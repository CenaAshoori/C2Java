#include <util/base.h>
#include <util/circlebuf.h>
#include <util/darray.h>
#include <obs-module.h>

#include <libavformat/avformat.h>

#include "obs-ffmpeg-formats.h"
#include "obs-ffmpeg-compat.h"

#define do_log(level, format, ...) \
	blog(level, "[FFmpeg aac encoder: '%s'] " format, \
			obs_encoder_get_name(enc->encoder), ##__VA_ARGS__)

#define warn(format, ...)  do_log(LOG_WARNING, format, ##__VA_ARGS__)
#define info(format, ...)  do_log(LOG_INFO,    format, ##__VA_ARGS__)
#define debug(format, ...) do_log(LOG_DEBUG,   format, ##__VA_ARGS__)

struct aac_encoder {
	obs_encoder_t    *encoder;

	AVCodec          *aac;
	AVCodecContext   *context;

	uint8_t          *samples[MAX_AV_PLANES];
	AVFrame          *aframe;
	int64_t          total_samples;

	DARRAY(uint8_t)  packet_buffer;

	size_t           audio_planes;
	size_t           audio_size;

	int              frame_size; 
	int              frame_size_bytes;
};

static const char *aac_getname(void *unused)
{
	UNUSED_PARAMETER(unused);
	return obs_module_text("FFmpegAAC");
}

static void aac_destroy(void *data)
{
	struct aac_encoder *enc = data;

	if (enc->samples[0])
		av_freep(&enc->samples[0]);
	if (enc->context)
		avcodec_close(enc->context);
	if (enc->aframe)
		av_frame_free(&enc->aframe);

	da_free(enc->packet_buffer);
	bfree(enc);
}

static bool initialize_codec(struct aac_encoder *enc)
{
	int ret;

	enc->aframe  = av_frame_alloc();
	if (!enc->aframe) {
		warn("Failed to allocate audio frame");
		return false;
	}

	ret = avcodec_open2(enc->context, enc->aac, NULL);
	if (ret < 0) {
		warn("Failed to open AAC codec: %s", av_err2str(ret));
		return false;
	}

	enc->frame_size = enc->context->frame_size;
	if (!enc->frame_size)
		enc->frame_size = 1024;

	enc->frame_size_bytes = enc->frame_size * (int)enc->audio_size;

	ret = av_samples_alloc(enc->samples, NULL, enc->context->channels,
			enc->frame_size, enc->context->sample_fmt, 0);
	if (ret < 0) {
		warn("Failed to create audio buffer: %s", av_err2str(ret));
		return false;
	}

	return true;
}

static void init_sizes(struct aac_encoder *enc, audio_t *audio)
{
	const struct audio_output_info *aoi;
	enum audio_format format;

	aoi    = audio_output_get_info(audio);
	format = convert_ffmpeg_sample_format(enc->context->sample_fmt);

	enc->audio_planes = get_audio_planes(format, aoi->speakers);
	enc->audio_size   = get_audio_size(format, aoi->speakers, 1);
}

#ifndef MIN
#define MIN(x, y) ((x) < (y) ? (x) : (y))
#endif

static void *aac_create(obs_data_t *settings, obs_encoder_t *encoder)
{
	struct aac_encoder *enc;
	int                bitrate = (int)obs_data_get_int(settings, "bitrate");
	audio_t            *audio   = obs_encoder_audio(encoder);

	avcodec_register_all();

	enc          = bzalloc(sizeof(struct aac_encoder));
	enc->encoder = encoder;
	enc->aac     = avcodec_find_encoder(AV_CODEC_ID_AAC);

	blog(LOG_INFO, "---------------------------------");

	if (!enc->aac) {
		warn("Couldn't find encoder");
		goto fail;
	}

	if (!bitrate) {
		warn("Invalid bitrate specified");
		return NULL;
	}

	enc->context = avcodec_alloc_context3(enc->aac);
	if (!enc->context) {
		warn("Failed to create codec context");
		goto fail;
	}

	enc->context->bit_rate    = bitrate * 1000;
	enc->context->channels    = (int)audio_output_get_channels(audio);
	enc->context->sample_rate = audio_output_get_sample_rate(audio);
	enc->context->sample_fmt  = enc->aac->sample_fmts ?
		enc->aac->sample_fmts[0] : AV_SAMPLE_FMT_FLTP;


	if (strcmp(enc->aac->name, "aac") == 0) {
		int cutoff1 = 4000 + (int)enc->context->bit_rate / 8;
		int cutoff2 = 12000 + (int)enc->context->bit_rate / 8;
		int cutoff3 = enc->context->sample_rate / 2;
		int cutoff;

		cutoff = MIN(cutoff1, cutoff2);
		cutoff = MIN(cutoff, cutoff3);
		enc->context->cutoff = cutoff;
	}

	info("bitrate: %" PRId64 ", channels: %d",
			enc->context->bit_rate / 1000, enc->context->channels);

	init_sizes(enc, audio);


	enc->context->strict_std_compliance = -2;

	enc->context->flags = CODEC_FLAG_GLOBAL_HEADER;

	if (initialize_codec(enc))
		return enc;

fail:
	aac_destroy(enc);
	return NULL;
}

static bool do_aac_encode(struct aac_encoder *enc,
		struct encoder_packet *packet, bool *received_packet)
{
	AVRational time_base = {1, enc->context->sample_rate};
	AVPacket   avpacket  = {0};
	int        got_packet;
	int        ret;

	enc->aframe->nb_samples = enc->frame_size;
	enc->aframe->pts = av_rescale_q(enc->total_samples,
			(AVRational){1, enc->context->sample_rate},
			enc->context->time_base);

	ret = avcodec_fill_audio_frame(enc->aframe, enc->context->channels,
			enc->context->sample_fmt, enc->samples[0],
			enc->frame_size_bytes * enc->context->channels, 1);
	if (ret < 0) {
		warn("avcodec_fill_audio_frame failed: %s", av_err2str(ret));
		return false;
	}

	enc->total_samples += enc->frame_size;

	ret = avcodec_encode_audio2(enc->context, &avpacket, enc->aframe,
			&got_packet);
	if (ret < 0) {
		warn("avcodec_encode_audio2 failed: %s", av_err2str(ret));
		return false;
	}

	*received_packet = !!got_packet;
	if (!got_packet)
		return true;

	da_resize(enc->packet_buffer, 0);
	da_push_back_array(enc->packet_buffer, avpacket.data, avpacket.size);

	packet->pts  = rescale_ts(avpacket.pts, enc->context, time_base);
	packet->dts  = rescale_ts(avpacket.dts, enc->context, time_base);
	packet->data = enc->packet_buffer.array;
	packet->size = avpacket.size;
	packet->type = OBS_ENCODER_AUDIO;
	packet->timebase_num = 1;
	packet->timebase_den = (int32_t)enc->context->sample_rate;
	av_free_packet(&avpacket);
	return true;
}

static bool aac_encode(void *data, struct encoder_frame *frame,
		struct encoder_packet *packet, bool *received_packet)
{
	struct aac_encoder *enc = data;

	for (size_t i = 0; i < enc->audio_planes; i++)
		memcpy(enc->samples[i], frame->data[i], enc->frame_size_bytes);

	return do_aac_encode(enc, packet, received_packet);
}

static void aac_defaults(obs_data_t *settings)
{
	obs_data_set_default_int(settings, "bitrate", 128);
}

static obs_properties_t *aac_properties(void *unused)
{
	UNUSED_PARAMETER(unused);

	obs_properties_t *props = obs_properties_create();

	obs_properties_add_int(props, "bitrate",
			obs_module_text("Bitrate"), 64, 320, 32);
	return props;
}

static bool aac_extra_data(void *data, uint8_t **extra_data, size_t *size)
{
	struct aac_encoder *enc = data;

	*extra_data = enc->context->extradata;
	*size       = enc->context->extradata_size;
	return true;
}

static void aac_audio_info(void *data, struct audio_convert_info *info)
{
	struct aac_encoder *enc = data;
	info->format = convert_ffmpeg_sample_format(enc->context->sample_fmt);
}

static size_t aac_frame_size(void *data)
{
	struct aac_encoder *enc =data;
	return enc->frame_size;
}

struct obs_encoder_info aac_encoder_info = {
	.id             = "ffmpeg_aac",
	.type           = OBS_ENCODER_AUDIO,
	.codec          = "AAC",
	.get_name       = aac_getname,
	.create         = aac_create,
	.destroy        = aac_destroy,
	.encode         = aac_encode,
	.get_frame_size = aac_frame_size,
	.get_defaults   = aac_defaults,
	.get_properties = aac_properties,
	.get_extra_data = aac_extra_data,
	.get_audio_info = aac_audio_info
};
<code block>
#include <util/base.h>
#include <util/circlebuf.h>
#include <util/darray.h>
#include <obs-module.h>

#include <libavformat/avformat.h>

#include "obs-ffmpeg-formats.h"
#include "obs-ffmpeg-compat.h"

#define do_log(level, format, ...) \
	blog(level, "[FFmpeg aac encoder: '%s'] " format, \
			obs_encoder_get_name(enc->encoder), ##__VA_ARGS__)

#define warn(format, ...)  do_log(LOG_WARNING, format, ##__VA_ARGS__)
#define info(format, ...)  do_log(LOG_INFO,    format, ##__VA_ARGS__)
#define debug(format, ...) do_log(LOG_DEBUG,   format, ##__VA_ARGS__)

struct aac_encoder {
	obs_encoder_t    *encoder;

	AVCodec          *aac;
	AVCodecContext   *context;

	uint8_t          *samples[MAX_AV_PLANES];
	AVFrame          *aframe;
	int64_t          total_samples;

	DARRAY(uint8_t)  packet_buffer;

	size_t           audio_planes;
	size_t           audio_size;

	int              frame_size; 
	int              frame_size_bytes;
};

static const char *aac_getname(void *unused)
{
	UNUSED_PARAMETER(unused);
	return obs_module_text("FFmpegAAC");
}

static void aac_destroy(void *data)
{
	struct aac_encoder *enc = data;

	if (enc->samples[0])
		av_freep(&enc->samples[0]);
	if (enc->context)
		avcodec_close(enc->context);
	if (enc->aframe)
		av_frame_free(&enc->aframe);

	da_free(enc->packet_buffer);
	bfree(enc);
}

static bool initialize_codec(struct aac_encoder *enc)
{
	int ret;

	enc->aframe  = av_frame_alloc();
	if (!enc->aframe) {
		warn("Failed to allocate audio frame");
		return false;
	}

	ret = avcodec_open2(enc->context, enc->aac, NULL);
	if (ret < 0) {
		warn("Failed to open AAC codec: %s", av_err2str(ret));
		return false;
	}

	enc->frame_size = enc->context->frame_size;
	if (!enc->frame_size)
		enc->frame_size = 1024;

	enc->frame_size_bytes = enc->frame_size * (int)enc->audio_size;

	ret = av_samples_alloc(enc->samples, NULL, enc->context->channels,
			enc->frame_size, enc->context->sample_fmt, 0);
	if (ret < 0) {
		warn("Failed to create audio buffer: %s", av_err2str(ret));
		return false;
	}

	return true;
}

static void init_sizes(struct aac_encoder *enc, audio_t *audio)
{
	const struct audio_output_info *aoi;
	enum audio_format format;

	aoi    = audio_output_get_info(audio);
	format = convert_ffmpeg_sample_format(enc->context->sample_fmt);

	enc->audio_planes = get_audio_planes(format, aoi->speakers);
	enc->audio_size   = get_audio_size(format, aoi->speakers, 1);
}

#ifndef MIN
#define MIN(x, y) ((x) < (y) ? (x) : (y))
#endif

static void *aac_create(obs_data_t *settings, obs_encoder_t *encoder)
{
	struct aac_encoder *enc;
	int                bitrate = (int)obs_data_get_int(settings, "bitrate");
	audio_t            *audio   = obs_encoder_audio(encoder);

	avcodec_register_all();

	enc          = bzalloc(sizeof(struct aac_encoder));
	enc->encoder = encoder;
	enc->aac     = avcodec_find_encoder(AV_CODEC_ID_AAC);

	blog(LOG_INFO, "---------------------------------");

	if (!enc->aac) {
		warn("Couldn't find encoder");
		goto fail;
	}

	if (!bitrate) {
		warn("Invalid bitrate specified");
		return NULL;
	}

	enc->context = avcodec_alloc_context3(enc->aac);
	if (!enc->context) {
		warn("Failed to create codec context");
		goto fail;
	}

	enc->context->bit_rate    = bitrate * 1000;
	enc->context->channels    = (int)audio_output_get_channels(audio);
	enc->context->sample_rate = audio_output_get_sample_rate(audio);
	enc->context->sample_fmt  = enc->aac->sample_fmts ?
		enc->aac->sample_fmts[0] : AV_SAMPLE_FMT_FLTP;


	if (strcmp(enc->aac->name, "aac") == 0) {
		int cutoff1 = 4000 + (int)enc->context->bit_rate / 8;
		int cutoff2 = 12000 + (int)enc->context->bit_rate / 8;
		int cutoff3 = enc->context->sample_rate / 2;
		int cutoff;

		cutoff = MIN(cutoff1, cutoff2);
		cutoff = MIN(cutoff, cutoff3);
		enc->context->cutoff = cutoff;
	}

	info("bitrate: %" PRId64 ", channels: %d",
			enc->context->bit_rate / 1000, enc->context->channels);

	init_sizes(enc, audio);


	enc->context->strict_std_compliance = -2;

	enc->context->flags = CODEC_FLAG_GLOBAL_HEADER;

	if (initialize_codec(enc))
		return enc;

fail:
	aac_destroy(enc);
	return NULL;
}

static bool do_aac_encode(struct aac_encoder *enc,
		struct encoder_packet *packet, bool *received_packet)
{
	AVRational time_base = {1, enc->context->sample_rate};
	AVPacket   avpacket  = {0};
	int        got_packet;
	int        ret;

	enc->aframe->nb_samples = enc->frame_size;
	enc->aframe->pts = av_rescale_q(enc->total_samples,
			(AVRational){1, enc->context->sample_rate},
			enc->context->time_base);

	ret = avcodec_fill_audio_frame(enc->aframe, enc->context->channels,
			enc->context->sample_fmt, enc->samples[0],
			enc->frame_size_bytes * enc->context->channels, 1);
	if (ret < 0) {
		warn("avcodec_fill_audio_frame failed: %s", av_err2str(ret));
		return false;
	}

	enc->total_samples += enc->frame_size;

	ret = avcodec_encode_audio2(enc->context, &avpacket, enc->aframe,
			&got_packet);
	if (ret < 0) {
		warn("avcodec_encode_audio2 failed: %s", av_err2str(ret));
		return false;
	}

	*received_packet = !!got_packet;
	if (!got_packet)
		return true;

	da_resize(enc->packet_buffer, 0);
	da_push_back_array(enc->packet_buffer, avpacket.data, avpacket.size);

	packet->pts  = rescale_ts(avpacket.pts, enc->context, time_base);
	packet->dts  = rescale_ts(avpacket.dts, enc->context, time_base);
	packet->data = enc->packet_buffer.array;
	packet->size = avpacket.size;
	packet->type = OBS_ENCODER_AUDIO;
	packet->timebase_num = 1;
	packet->timebase_den = (int32_t)enc->context->sample_rate;
	av_free_packet(&avpacket);
	return true;
}

static bool aac_encode(void *data, struct encoder_frame *frame,
		struct encoder_packet *packet, bool *received_packet)
{
	struct aac_encoder *enc = data;

	for (size_t i = 0; i < enc->audio_planes; i++)
		memcpy(enc->samples[i], frame->data[i], enc->frame_size_bytes);

	return do_aac_encode(enc, packet, received_packet);
}

static void aac_defaults(obs_data_t *settings)
{
	obs_data_set_default_int(settings, "bitrate", 128);
}

static obs_properties_t *aac_properties(void *unused)
{
	UNUSED_PARAMETER(unused);

	obs_properties_t *props = obs_properties_create();

	obs_properties_add_int(props, "bitrate",
			obs_module_text("Bitrate"), 64, 320, 32);
	return props;
}

static bool aac_extra_data(void *data, uint8_t **extra_data, size_t *size)
{
	struct aac_encoder *enc = data;

	*extra_data = enc->context->extradata;
	*size       = enc->context->extradata_size;
	return true;
}

static void aac_audio_info(void *data, struct audio_convert_info *info)
{
	struct aac_encoder *enc = data;
	info->format = convert_ffmpeg_sample_format(enc->context->sample_fmt);
}

static size_t aac_frame_size(void *data)
{
	struct aac_encoder *enc =data;
	return enc->frame_size;
}

struct obs_encoder_info aac_encoder_info = {
	.id             = "ffmpeg_aac",
	.type           = OBS_ENCODER_AUDIO,
	.codec          = "AAC",
	.get_name       = aac_getname,
	.create         = aac_create,
	.destroy        = aac_destroy,
	.encode         = aac_encode,
	.get_frame_size = aac_frame_size,
	.get_defaults   = aac_defaults,
	.get_properties = aac_properties,
	.get_extra_data = aac_extra_data,
	.get_audio_info = aac_audio_info
};
<code block>
#include <inttypes.h>

#include "media-io/format-conversion.h"
#include "media-io/video-frame.h"
#include "media-io/audio-io.h"
#include "util/threading.h"
#include "util/platform.h"
#include "callback/calldata.h"
#include "graphics/matrix3.h"
#include "graphics/vec3.h"

#include "obs.h"
#include "obs-internal.h"

static inline bool source_valid(struct obs_source *source)
{
	return source && source->context.data;
}

const struct obs_source_info *find_source(struct darray *list, const char *id)
{
	size_t i;
	struct obs_source_info *array = list->array;

	for (i = 0; i < list->num; i++) {
		struct obs_source_info *info = array+i;
		if (strcmp(info->id, id) == 0)
			return info;
	}

	return NULL;
}

static const struct obs_source_info *get_source_info(enum obs_source_type type,
		const char *id)
{
	struct darray *list = NULL;

	switch (type) {
	case OBS_SOURCE_TYPE_INPUT:
		list = &obs->input_types.da;
		break;

	case OBS_SOURCE_TYPE_FILTER:
		list = &obs->filter_types.da;
		break;

	case OBS_SOURCE_TYPE_TRANSITION:
		list = &obs->transition_types.da;
		break;
	}

	return find_source(list, id);
}

static const char *source_signals[] = {
	"void destroy(ptr source)",
	"void add(ptr source)",
	"void remove(ptr source)",
	"void activate(ptr source)",
	"void deactivate(ptr source)",
	"void show(ptr source)",
	"void hide(ptr source)",
	"void rename(ptr source, string new_name, string prev_name)",
	"void volume(ptr source, in out float volume)",
	"void volume_level(ptr source, float level, float magnitude, "
		"float peak)",
	NULL
};

bool obs_source_init_context(struct obs_source *source,
		obs_data_t settings, const char *name)
{
	if (!obs_context_data_init(&source->context, settings, name))
		return false;

	return signal_handler_add_array(source->context.signals,
			source_signals);
}

const char *obs_source_getdisplayname(enum obs_source_type type, const char *id)
{
	const struct obs_source_info *info = get_source_info(type, id);
	return (info != NULL) ? info->getname() : NULL;
}


bool obs_source_init(struct obs_source *source,
		const struct obs_source_info *info)
{
	source->refs = 1;
	source->user_volume = 1.0f;
	source->present_volume = 0.0f;
	source->sync_offset = 0;
	pthread_mutex_init_value(&source->filter_mutex);
	pthread_mutex_init_value(&source->video_mutex);
	pthread_mutex_init_value(&source->audio_mutex);

	if (pthread_mutex_init(&source->filter_mutex, NULL) != 0)
		return false;
	if (pthread_mutex_init(&source->audio_mutex, NULL) != 0)
		return false;
	if (pthread_mutex_init(&source->video_mutex, NULL) != 0)
		return false;

	if (info && info->output_flags & OBS_SOURCE_AUDIO) {
		source->audio_line = audio_output_createline(obs->audio.audio,
				source->context.name);
		if (!source->audio_line) {
			blog(LOG_ERROR, "Failed to create audio line for "
			                "source '%s'", source->context.name);
			return false;
		}
	}

	obs_context_data_insert(&source->context,
			&obs->data.sources_mutex,
			&obs->data.first_source);
	return true;
}

static inline void obs_source_dosignal(struct obs_source *source,
		const char *signal_obs, const char *signal_source)
{
	struct calldata data;

	calldata_init(&data);
	calldata_setptr(&data, "source", source);
	if (signal_obs)
		signal_handler_signal(obs->signals, signal_obs, &data);
	if (signal_source)
		signal_handler_signal(source->context.signals, signal_source,
				&data);
	calldata_free(&data);
}

obs_source_t obs_source_create(enum obs_source_type type, const char *id,
		const char *name, obs_data_t settings)
{
	struct obs_source *source = bzalloc(sizeof(struct obs_source));

	const struct obs_source_info *info = get_source_info(type, id);
	if (!info) {
		blog(LOG_ERROR, "Source ID '%s' not found", id);

		source->info.id      = bstrdup(id);
		source->info.type    = type;
		source->owns_info_id = true;
	} else {
		source->info = *info;
	}

	if (!obs_source_init_context(source, settings, name))
		goto fail;

	if (info && info->defaults)
		info->defaults(source->context.settings);


	if (info)
		source->context.data = info->create(source->context.settings,
				source);
	if (!source->context.data)
		blog(LOG_ERROR, "Failed to create source '%s'!", name);

	if (!obs_source_init(source, info))
		goto fail;

	blog(LOG_INFO, "source '%s' (%s) created", name, id);
	obs_source_dosignal(source, "source_create", NULL);
	return source;

fail:
	blog(LOG_ERROR, "obs_source_create failed");
	obs_source_destroy(source);
	return NULL;
}

void source_frame_init(struct source_frame *frame, enum video_format format,
		uint32_t width, uint32_t height)
{
	struct video_frame vid_frame;

	if (!frame)
		return;

	video_frame_init(&vid_frame, format, width, height);
	frame->format = format;
	frame->width  = width;
	frame->height = height;

	for (size_t i = 0; i < MAX_AV_PLANES; i++) {
		frame->data[i]     = vid_frame.data[i];
		frame->linesize[i] = vid_frame.linesize[i];
	}
}

void obs_source_destroy(struct obs_source *source)
{
	size_t i;

	if (!source)
		return;

	obs_context_data_remove(&source->context);

	blog(LOG_INFO, "source '%s' destroyed", source->context.name);

	obs_source_dosignal(source, "source_destroy", "destroy");

	if (source->context.data) {
		source->info.destroy(source->context.data);
		source->context.data = NULL;
	}

	if (source->filter_parent)
		obs_source_filter_remove(source->filter_parent, source);

	for (i = 0; i < source->filters.num; i++)
		obs_source_release(source->filters.array[i]);

	for (i = 0; i < source->video_frames.num; i++)
		source_frame_destroy(source->video_frames.array[i]);

	gs_entercontext(obs->video.graphics);
	texrender_destroy(source->async_convert_texrender);
	texture_destroy(source->async_texture);
	gs_leavecontext();

	for (i = 0; i < MAX_AV_PLANES; i++)
		bfree(source->audio_data.data[i]);

	audio_line_destroy(source->audio_line);
	audio_resampler_destroy(source->resampler);

	texrender_destroy(source->filter_texrender);
	da_free(source->video_frames);
	da_free(source->filters);
	pthread_mutex_destroy(&source->filter_mutex);
	pthread_mutex_destroy(&source->audio_mutex);
	pthread_mutex_destroy(&source->video_mutex);
	obs_context_data_free(&source->context);
	
	if (source->owns_info_id)
		bfree((void*)source->info.id);

	bfree(source);
}

void obs_source_addref(obs_source_t source)
{
	if (source)
		os_atomic_inc_long(&source->refs);
}

void obs_source_release(obs_source_t source)
{
	if (!source)
		return;

	if (os_atomic_dec_long(&source->refs) == 0)
		obs_source_destroy(source);
}

void obs_source_remove(obs_source_t source)
{
	struct obs_core_data *data = &obs->data;
	size_t id;
	bool   exists;

	pthread_mutex_lock(&data->sources_mutex);

	if (!source || source->removed) {
		pthread_mutex_unlock(&data->sources_mutex);
		return;
	}

	source->removed = true;

	obs_source_addref(source);

	id = da_find(data->user_sources, &source, 0);
	exists = (id != DARRAY_INVALID);
	if (exists) {
		da_erase(data->user_sources, id);
		obs_source_release(source);
	}

	pthread_mutex_unlock(&data->sources_mutex);

	if (exists)
		obs_source_dosignal(source, "source_remove", "remove");

	obs_source_release(source);
}

bool obs_source_removed(obs_source_t source)
{
	return source ? source->removed : true;
}

static inline obs_data_t get_defaults(const struct obs_source_info *info)
{
	obs_data_t settings = obs_data_create();
	if (info->defaults)
		info->defaults(settings);
	return settings;
}

obs_data_t obs_source_settings(enum obs_source_type type, const char *id)
{
	const struct obs_source_info *info = get_source_info(type, id);
	return (info) ? get_defaults(info) : NULL;
}

obs_properties_t obs_get_source_properties(enum obs_source_type type,
		const char *id)
{
	const struct obs_source_info *info = get_source_info(type, id);
	if (info && info->properties) {
		obs_data_t       defaults = get_defaults(info);
		obs_properties_t properties;

		properties = info->properties();
		obs_properties_apply_settings(properties, defaults);
		obs_data_release(defaults);
		return properties;
	}
	return NULL;
}

obs_properties_t obs_source_properties(obs_source_t source)
{
	if (source_valid(source) && source->info.properties) {
		obs_properties_t props;
		props = source->info.properties();
		obs_properties_apply_settings(props, source->context.settings);
		return props;
	}

	return NULL;
}

uint32_t obs_source_get_output_flags(obs_source_t source)
{
	return source ? source->info.output_flags : 0;
}

static void obs_source_deferred_update(obs_source_t source)
{
	if (source->context.data && source->info.update)
		source->info.update(source->context.data,
				source->context.settings);

	source->defer_update = false;
}

void obs_source_update(obs_source_t source, obs_data_t settings)
{
	if (!source) return;

	if (settings)
		obs_data_apply(source->context.settings, settings);

	if (source->info.output_flags & OBS_SOURCE_VIDEO) {
		source->defer_update = true;
	} else if (source->context.data && source->info.update) {
		source->info.update(source->context.data,
				source->context.settings);
	}
}

static void activate_source(obs_source_t source)
{
	if (source->context.data && source->info.activate)
		source->info.activate(source->context.data);
	obs_source_dosignal(source, "source_activate", "activate");
}

static void deactivate_source(obs_source_t source)
{
	if (source->context.data && source->info.deactivate)
		source->info.deactivate(source->context.data);
	obs_source_dosignal(source, "source_deactivate", "deactivate");
}

static void show_source(obs_source_t source)
{
	if (source->context.data && source->info.show)
		source->info.show(source->context.data);
	obs_source_dosignal(source, "source_show", "show");
}

static void hide_source(obs_source_t source)
{
	if (source->context.data && source->info.hide)
		source->info.hide(source->context.data);
	obs_source_dosignal(source, "source_hide", "hide");
}

static void activate_tree(obs_source_t parent, obs_source_t child, void *param)
{
	if (os_atomic_inc_long(&child->activate_refs) == 1)
		activate_source(child);

	UNUSED_PARAMETER(parent);
	UNUSED_PARAMETER(param);
}

static void deactivate_tree(obs_source_t parent, obs_source_t child,
		void *param)
{
	if (os_atomic_dec_long(&child->activate_refs) == 0)
		deactivate_source(child);

	UNUSED_PARAMETER(parent);
	UNUSED_PARAMETER(param);
}

static void show_tree(obs_source_t parent, obs_source_t child, void *param)
{
	if (os_atomic_inc_long(&child->show_refs) == 1)
		show_source(child);

	UNUSED_PARAMETER(parent);
	UNUSED_PARAMETER(param);
}

static void hide_tree(obs_source_t parent, obs_source_t child, void *param)
{
	if (os_atomic_dec_long(&child->show_refs) == 0)
		hide_source(child);

	UNUSED_PARAMETER(parent);
	UNUSED_PARAMETER(param);
}

void obs_source_activate(obs_source_t source, enum view_type type)
{
	if (!source) return;

	if (os_atomic_inc_long(&source->show_refs) == 1) {
		show_source(source);
		obs_source_enum_tree(source, show_tree, NULL);
	}

	if (type == MAIN_VIEW) {
		if (os_atomic_inc_long(&source->activate_refs) == 1) {
			activate_source(source);
			obs_source_enum_tree(source, activate_tree, NULL);
			obs_source_set_present_volume(source, 1.0f);
		}
	}
}

void obs_source_deactivate(obs_source_t source, enum view_type type)
{
	if (!source) return;

	if (os_atomic_dec_long(&source->show_refs) == 0) {
		hide_source(source);
		obs_source_enum_tree(source, hide_tree, NULL);
	}

	if (type == MAIN_VIEW) {
		if (os_atomic_dec_long(&source->activate_refs) == 0) {
			deactivate_source(source);
			obs_source_enum_tree(source, deactivate_tree, NULL);
			obs_source_set_present_volume(source, 0.0f);
		}
	}
}

void obs_source_video_tick(obs_source_t source, float seconds)
{
	if (!source) return;

	if (source->defer_update)
		obs_source_deferred_update(source);


	if (source->filter_texrender)
		texrender_reset(source->filter_texrender);

	if (source->context.data && source->info.video_tick)
		source->info.video_tick(source->context.data, seconds);
}


static inline uint64_t conv_frames_to_time(size_t frames)
{
	const struct audio_output_info *info;
	info = audio_output_getinfo(obs->audio.audio);

	return (uint64_t)frames * 1000000000ULL /
		(uint64_t)info->samples_per_sec;
}


#define MAX_TS_VAR          5000000000ULL

#define MAX_TIMESTAMP_JUMP  2000000000ULL

#define TS_SMOOTHING_THRESHOLD 70000000ULL

static inline void reset_audio_timing(obs_source_t source, uint64_t timetamp)
{
	source->timing_set    = true;
	source->timing_adjust = os_gettime_ns() - timetamp;
}

static inline void handle_ts_jump(obs_source_t source, uint64_t expected,
		uint64_t ts, uint64_t diff)
{
	blog(LOG_DEBUG, "Timestamp for source '%s' jumped by '%"PRIu64"', "
	                "expected value %"PRIu64", input value %"PRIu64,
	                source->context.name, diff, expected, ts);


	if (source->info.output_flags & OBS_SOURCE_ASYNC)
		os_atomic_dec_long(&source->av_sync_ref);
	else
		reset_audio_timing(source, ts);
}

#define VOL_MIN -96.0f
#define VOL_MAX  0.0f

static inline float to_db(float val)
{
	float db = 20.0f * log10f(val);
	return isfinite(db) ? db : VOL_MIN;
}

static void calc_volume_levels(struct obs_source *source, float *array,
		size_t frames, float volume)
{
	float sum_val = 0.0f;
	float max_val = 0.0f;
	float rms_val = 0.0f;

	const uint32_t sample_rate    = audio_output_samplerate(obs_audio());
	const size_t   channels       = audio_output_channels(obs_audio());
	const size_t   count          = frames * channels;
	const size_t   vol_peak_delay = sample_rate * 3;
	const float    alpha          = 0.15f;

	for (size_t i = 0; i < count; i++) {
		float val      = array[i];
		float val_pow2 = val * val;

		sum_val += val_pow2;
		max_val  = fmaxf(max_val, val_pow2);
	}



	UNUSED_PARAMETER(volume);

	rms_val = to_db(sqrtf(sum_val / (float)count));
	max_val = to_db(sqrtf(max_val));

	if (max_val > source->vol_max)
		source->vol_max = max_val;
	else
		source->vol_max = alpha * source->vol_max +
			(1.0f - alpha) * max_val;

	if (source->vol_max > source->vol_peak ||
	    source->vol_update_count > vol_peak_delay) {
		source->vol_peak         = source->vol_max;
		source->vol_update_count = 0;
	} else {
		source->vol_update_count += count;
	}

	source->vol_mag = alpha * rms_val + source->vol_mag * (1.0f - alpha);
}


static void obs_source_update_volume_level(obs_source_t source,
		struct audio_data *in)
{
	if (source && in) {
		struct calldata data = {0};

		calc_volume_levels(source, (float*)in->data[0], in->frames,
				in->volume);

		calldata_setptr  (&data, "source",    source);
		calldata_setfloat(&data, "level",     source->vol_max);
		calldata_setfloat(&data, "magnitude", source->vol_mag);
		calldata_setfloat(&data, "peak",      source->vol_peak);

		signal_handler_signal(source->context.signals, "volume_level",
				&data);
		signal_handler_signal(obs->signals, "source_volume_level",
				&data);

		calldata_free(&data);
	}
}

static void source_output_audio_line(obs_source_t source,
		const struct audio_data *data)
{
	struct audio_data in = *data;
	uint64_t diff;

	if (!source->timing_set) {
		reset_audio_timing(source, in.timestamp);


		if ((source->timing_adjust + MAX_TS_VAR) < MAX_TS_VAR * 2)
			source->timing_adjust = 0;

	} else {
		bool ts_under = (in.timestamp < source->next_audio_ts_min);

		diff = ts_under ?
			(source->next_audio_ts_min - in.timestamp) :
			(in.timestamp - source->next_audio_ts_min);


		if (diff > MAX_TIMESTAMP_JUMP)
			handle_ts_jump(source, source->next_audio_ts_min,
					in.timestamp, diff);
		else if (ts_under || diff < TS_SMOOTHING_THRESHOLD)
			in.timestamp = source->next_audio_ts_min;
	}

	source->next_audio_ts_min = in.timestamp +
		conv_frames_to_time(in.frames);

	if (source->av_sync_ref != 0)
		return;

	in.timestamp += source->timing_adjust + source->sync_offset;
	in.volume = source->user_volume * source->present_volume *
		obs->audio.user_volume * obs->audio.present_volume;

	audio_line_output(source->audio_line, &in);
	obs_source_update_volume_level(source, &in);
}

enum convert_type {
	CONVERT_NONE,
	CONVERT_NV12,
	CONVERT_420,
	CONVERT_422_U,
	CONVERT_422_Y,
};

static inline enum convert_type get_convert_type(enum video_format format)
{
	switch (format) {
	case VIDEO_FORMAT_I420:
		return CONVERT_420;
	case VIDEO_FORMAT_NV12:
		return CONVERT_NV12;

	case VIDEO_FORMAT_YVYU:
	case VIDEO_FORMAT_YUY2:
		return CONVERT_422_Y;
	case VIDEO_FORMAT_UYVY:
		return CONVERT_422_U;

	case VIDEO_FORMAT_NONE:
	case VIDEO_FORMAT_RGBA:
	case VIDEO_FORMAT_BGRA:
	case VIDEO_FORMAT_BGRX:
		return CONVERT_NONE;
	}

	return CONVERT_NONE;
}

static inline bool set_packed422_sizes(struct obs_source *source,
		struct source_frame *frame)
{
	source->async_convert_height = frame->height;
	source->async_convert_width  = frame->width / 2;
	source->async_texture_format = GS_BGRA;
	return true;
}

static inline bool set_planar420_sizes(struct obs_source *source,
		struct source_frame *frame)
{
	uint32_t size = frame->width * frame->height;
	size += size/2;

	source->async_convert_width   = frame->width;
	source->async_convert_height  = (size / frame->width + 1) & 0xFFFFFFFE;
	source->async_texture_format  = GS_R8;
	source->async_plane_offset[0] = frame->width * frame->height;
	source->async_plane_offset[1] = source->async_plane_offset[0] +
		frame->width * frame->height / 4;
	return true;
}

static inline bool init_gpu_conversion(struct obs_source *source,
		struct source_frame *frame)
{
	switch (get_convert_type(frame->format)) {
		case CONVERT_422_Y:
		case CONVERT_422_U:
			return set_packed422_sizes(source, frame);

		case CONVERT_420:
			return set_planar420_sizes(source, frame);

		case CONVERT_NV12:
			assert(false && "NV12 not yet implemented");

			break;

		case CONVERT_NONE:
			assert(false && "No conversion requested");
			break;

	}
	return false;
}

static inline enum gs_color_format convert_video_format(
		enum video_format format)
{
	if (format == VIDEO_FORMAT_RGBA)
		return GS_RGBA;
	else if (format == VIDEO_FORMAT_BGRA)
		return GS_BGRA;

	return GS_BGRX;
}

static inline bool set_async_texture_size(struct obs_source *source,
		struct source_frame *frame)
{
	enum convert_type prev, cur;
	prev = get_convert_type(source->async_format);
	cur  = get_convert_type(frame->format);
	if (source->async_texture) {
		if (source->async_width  == frame->width &&
		    source->async_height == frame->height &&
		    prev == cur)
			return true;
	}

	texture_destroy(source->async_texture);
	texrender_destroy(source->async_convert_texrender);
	source->async_convert_texrender = NULL;

	if (cur != CONVERT_NONE && init_gpu_conversion(source, frame)) {
		source->async_gpu_conversion = true;

		source->async_convert_texrender =
			texrender_create(GS_BGRX, GS_ZS_NONE);

		source->async_texture = gs_create_texture(
				source->async_convert_width,
				source->async_convert_height,
				source->async_texture_format,
				1, NULL, GS_DYNAMIC);

	} else {
		enum gs_color_format format = convert_video_format(
				frame->format);
		source->async_gpu_conversion = false;

		source->async_texture = gs_create_texture(
				frame->width, frame->height,
				format, 1, NULL, GS_DYNAMIC);
	}

	if (!source->async_texture)
		return false;

	source->async_width  = frame->width;
	source->async_height = frame->height;
	return true;
}

static void upload_raw_frame(texture_t tex, const struct source_frame *frame)
{
	switch (get_convert_type(frame->format)) {
		case CONVERT_422_U:
		case CONVERT_422_Y:
			texture_setimage(tex, frame->data[0],
					frame->linesize[0], false);
			break;

		case CONVERT_420:
			texture_setimage(tex, frame->data[0],
					frame->width, false);
			break;

		case CONVERT_NV12:
			assert(false && "Conversion not yet implemented");
			break;

		case CONVERT_NONE:
			assert(false && "No conversion requested");
			break;
	}
}

static const char *select_conversion_technique(enum video_format format)
{
	switch (format) {
		case VIDEO_FORMAT_UYVY:
			return "UYVY_Reverse";

		case VIDEO_FORMAT_YUY2:
			return "YUY2_Reverse";

		case VIDEO_FORMAT_YVYU:
			return "YVYU_Reverse";

		case VIDEO_FORMAT_I420:
			return "I420_Reverse";

		case VIDEO_FORMAT_NV12:
			assert(false && "Conversion not yet implemented");
			break;

		case VIDEO_FORMAT_BGRA:
		case VIDEO_FORMAT_BGRX:
		case VIDEO_FORMAT_RGBA:
		case VIDEO_FORMAT_NONE:
			assert(false && "No conversion requested");
			break;
	}
	return NULL;
}

static inline void set_eparam(effect_t effect, const char *name, float val)
{
	eparam_t param = effect_getparambyname(effect, name);
	effect_setfloat(param, val);
}

static bool update_async_texrender(struct obs_source *source,
		const struct source_frame *frame)
{
	texture_t   tex       = source->async_texture;
	texrender_t texrender = source->async_convert_texrender;

	texrender_reset(texrender);

	upload_raw_frame(tex, frame);

	uint32_t cx = source->async_width;
	uint32_t cy = source->async_height;

	float convert_width  = (float)source->async_convert_width;
	float convert_height = (float)source->async_convert_height;

	effect_t conv = obs->video.conversion_effect;
	technique_t tech = effect_gettechnique(conv,
			select_conversion_technique(frame->format));

	if (!texrender_begin(texrender, cx, cy))
		return false;

	technique_begin(tech);
	technique_beginpass(tech, 0);

	effect_settexture(effect_getparambyname(conv, "image"), tex);
	set_eparam(conv, "width",  (float)cx);
	set_eparam(conv, "height", (float)cy);
	set_eparam(conv, "width_i",  1.0f / cx);
	set_eparam(conv, "height_i", 1.0f / cy);
	set_eparam(conv, "width_d2",  cx * 0.5f);
	set_eparam(conv, "height_d2", cy * 0.5f);
	set_eparam(conv, "width_d2_i",  1.0f / (cx * 0.5f));
	set_eparam(conv, "height_d2_i", 1.0f / (cy * 0.5f));
	set_eparam(conv, "input_width",  convert_width);
	set_eparam(conv, "input_height", convert_height);
	set_eparam(conv, "input_width_i",  1.0f / convert_width);
	set_eparam(conv, "input_height_i", 1.0f / convert_height);
	set_eparam(conv, "input_width_i_d2",  (1.0f / convert_width)  * 0.5f);
	set_eparam(conv, "input_height_i_d2", (1.0f / convert_height) * 0.5f);
	set_eparam(conv, "u_plane_offset",
			(float)source->async_plane_offset[0]);
	set_eparam(conv, "v_plane_offset",
			(float)source->async_plane_offset[1]);

	gs_ortho(0.f, (float)cx, 0.f, (float)cy, -100.f, 100.f);

	gs_draw_sprite(tex, 0, cx, cy);

	technique_endpass(tech);
	technique_end(tech);

	texrender_end(texrender);

	return true;
}

static bool update_async_texture(struct obs_source *source,
		const struct source_frame *frame)
{
	texture_t         tex       = source->async_texture;
	texrender_t       texrender = source->async_convert_texrender;
	enum convert_type type      = get_convert_type(frame->format);
	uint8_t           *ptr;
	uint32_t          linesize;

	source->async_format     = frame->format;
	source->async_flip       = frame->flip;
	source->async_full_range = frame->full_range;
	memcpy(source->async_color_matrix, frame->color_matrix,
			sizeof(frame->color_matrix));
	memcpy(source->async_color_range_min, frame->color_range_min,
			sizeof frame->color_range_min);
	memcpy(source->async_color_range_max, frame->color_range_max,
			sizeof frame->color_range_max);

	if (source->async_gpu_conversion && texrender)
		return update_async_texrender(source, frame);

	if (type == CONVERT_NONE) {
		texture_setimage(tex, frame->data[0], frame->linesize[0],
				false);
		return true;
	}

	if (!texture_map(tex, &ptr, &linesize))
		return false;

	if (type == CONVERT_420)
		decompress_420((const uint8_t* const*)frame->data,
				frame->linesize,
				0, frame->height, ptr, linesize);

	else if (type == CONVERT_NV12)
		decompress_nv12((const uint8_t* const*)frame->data,
				frame->linesize,
				0, frame->height, ptr, linesize);

	else if (type == CONVERT_422_Y)
		decompress_422(frame->data[0], frame->linesize[0],
				0, frame->height, ptr, linesize, true);

	else if (type == CONVERT_422_U)
		decompress_422(frame->data[0], frame->linesize[0],
				0, frame->height, ptr, linesize, false);

	texture_unmap(tex);
	return true;
}

static inline void obs_source_draw_texture(struct obs_source *source,
		effect_t effect, float *color_matrix,
		float const *color_range_min, float const *color_range_max)
{
	texture_t tex = source->async_texture;
	eparam_t  param;

	if (source->async_convert_texrender)
		tex = texrender_gettexture(source->async_convert_texrender);

	if (color_range_min) {
		size_t const size = sizeof(float) * 3;
		param = effect_getparambyname(effect, "color_range_min");
		effect_setval(param, color_range_min, size);
	}

	if (color_range_max) {
		size_t const size = sizeof(float) * 3;
		param = effect_getparambyname(effect, "color_range_max");
		effect_setval(param, color_range_max, size);
	}

	if (color_matrix) {
		param = effect_getparambyname(effect, "color_matrix");
		effect_setval(param, color_matrix, sizeof(float) * 16);
	}

	param = effect_getparambyname(effect, "image");
	effect_settexture(param, tex);

	gs_draw_sprite(tex, source->async_flip ? GS_FLIP_V : 0, 0, 0);
}

static void obs_source_draw_async_texture(struct obs_source *source)
{
	effect_t    effect        = gs_geteffect();
	bool        yuv           = format_is_yuv(source->async_format);
	bool        limited_range = yuv && !source->async_full_range;
	const char  *type         = yuv ? "DrawMatrix" : "Draw";
	bool        def_draw      = (!effect);
	technique_t tech          = NULL;

	if (def_draw) {
		effect = obs_get_default_effect();
		tech = effect_gettechnique(effect, type);
		technique_begin(tech);
		technique_beginpass(tech, 0);
	}

	obs_source_draw_texture(source, effect,
			yuv ? source->async_color_matrix : NULL,
			limited_range ? source->async_color_range_min : NULL,
			limited_range ? source->async_color_range_max : NULL);

	if (def_draw) {
		technique_endpass(tech);
		technique_end(tech);
	}
}

static void obs_source_render_async_video(obs_source_t source)
{
	struct source_frame *frame = obs_source_get_frame(source);
	if (frame) {
		if (!set_async_texture_size(source, frame))
			return;
		if (!update_async_texture(source, frame))
			return;
	}

	if (source->async_texture)
		obs_source_draw_async_texture(source);

	obs_source_release_frame(source, frame);
}

static inline void obs_source_render_filters(obs_source_t source)
{
	source->rendering_filter = true;
	obs_source_video_render(source->filters.array[0]);
	source->rendering_filter = false;
}

static inline void obs_source_default_render(obs_source_t source,
		bool color_matrix)
{
	effect_t    effect     = obs->video.default_effect;
	const char  *tech_name = color_matrix ? "DrawMatrix" : "Draw";
	technique_t tech       = effect_gettechnique(effect, tech_name);
	size_t      passes, i;

	passes = technique_begin(tech);
	for (i = 0; i < passes; i++) {
		technique_beginpass(tech, i);
		if (source->context.data)
			source->info.video_render(source->context.data, effect);
		technique_endpass(tech);
	}
	technique_end(tech);
}

static inline void obs_source_main_render(obs_source_t source)
{
	uint32_t flags      = source->info.output_flags;
	bool color_matrix   = (flags & OBS_SOURCE_COLOR_MATRIX) != 0;
	bool custom_draw    = (flags & OBS_SOURCE_CUSTOM_DRAW) != 0;
	bool default_effect = !source->filter_parent &&
	                      source->filters.num == 0 &&
	                      !custom_draw;

	if (default_effect)
		obs_source_default_render(source, color_matrix);
	else if (source->context.data)
		source->info.video_render(source->context.data,
				custom_draw ? NULL : gs_geteffect());
}

void obs_source_video_render(obs_source_t source)
{
	if (!source_valid(source)) return;

	if (source->filters.num && !source->rendering_filter)
		obs_source_render_filters(source);

	else if (source->info.video_render)
		obs_source_main_render(source);

	else if (source->filter_target)
		obs_source_video_render(source->filter_target);

	else
		obs_source_render_async_video(source);
}

uint32_t obs_source_getwidth(obs_source_t source)
{
	if (!source_valid(source)) return 0;

	if (source->info.getwidth)
		return source->info.getwidth(source->context.data);
	return source->async_width;
}

uint32_t obs_source_getheight(obs_source_t source)
{
	if (!source_valid(source)) return 0;

	if (source->info.getheight)
		return source->info.getheight(source->context.data);
	return source->async_height;
}

obs_source_t obs_filter_getparent(obs_source_t filter)
{
	return filter ? filter->filter_parent : NULL;
}

obs_source_t obs_filter_gettarget(obs_source_t filter)
{
	return filter ? filter->filter_target : NULL;
}

void obs_source_filter_add(obs_source_t source, obs_source_t filter)
{
	if (!source || !filter)
		return;

	pthread_mutex_lock(&source->filter_mutex);

	if (da_find(source->filters, &filter, 0) != DARRAY_INVALID) {
		blog(LOG_WARNING, "Tried to add a filter that was already "
		                  "present on the source");
		return;
	}

	if (source->filters.num) {
		obs_source_t *back = da_end(source->filters);
		(*back)->filter_target = filter;
	}

	da_push_back(source->filters, &filter);

	pthread_mutex_unlock(&source->filter_mutex);

	filter->filter_parent = source;
	filter->filter_target = source;
}

void obs_source_filter_remove(obs_source_t source, obs_source_t filter)
{
	size_t idx;

	if (!source || !filter)
		return;

	pthread_mutex_lock(&source->filter_mutex);

	idx = da_find(source->filters, &filter, 0);
	if (idx == DARRAY_INVALID)
		return;

	if (idx > 0) {
		obs_source_t prev = source->filters.array[idx-1];
		prev->filter_target = filter->filter_target;
	}

	da_erase(source->filters, idx);

	pthread_mutex_unlock(&source->filter_mutex);

	filter->filter_parent = NULL;
	filter->filter_target = NULL;
}

void obs_source_filter_setorder(obs_source_t source, obs_source_t filter,
		enum order_movement movement)
{
	size_t idx, i;

	if (!source || !filter)
		return;

	idx = da_find(source->filters, &filter, 0);
	if (idx == DARRAY_INVALID)
		return;

	if (movement == ORDER_MOVE_UP) {
		if (idx == source->filters.num-1)
			return;
		da_move_item(source->filters, idx, idx+1);

	} else if (movement == ORDER_MOVE_DOWN) {
		if (idx == 0)
			return;
		da_move_item(source->filters, idx, idx-1);

	} else if (movement == ORDER_MOVE_TOP) {
		if (idx == source->filters.num-1)
			return;
		da_move_item(source->filters, idx, source->filters.num-1);

	} else if (movement == ORDER_MOVE_BOTTOM) {
		if (idx == 0)
			return;
		da_move_item(source->filters, idx, 0);
	}


	for (i = 0; i < source->filters.num; i++) {
		obs_source_t next_filter = (i == source->filters.num-1) ?
			source : source->filters.array[idx+1];
		source->filters.array[i]->filter_target = next_filter;
	}
}

obs_data_t obs_source_getsettings(obs_source_t source)
{
	if (!source) return NULL;

	obs_data_addref(source->context.settings);
	return source->context.settings;
}

static inline struct source_frame *filter_async_video(obs_source_t source,
		struct source_frame *in)
{
	size_t i;
	for (i = source->filters.num; i > 0; i--) {
		struct obs_source *filter = source->filters.array[i-1];

		if (filter->context.data && filter->info.filter_video) {
			in = filter->info.filter_video(filter->context.data,
					in);
			if (!in)
				return NULL;
		}
	}

	return in;
}

static inline void copy_frame_data_line(struct source_frame *dst,
		const struct source_frame *src, uint32_t plane, uint32_t y)
{
	uint32_t pos_src = y * src->linesize[plane];
	uint32_t pos_dst = y * dst->linesize[plane];
	uint32_t bytes = dst->linesize[plane] < src->linesize[plane] ?
		dst->linesize[plane] : src->linesize[plane];

	memcpy(dst->data[plane] + pos_dst, src->data[plane] + pos_src, bytes);
}

static inline void copy_frame_data_plane(struct source_frame *dst,
		const struct source_frame *src, uint32_t plane, uint32_t lines)
{
	if (dst->linesize[plane] != src->linesize[plane])
		for (uint32_t y = 0; y < lines; y++)
			copy_frame_data_line(dst, src, plane, y);
	else
		memcpy(dst->data[plane], src->data[plane],
				dst->linesize[plane] * lines);
}

static void copy_frame_data(struct source_frame *dst,
		const struct source_frame *src)
{
	dst->flip         = src->flip;
	dst->full_range   = src->full_range;
	dst->timestamp    = src->timestamp;
	memcpy(dst->color_matrix, src->color_matrix, sizeof(float) * 16);
	if (!dst->full_range) {
		size_t const size = sizeof(float) * 3;
		memcpy(dst->color_range_min, src->color_range_min, size);
		memcpy(dst->color_range_max, src->color_range_max, size);
	}

	switch (dst->format) {
	case VIDEO_FORMAT_I420:
		copy_frame_data_plane(dst, src, 0, dst->height);
		copy_frame_data_plane(dst, src, 1, dst->height/2);
		copy_frame_data_plane(dst, src, 2, dst->height/2);
		break;

	case VIDEO_FORMAT_NV12:
		copy_frame_data_plane(dst, src, 0, dst->height);
		copy_frame_data_plane(dst, src, 1, dst->height/2);
		break;

	case VIDEO_FORMAT_YVYU:
	case VIDEO_FORMAT_YUY2:
	case VIDEO_FORMAT_UYVY:
	case VIDEO_FORMAT_NONE:
	case VIDEO_FORMAT_RGBA:
	case VIDEO_FORMAT_BGRA:
	case VIDEO_FORMAT_BGRX:
		copy_frame_data_plane(dst, src, 0, dst->height);
	}
}

static inline struct source_frame *cache_video(const struct source_frame *frame)
{

	struct source_frame *new_frame = source_frame_create(frame->format,
			frame->width, frame->height);

	copy_frame_data(new_frame, frame);
	return new_frame;
}

static bool ready_async_frame(obs_source_t source, uint64_t sys_time);

static inline void cycle_frames(struct obs_source *source)
{
	if (source->video_frames.num && !source->activate_refs)
		ready_async_frame(source, os_gettime_ns());
}

void obs_source_output_video(obs_source_t source,
		const struct source_frame *frame)
{
	if (!source || !frame)
		return;

	struct source_frame *output = cache_video(frame);

	pthread_mutex_lock(&source->filter_mutex);
	output = filter_async_video(source, output);
	pthread_mutex_unlock(&source->filter_mutex);

	if (output) {
		pthread_mutex_lock(&source->video_mutex);
		cycle_frames(source);
		da_push_back(source->video_frames, &output);
		pthread_mutex_unlock(&source->video_mutex);
	}
}

static inline struct filtered_audio *filter_async_audio(obs_source_t source,
		struct filtered_audio *in)
{
	size_t i;
	for (i = source->filters.num; i > 0; i--) {
		struct obs_source *filter = source->filters.array[i-1];

		if (filter->context.data && filter->info.filter_audio) {
			in = filter->info.filter_audio(filter->context.data,
					in);
			if (!in)
				return NULL;
		}
	}

	return in;
}

static inline void reset_resampler(obs_source_t source,
		const struct source_audio *audio)
{
	const struct audio_output_info *obs_info;
	struct resample_info output_info;

	obs_info = audio_output_getinfo(obs->audio.audio);

	output_info.format           = obs_info->format;
	output_info.samples_per_sec  = obs_info->samples_per_sec;
	output_info.speakers         = obs_info->speakers;

	source->sample_info.format          = audio->format;
	source->sample_info.samples_per_sec = audio->samples_per_sec;
	source->sample_info.speakers        = audio->speakers;

	if (source->sample_info.samples_per_sec == obs_info->samples_per_sec &&
	    source->sample_info.format          == obs_info->format          &&
	    source->sample_info.speakers        == obs_info->speakers) {
		source->audio_failed = false;
		return;
	}

	audio_resampler_destroy(source->resampler);
	source->resampler = audio_resampler_create(&output_info,
			&source->sample_info);

	source->audio_failed = source->resampler == NULL;
	if (source->resampler == NULL)
		blog(LOG_ERROR, "creation of resampler failed");
}

static inline void copy_audio_data(obs_source_t source,
		const uint8_t *const data[], uint32_t frames, uint64_t ts)
{
	size_t planes    = audio_output_planes(obs->audio.audio);
	size_t blocksize = audio_output_blocksize(obs->audio.audio);
	size_t size      = (size_t)frames * blocksize;
	bool   resize    = source->audio_storage_size < size;

	source->audio_data.frames    = frames;
	source->audio_data.timestamp = ts;

	for (size_t i = 0; i < planes; i++) {

		if (resize) {
			bfree(source->audio_data.data[i]);
			source->audio_data.data[i] = bmalloc(size);
		}

		memcpy(source->audio_data.data[i], data[i], size);
	}

	if (resize)
		source->audio_storage_size = size;
}


static void process_audio(obs_source_t source, const struct source_audio *audio)
{
	if (source->sample_info.samples_per_sec != audio->samples_per_sec ||
	    source->sample_info.format          != audio->format          ||
	    source->sample_info.speakers        != audio->speakers)
		reset_resampler(source, audio);

	if (source->audio_failed)
		return;

	if (source->resampler) {
		uint8_t  *output[MAX_AV_PLANES];
		uint32_t frames;
		uint64_t offset;

		memset(output, 0, sizeof(output));

		audio_resampler_resample(source->resampler,
				output, &frames, &offset,
				audio->data, audio->frames);

		copy_audio_data(source, (const uint8_t *const *)output, frames,
				audio->timestamp - offset);
	} else {
		copy_audio_data(source, audio->data, audio->frames,
				audio->timestamp);
	}
}

void obs_source_output_audio(obs_source_t source,
		const struct source_audio *audio)
{
	uint32_t flags;
	struct filtered_audio *output;

	if (!source || !audio)
		return;

	flags = source->info.output_flags;
	process_audio(source, audio);

	pthread_mutex_lock(&source->filter_mutex);
	output = filter_async_audio(source, &source->audio_data);

	if (output) {
		bool async = (flags & OBS_SOURCE_ASYNC) != 0;

		pthread_mutex_lock(&source->audio_mutex);


		if (source->timing_set || !async) {
			struct audio_data data;

			for (int i = 0; i < MAX_AV_PLANES; i++)
				data.data[i] = output->data[i];

			data.frames    = output->frames;
			data.timestamp = output->timestamp;
			source_output_audio_line(source, &data);
		}

		pthread_mutex_unlock(&source->audio_mutex);
	}

	pthread_mutex_unlock(&source->filter_mutex);
}

static inline bool frame_out_of_bounds(obs_source_t source, uint64_t ts)
{
	return ((ts - source->last_frame_ts) > MAX_TIMESTAMP_JUMP);
}

static bool ready_async_frame(obs_source_t source, uint64_t sys_time)
{
	struct source_frame *next_frame = source->video_frames.array[0];
	struct source_frame *frame      = NULL;
	uint64_t sys_offset = sys_time - source->last_sys_timestamp;
	uint64_t frame_time = next_frame->timestamp;
	uint64_t frame_offset = 0;


	if (frame_out_of_bounds(source, frame_time)) {
		source->last_frame_ts = next_frame->timestamp;
		os_atomic_inc_long(&source->av_sync_ref);
	} else {
		frame_offset = frame_time - source->last_frame_ts;
		source->last_frame_ts += frame_offset;
	}

	while (frame_offset <= sys_offset) {
		source_frame_destroy(frame);

		if (source->video_frames.num == 1)
			return true;

		frame = next_frame;
		da_erase(source->video_frames, 0);
		next_frame = source->video_frames.array[0];


		if ((next_frame->timestamp - frame_time) > MAX_TIMESTAMP_JUMP) {
			source->last_frame_ts =
				next_frame->timestamp - frame_offset;
			os_atomic_inc_long(&source->av_sync_ref);
		}

		frame_time   = next_frame->timestamp;
		frame_offset = frame_time - source->last_frame_ts;
	}

	source_frame_destroy(frame);

	return frame != NULL;
}

static inline struct source_frame *get_closest_frame(obs_source_t source,
		uint64_t sys_time)
{
	if (ready_async_frame(source, sys_time)) {
		struct source_frame *frame = source->video_frames.array[0];
		da_erase(source->video_frames, 0);
		return frame;
	}

	return NULL;
}


struct source_frame *obs_source_get_frame(obs_source_t source)
{
	struct source_frame *frame = NULL;
	uint64_t sys_time;

	if (!source)
		return NULL;

	pthread_mutex_lock(&source->video_mutex);

	if (!source->video_frames.num)
		goto unlock;

	sys_time = os_gettime_ns();

	if (!source->last_frame_ts) {
		frame = source->video_frames.array[0];
		da_erase(source->video_frames, 0);

		source->last_frame_ts = frame->timestamp;
	} else {
		frame = get_closest_frame(source, sys_time);
	}


	if (frame) {
		source->timing_adjust = sys_time - frame->timestamp;
		source->timing_set = true;
	}

	source->last_sys_timestamp = sys_time;

unlock:
	pthread_mutex_unlock(&source->video_mutex);

	if (frame)
		obs_source_addref(source);

	return frame;
}

void obs_source_release_frame(obs_source_t source, struct source_frame *frame)
{
	if (source && frame) {
		source_frame_destroy(frame);
		obs_source_release(source);
	}
}

const char *obs_source_getname(obs_source_t source)
{
	return source ? source->context.name : NULL;
}

void obs_source_setname(obs_source_t source, const char *name)
{
	if (!source) return;

	if (!name || !*name || strcmp(name, source->context.name) != 0) {
		struct calldata data;
		char *prev_name = bstrdup(source->context.name);
		obs_context_data_setname(&source->context, name);

		calldata_init(&data);
		calldata_setptr(&data, "source", source);
		calldata_setstring(&data, "new_name", source->context.name);
		calldata_setstring(&data, "prev_name", prev_name);
		signal_handler_signal(obs->signals, "source_rename", &data);
		signal_handler_signal(source->context.signals, "rename", &data);
		calldata_free(&data);
		bfree(prev_name);
	}
}

void obs_source_gettype(obs_source_t source, enum obs_source_type *type,
		const char **id)
{
	if (!source) return;

	if (type) *type = source->info.type;
	if (id)   *id   = source->info.id;
}

static inline void render_filter_bypass(obs_source_t target, effect_t effect,
		bool use_matrix)
{
	const char  *tech_name = use_matrix ? "DrawMatrix" : "Draw";
	technique_t tech       = effect_gettechnique(effect, tech_name);
	size_t      passes, i;

	passes = technique_begin(tech);
	for (i = 0; i < passes; i++) {
		technique_beginpass(tech, i);
		obs_source_video_render(target);
		technique_endpass(tech);
	}
	technique_end(tech);
}

static inline void render_filter_tex(texture_t tex, effect_t effect,
		uint32_t width, uint32_t height, bool use_matrix)
{
	const char  *tech_name = use_matrix ? "DrawMatrix" : "Draw";
	technique_t tech       = effect_gettechnique(effect, tech_name);
	eparam_t    image      = effect_getparambyname(effect, "image");
	size_t      passes, i;

	effect_settexture(image, tex);

	passes = technique_begin(tech);
	for (i = 0; i < passes; i++) {
		technique_beginpass(tech, i);
		gs_draw_sprite(tex, width, height, 0);
		technique_endpass(tech);
	}
	technique_end(tech);
}

void obs_source_process_filter(obs_source_t filter, effect_t effect,
		uint32_t width, uint32_t height, enum gs_color_format format,
		enum allow_direct_render allow_direct)
{
	obs_source_t target, parent;
	uint32_t     target_flags, parent_flags;
	int          cx, cy;
	bool         use_matrix, expects_def, can_directly;

	if (!filter) return;

	target       = obs_filter_gettarget(filter);
	parent       = obs_filter_getparent(filter);
	target_flags = target->info.output_flags;
	parent_flags = parent->info.output_flags;
	cx           = obs_source_getwidth(target);
	cy           = obs_source_getheight(target);
	use_matrix   = !!(target_flags & OBS_SOURCE_COLOR_MATRIX);
	expects_def  = !(parent_flags & OBS_SOURCE_CUSTOM_DRAW);
	can_directly = allow_direct == ALLOW_DIRECT_RENDERING;


	if (can_directly && expects_def && target == parent) {
		render_filter_bypass(target, effect, use_matrix);
		return;
	}

	if (!filter->filter_texrender)
		filter->filter_texrender = texrender_create(format,
				GS_ZS_NONE);

	if (texrender_begin(filter->filter_texrender, cx, cy)) {
		gs_ortho(0.0f, (float)cx, 0.0f, (float)cy, -100.0f, 100.0f);
		if (expects_def && parent == target)
			obs_source_default_render(parent, use_matrix);
		else
			obs_source_video_render(target);
		texrender_end(filter->filter_texrender);
	}



	render_filter_tex(texrender_gettexture(filter->filter_texrender),
			effect, width, height, use_matrix);
}

signal_handler_t obs_source_signalhandler(obs_source_t source)
{
	return source ? source->context.signals : NULL;
}

proc_handler_t obs_source_prochandler(obs_source_t source)
{
	return source ? source->context.procs : NULL;
}

void obs_source_setvolume(obs_source_t source, float volume)
{
	if (source) {
		struct calldata data = {0};
		calldata_setptr(&data, "source", source);
		calldata_setfloat(&data, "volume", volume);

		signal_handler_signal(source->context.signals, "volume", &data);
		signal_handler_signal(obs->signals, "source_volume", &data);

		volume = (float)calldata_float(&data, "volume");
		calldata_free(&data);

		source->user_volume = volume;
	}
}

static void set_tree_preset_vol(obs_source_t parent, obs_source_t child,
		void *param)
{
	float *vol = param;
	child->present_volume = *vol;

	UNUSED_PARAMETER(parent);
}

void obs_source_set_present_volume(obs_source_t source, float volume)
{
	if (source) {
		source->present_volume = volume;


		if (source->info.type != OBS_SOURCE_TYPE_TRANSITION)
			obs_source_enum_tree(source, set_tree_preset_vol,
					&volume);
	}
}

float obs_source_getvolume(obs_source_t source)
{
	return source ? source->user_volume : 0.0f;
}

float obs_source_get_present_volume(obs_source_t source)
{
	return source ? source->present_volume : 0.0f;
}

void obs_source_set_sync_offset(obs_source_t source, int64_t offset)
{
	if (source)
		source->sync_offset = offset;
}

int64_t obs_source_get_sync_offset(obs_source_t source)
{
	return source ? source->sync_offset : 0;
}

struct source_enum_data {
	obs_source_enum_proc_t enum_callback;
	void *param;
};

static void enum_source_tree_callback(obs_source_t parent, obs_source_t child,
		void *param)
{
	struct source_enum_data *data = param;

	if (child->info.enum_sources && !child->enum_refs) {
		os_atomic_inc_long(&child->enum_refs);

		if (child->context.data)
			child->info.enum_sources(child->context.data,
					enum_source_tree_callback, data);

		os_atomic_dec_long(&child->enum_refs);
	}

	data->enum_callback(parent, child, data->param);
}

void obs_source_enum_sources(obs_source_t source,
		obs_source_enum_proc_t enum_callback,
		void *param)
{
	if (!source_valid(source)      ||
	    !source->info.enum_sources ||
	    source->enum_refs)
		return;

	obs_source_addref(source);

	os_atomic_inc_long(&source->enum_refs);
	source->info.enum_sources(source->context.data, enum_callback, param);
	os_atomic_dec_long(&source->enum_refs);

	obs_source_release(source);
}

void obs_source_enum_tree(obs_source_t source,
		obs_source_enum_proc_t enum_callback,
		void *param)
{
	struct source_enum_data data = {enum_callback, param};

	if (!source_valid(source)      ||
	    !source->info.enum_sources ||
	    source->enum_refs)
		return;

	obs_source_addref(source);

	os_atomic_inc_long(&source->enum_refs);
	source->info.enum_sources(source->context.data,
			enum_source_tree_callback,
			&data);
	os_atomic_dec_long(&source->enum_refs);

	obs_source_release(source);
}

void obs_source_add_child(obs_source_t parent, obs_source_t child)
{
	if (!parent || !child) return;

	for (int i = 0; i < parent->show_refs; i++) {
		enum view_type type;
		type = (i < parent->activate_refs) ? MAIN_VIEW : AUX_VIEW;
		obs_source_activate(child, type);
	}
}

void obs_source_remove_child(obs_source_t parent, obs_source_t child)
{
	if (!parent || !child) return;

	for (int i = 0; i < parent->show_refs; i++) {
		enum view_type type;
		type = (i < parent->activate_refs) ? MAIN_VIEW : AUX_VIEW;
		obs_source_deactivate(child, type);
	}
}

static void reset_transition_vol(obs_source_t parent, obs_source_t child,
		void *param)
{
	child->transition_volume = 0.0f;

	UNUSED_PARAMETER(parent);
	UNUSED_PARAMETER(param);
}

static void add_transition_vol(obs_source_t parent, obs_source_t child,
		void *param)
{
	float *vol = param;
	child->transition_volume += *vol;

	UNUSED_PARAMETER(parent);
}

static void apply_transition_vol(obs_source_t parent, obs_source_t child,
		void *param)
{
	child->present_volume = child->transition_volume;

	UNUSED_PARAMETER(parent);
	UNUSED_PARAMETER(param);
}

void obs_transition_begin_frame(obs_source_t transition)
{
	if (!transition) return;
	obs_source_enum_tree(transition, reset_transition_vol, NULL);
}

void obs_source_set_transition_vol(obs_source_t source, float vol)
{
	if (!source) return;

	add_transition_vol(NULL, source, &vol);
	obs_source_enum_tree(source, add_transition_vol, &vol);
}

void obs_transition_end_frame(obs_source_t transition)
{
	if (!transition) return;
	obs_source_enum_tree(transition, apply_transition_vol, NULL);
}

void obs_source_save(obs_source_t source)
{
	if (!source_valid(source) || !source->info.save) return;
	source->info.save(source->context.data, source->context.settings);
}

void obs_source_load(obs_source_t source)
{
	if (!source_valid(source) || !source->info.load) return;
	source->info.load(source->context.data, source->context.settings);
}
<code block>
#include <inttypes.h>

#include "media-io/format-conversion.h"
#include "media-io/video-frame.h"
#include "media-io/audio-io.h"
#include "util/threading.h"
#include "util/platform.h"
#include "callback/calldata.h"
#include "graphics/matrix3.h"
#include "graphics/vec3.h"

#include "obs.h"
#include "obs-internal.h"

static inline bool source_valid(struct obs_source *source)
{
	return source && source->context.data;
}

const struct obs_source_info *find_source(struct darray *list, const char *id)
{
	size_t i;
	struct obs_source_info *array = list->array;

	for (i = 0; i < list->num; i++) {
		struct obs_source_info *info = array+i;
		if (strcmp(info->id, id) == 0)
			return info;
	}

	return NULL;
}

static const struct obs_source_info *get_source_info(enum obs_source_type type,
		const char *id)
{
	struct darray *list = NULL;

	switch (type) {
	case OBS_SOURCE_TYPE_INPUT:
		list = &obs->input_types.da;
		break;

	case OBS_SOURCE_TYPE_FILTER:
		list = &obs->filter_types.da;
		break;

	case OBS_SOURCE_TYPE_TRANSITION:
		list = &obs->transition_types.da;
		break;
	}

	return find_source(list, id);
}

static const char *source_signals[] = {
	"void destroy(ptr source)",
	"void add(ptr source)",
	"void remove(ptr source)",
	"void activate(ptr source)",
	"void deactivate(ptr source)",
	"void show(ptr source)",
	"void hide(ptr source)",
	"void rename(ptr source, string new_name, string prev_name)",
	"void volume(ptr source, in out float volume)",
	"void volume_level(ptr source, float level, float magnitude, "
		"float peak)",
	NULL
};

bool obs_source_init_context(struct obs_source *source,
		obs_data_t settings, const char *name)
{
	if (!obs_context_data_init(&source->context, settings, name))
		return false;

	return signal_handler_add_array(source->context.signals,
			source_signals);
}

const char *obs_source_getdisplayname(enum obs_source_type type, const char *id)
{
	const struct obs_source_info *info = get_source_info(type, id);
	return (info != NULL) ? info->getname() : NULL;
}


bool obs_source_init(struct obs_source *source,
		const struct obs_source_info *info)
{
	source->refs = 1;
	source->user_volume = 1.0f;
	source->present_volume = 0.0f;
	source->sync_offset = 0;
	pthread_mutex_init_value(&source->filter_mutex);
	pthread_mutex_init_value(&source->video_mutex);
	pthread_mutex_init_value(&source->audio_mutex);

	if (pthread_mutex_init(&source->filter_mutex, NULL) != 0)
		return false;
	if (pthread_mutex_init(&source->audio_mutex, NULL) != 0)
		return false;
	if (pthread_mutex_init(&source->video_mutex, NULL) != 0)
		return false;

	if (info && info->output_flags & OBS_SOURCE_AUDIO) {
		source->audio_line = audio_output_createline(obs->audio.audio,
				source->context.name);
		if (!source->audio_line) {
			blog(LOG_ERROR, "Failed to create audio line for "
			                "source '%s'", source->context.name);
			return false;
		}
	}

	obs_context_data_insert(&source->context,
			&obs->data.sources_mutex,
			&obs->data.first_source);
	return true;
}

static inline void obs_source_dosignal(struct obs_source *source,
		const char *signal_obs, const char *signal_source)
{
	struct calldata data;

	calldata_init(&data);
	calldata_setptr(&data, "source", source);
	if (signal_obs)
		signal_handler_signal(obs->signals, signal_obs, &data);
	if (signal_source)
		signal_handler_signal(source->context.signals, signal_source,
				&data);
	calldata_free(&data);
}

obs_source_t obs_source_create(enum obs_source_type type, const char *id,
		const char *name, obs_data_t settings)
{
	struct obs_source *source = bzalloc(sizeof(struct obs_source));

	const struct obs_source_info *info = get_source_info(type, id);
	if (!info) {
		blog(LOG_ERROR, "Source ID '%s' not found", id);

		source->info.id      = bstrdup(id);
		source->info.type    = type;
		source->owns_info_id = true;
	} else {
		source->info = *info;
	}

	if (!obs_source_init_context(source, settings, name))
		goto fail;

	if (info && info->defaults)
		info->defaults(source->context.settings);


	if (info)
		source->context.data = info->create(source->context.settings,
				source);
	if (!source->context.data)
		blog(LOG_ERROR, "Failed to create source '%s'!", name);

	if (!obs_source_init(source, info))
		goto fail;

	blog(LOG_INFO, "source '%s' (%s) created", name, id);
	obs_source_dosignal(source, "source_create", NULL);
	return source;

fail:
	blog(LOG_ERROR, "obs_source_create failed");
	obs_source_destroy(source);
	return NULL;
}

void source_frame_init(struct source_frame *frame, enum video_format format,
		uint32_t width, uint32_t height)
{
	struct video_frame vid_frame;

	if (!frame)
		return;

	video_frame_init(&vid_frame, format, width, height);
	frame->format = format;
	frame->width  = width;
	frame->height = height;

	for (size_t i = 0; i < MAX_AV_PLANES; i++) {
		frame->data[i]     = vid_frame.data[i];
		frame->linesize[i] = vid_frame.linesize[i];
	}
}

void obs_source_destroy(struct obs_source *source)
{
	size_t i;

	if (!source)
		return;

	obs_context_data_remove(&source->context);

	blog(LOG_INFO, "source '%s' destroyed", source->context.name);

	obs_source_dosignal(source, "source_destroy", "destroy");

	if (source->context.data) {
		source->info.destroy(source->context.data);
		source->context.data = NULL;
	}

	if (source->filter_parent)
		obs_source_filter_remove(source->filter_parent, source);

	for (i = 0; i < source->filters.num; i++)
		obs_source_release(source->filters.array[i]);

	for (i = 0; i < source->video_frames.num; i++)
		source_frame_destroy(source->video_frames.array[i]);

	gs_entercontext(obs->video.graphics);
	texrender_destroy(source->async_convert_texrender);
	texture_destroy(source->async_texture);
	gs_leavecontext();

	for (i = 0; i < MAX_AV_PLANES; i++)
		bfree(source->audio_data.data[i]);

	audio_line_destroy(source->audio_line);
	audio_resampler_destroy(source->resampler);

	texrender_destroy(source->filter_texrender);
	da_free(source->video_frames);
	da_free(source->filters);
	pthread_mutex_destroy(&source->filter_mutex);
	pthread_mutex_destroy(&source->audio_mutex);
	pthread_mutex_destroy(&source->video_mutex);
	obs_context_data_free(&source->context);
	
	if (source->owns_info_id)
		bfree((void*)source->info.id);

	bfree(source);
}

void obs_source_addref(obs_source_t source)
{
	if (source)
		os_atomic_inc_long(&source->refs);
}

void obs_source_release(obs_source_t source)
{
	if (!source)
		return;

	if (os_atomic_dec_long(&source->refs) == 0)
		obs_source_destroy(source);
}

void obs_source_remove(obs_source_t source)
{
	struct obs_core_data *data = &obs->data;
	size_t id;
	bool   exists;

	pthread_mutex_lock(&data->sources_mutex);

	if (!source || source->removed) {
		pthread_mutex_unlock(&data->sources_mutex);
		return;
	}

	source->removed = true;

	obs_source_addref(source);

	id = da_find(data->user_sources, &source, 0);
	exists = (id != DARRAY_INVALID);
	if (exists) {
		da_erase(data->user_sources, id);
		obs_source_release(source);
	}

	pthread_mutex_unlock(&data->sources_mutex);

	if (exists)
		obs_source_dosignal(source, "source_remove", "remove");

	obs_source_release(source);
}

bool obs_source_removed(obs_source_t source)
{
	return source ? source->removed : true;
}

static inline obs_data_t get_defaults(const struct obs_source_info *info)
{
	obs_data_t settings = obs_data_create();
	if (info->defaults)
		info->defaults(settings);
	return settings;
}

obs_data_t obs_source_settings(enum obs_source_type type, const char *id)
{
	const struct obs_source_info *info = get_source_info(type, id);
	return (info) ? get_defaults(info) : NULL;
}

obs_properties_t obs_get_source_properties(enum obs_source_type type,
		const char *id)
{
	const struct obs_source_info *info = get_source_info(type, id);
	if (info && info->properties) {
		obs_data_t       defaults = get_defaults(info);
		obs_properties_t properties;

		properties = info->properties();
		obs_properties_apply_settings(properties, defaults);
		obs_data_release(defaults);
		return properties;
	}
	return NULL;
}

obs_properties_t obs_source_properties(obs_source_t source)
{
	if (source_valid(source) && source->info.properties) {
		obs_properties_t props;
		props = source->info.properties();
		obs_properties_apply_settings(props, source->context.settings);
		return props;
	}

	return NULL;
}

uint32_t obs_source_get_output_flags(obs_source_t source)
{
	return source ? source->info.output_flags : 0;
}

static void obs_source_deferred_update(obs_source_t source)
{
	if (source->context.data && source->info.update)
		source->info.update(source->context.data,
				source->context.settings);

	source->defer_update = false;
}

void obs_source_update(obs_source_t source, obs_data_t settings)
{
	if (!source) return;

	if (settings)
		obs_data_apply(source->context.settings, settings);

	if (source->info.output_flags & OBS_SOURCE_VIDEO) {
		source->defer_update = true;
	} else if (source->context.data && source->info.update) {
		source->info.update(source->context.data,
				source->context.settings);
	}
}

static void activate_source(obs_source_t source)
{
	if (source->context.data && source->info.activate)
		source->info.activate(source->context.data);
	obs_source_dosignal(source, "source_activate", "activate");
}

static void deactivate_source(obs_source_t source)
{
	if (source->context.data && source->info.deactivate)
		source->info.deactivate(source->context.data);
	obs_source_dosignal(source, "source_deactivate", "deactivate");
}

static void show_source(obs_source_t source)
{
	if (source->context.data && source->info.show)
		source->info.show(source->context.data);
	obs_source_dosignal(source, "source_show", "show");
}

static void hide_source(obs_source_t source)
{
	if (source->context.data && source->info.hide)
		source->info.hide(source->context.data);
	obs_source_dosignal(source, "source_hide", "hide");
}

static void activate_tree(obs_source_t parent, obs_source_t child, void *param)
{
	if (os_atomic_inc_long(&child->activate_refs) == 1)
		activate_source(child);

	UNUSED_PARAMETER(parent);
	UNUSED_PARAMETER(param);
}

static void deactivate_tree(obs_source_t parent, obs_source_t child,
		void *param)
{
	if (os_atomic_dec_long(&child->activate_refs) == 0)
		deactivate_source(child);

	UNUSED_PARAMETER(parent);
	UNUSED_PARAMETER(param);
}

static void show_tree(obs_source_t parent, obs_source_t child, void *param)
{
	if (os_atomic_inc_long(&child->show_refs) == 1)
		show_source(child);

	UNUSED_PARAMETER(parent);
	UNUSED_PARAMETER(param);
}

static void hide_tree(obs_source_t parent, obs_source_t child, void *param)
{
	if (os_atomic_dec_long(&child->show_refs) == 0)
		hide_source(child);

	UNUSED_PARAMETER(parent);
	UNUSED_PARAMETER(param);
}

void obs_source_activate(obs_source_t source, enum view_type type)
{
	if (!source) return;

	if (os_atomic_inc_long(&source->show_refs) == 1) {
		show_source(source);
		obs_source_enum_tree(source, show_tree, NULL);
	}

	if (type == MAIN_VIEW) {
		if (os_atomic_inc_long(&source->activate_refs) == 1) {
			activate_source(source);
			obs_source_enum_tree(source, activate_tree, NULL);
			obs_source_set_present_volume(source, 1.0f);
		}
	}
}

void obs_source_deactivate(obs_source_t source, enum view_type type)
{
	if (!source) return;

	if (os_atomic_dec_long(&source->show_refs) == 0) {
		hide_source(source);
		obs_source_enum_tree(source, hide_tree, NULL);
	}

	if (type == MAIN_VIEW) {
		if (os_atomic_dec_long(&source->activate_refs) == 0) {
			deactivate_source(source);
			obs_source_enum_tree(source, deactivate_tree, NULL);
			obs_source_set_present_volume(source, 0.0f);
		}
	}
}

void obs_source_video_tick(obs_source_t source, float seconds)
{
	if (!source) return;

	if (source->defer_update)
		obs_source_deferred_update(source);


	if (source->filter_texrender)
		texrender_reset(source->filter_texrender);

	if (source->context.data && source->info.video_tick)
		source->info.video_tick(source->context.data, seconds);
}


static inline uint64_t conv_frames_to_time(size_t frames)
{
	const struct audio_output_info *info;
	info = audio_output_getinfo(obs->audio.audio);

	return (uint64_t)frames * 1000000000ULL /
		(uint64_t)info->samples_per_sec;
}


#define MAX_TS_VAR          5000000000ULL

#define MAX_TIMESTAMP_JUMP  2000000000ULL

#define TS_SMOOTHING_THRESHOLD 70000000ULL

static inline void reset_audio_timing(obs_source_t source, uint64_t timetamp)
{
	source->timing_set    = true;
	source->timing_adjust = os_gettime_ns() - timetamp;
}

static inline void handle_ts_jump(obs_source_t source, uint64_t expected,
		uint64_t ts, uint64_t diff)
{
	blog(LOG_DEBUG, "Timestamp for source '%s' jumped by '%"PRIu64"', "
	                "expected value %"PRIu64", input value %"PRIu64,
	                source->context.name, diff, expected, ts);


	if (source->info.output_flags & OBS_SOURCE_ASYNC)
		os_atomic_dec_long(&source->av_sync_ref);
	else
		reset_audio_timing(source, ts);
}

#define VOL_MIN -96.0f
#define VOL_MAX  0.0f

static inline float to_db(float val)
{
	float db = 20.0f * log10f(val);
	return isfinite(db) ? db : VOL_MIN;
}

static void calc_volume_levels(struct obs_source *source, float *array,
		size_t frames, float volume)
{
	float sum_val = 0.0f;
	float max_val = 0.0f;
	float rms_val = 0.0f;

	const uint32_t sample_rate    = audio_output_samplerate(obs_audio());
	const size_t   channels       = audio_output_channels(obs_audio());
	const size_t   count          = frames * channels;
	const size_t   vol_peak_delay = sample_rate * 3;
	const float    alpha          = 0.15f;

	for (size_t i = 0; i < count; i++) {
		float val      = array[i];
		float val_pow2 = val * val;

		sum_val += val_pow2;
		max_val  = fmaxf(max_val, val_pow2);
	}



	UNUSED_PARAMETER(volume);

	rms_val = to_db(sqrtf(sum_val / (float)count));
	max_val = to_db(sqrtf(max_val));

	if (max_val > source->vol_max)
		source->vol_max = max_val;
	else
		source->vol_max = alpha * source->vol_max +
			(1.0f - alpha) * max_val;

	if (source->vol_max > source->vol_peak ||
	    source->vol_update_count > vol_peak_delay) {
		source->vol_peak         = source->vol_max;
		source->vol_update_count = 0;
	} else {
		source->vol_update_count += count;
	}

	source->vol_mag = alpha * rms_val + source->vol_mag * (1.0f - alpha);
}


static void obs_source_update_volume_level(obs_source_t source,
		struct audio_data *in)
{
	if (source && in) {
		struct calldata data = {0};

		calc_volume_levels(source, (float*)in->data[0], in->frames,
				in->volume);

		calldata_setptr  (&data, "source",    source);
		calldata_setfloat(&data, "level",     source->vol_max);
		calldata_setfloat(&data, "magnitude", source->vol_mag);
		calldata_setfloat(&data, "peak",      source->vol_peak);

		signal_handler_signal(source->context.signals, "volume_level",
				&data);
		signal_handler_signal(obs->signals, "source_volume_level",
				&data);

		calldata_free(&data);
	}
}

static void source_output_audio_line(obs_source_t source,
		const struct audio_data *data)
{
	struct audio_data in = *data;
	uint64_t diff;

	if (!source->timing_set) {
		reset_audio_timing(source, in.timestamp);


		if ((source->timing_adjust + MAX_TS_VAR) < MAX_TS_VAR * 2)
			source->timing_adjust = 0;

	} else {
		bool ts_under = (in.timestamp < source->next_audio_ts_min);

		diff = ts_under ?
			(source->next_audio_ts_min - in.timestamp) :
			(in.timestamp - source->next_audio_ts_min);


		if (diff > MAX_TIMESTAMP_JUMP)
			handle_ts_jump(source, source->next_audio_ts_min,
					in.timestamp, diff);
		else if (ts_under || diff < TS_SMOOTHING_THRESHOLD)
			in.timestamp = source->next_audio_ts_min;
	}

	source->next_audio_ts_min = in.timestamp +
		conv_frames_to_time(in.frames);

	if (source->av_sync_ref != 0)
		return;

	in.timestamp += source->timing_adjust + source->sync_offset;
	in.volume = source->user_volume * source->present_volume *
		obs->audio.user_volume * obs->audio.present_volume;

	audio_line_output(source->audio_line, &in);
	obs_source_update_volume_level(source, &in);
}

enum convert_type {
	CONVERT_NONE,
	CONVERT_NV12,
	CONVERT_420,
	CONVERT_422_U,
	CONVERT_422_Y,
};

static inline enum convert_type get_convert_type(enum video_format format)
{
	switch (format) {
	case VIDEO_FORMAT_I420:
		return CONVERT_420;
	case VIDEO_FORMAT_NV12:
		return CONVERT_NV12;

	case VIDEO_FORMAT_YVYU:
	case VIDEO_FORMAT_YUY2:
		return CONVERT_422_Y;
	case VIDEO_FORMAT_UYVY:
		return CONVERT_422_U;

	case VIDEO_FORMAT_NONE:
	case VIDEO_FORMAT_RGBA:
	case VIDEO_FORMAT_BGRA:
	case VIDEO_FORMAT_BGRX:
		return CONVERT_NONE;
	}

	return CONVERT_NONE;
}

static inline bool set_packed422_sizes(struct obs_source *source,
		struct source_frame *frame)
{
	source->async_convert_height = frame->height;
	source->async_convert_width  = frame->width / 2;
	source->async_texture_format = GS_BGRA;
	return true;
}

static inline bool set_planar420_sizes(struct obs_source *source,
		struct source_frame *frame)
{
	uint32_t size = frame->width * frame->height;
	size += size/2;

	source->async_convert_width   = frame->width;
	source->async_convert_height  = (size / frame->width + 1) & 0xFFFFFFFE;
	source->async_texture_format  = GS_R8;
	source->async_plane_offset[0] = frame->width * frame->height;
	source->async_plane_offset[1] = source->async_plane_offset[0] +
		frame->width * frame->height / 4;
	return true;
}

static inline bool init_gpu_conversion(struct obs_source *source,
		struct source_frame *frame)
{
	switch (get_convert_type(frame->format)) {
		case CONVERT_422_Y:
		case CONVERT_422_U:
			return set_packed422_sizes(source, frame);

		case CONVERT_420:
			return set_planar420_sizes(source, frame);

		case CONVERT_NV12:
			assert(false && "NV12 not yet implemented");

			break;

		case CONVERT_NONE:
			assert(false && "No conversion requested");
			break;

	}
	return false;
}

static inline enum gs_color_format convert_video_format(
		enum video_format format)
{
	if (format == VIDEO_FORMAT_RGBA)
		return GS_RGBA;
	else if (format == VIDEO_FORMAT_BGRA)
		return GS_BGRA;

	return GS_BGRX;
}

static inline bool set_async_texture_size(struct obs_source *source,
		struct source_frame *frame)
{
	enum convert_type prev, cur;
	prev = get_convert_type(source->async_format);
	cur  = get_convert_type(frame->format);
	if (source->async_texture) {
		if (source->async_width  == frame->width &&
		    source->async_height == frame->height &&
		    prev == cur)
			return true;
	}

	texture_destroy(source->async_texture);
	texrender_destroy(source->async_convert_texrender);
	source->async_convert_texrender = NULL;

	if (cur != CONVERT_NONE && init_gpu_conversion(source, frame)) {
		source->async_gpu_conversion = true;

		source->async_convert_texrender =
			texrender_create(GS_BGRX, GS_ZS_NONE);

		source->async_texture = gs_create_texture(
				source->async_convert_width,
				source->async_convert_height,
				source->async_texture_format,
				1, NULL, GS_DYNAMIC);

	} else {
		enum gs_color_format format = convert_video_format(
				frame->format);
		source->async_gpu_conversion = false;

		source->async_texture = gs_create_texture(
				frame->width, frame->height,
				format, 1, NULL, GS_DYNAMIC);
	}

	if (!source->async_texture)
		return false;

	source->async_width  = frame->width;
	source->async_height = frame->height;
	return true;
}

static void upload_raw_frame(texture_t tex, const struct source_frame *frame)
{
	switch (get_convert_type(frame->format)) {
		case CONVERT_422_U:
		case CONVERT_422_Y:
			texture_setimage(tex, frame->data[0],
					frame->linesize[0], false);
			break;

		case CONVERT_420:
			texture_setimage(tex, frame->data[0],
					frame->width, false);
			break;

		case CONVERT_NV12:
			assert(false && "Conversion not yet implemented");
			break;

		case CONVERT_NONE:
			assert(false && "No conversion requested");
			break;
	}
}

static const char *select_conversion_technique(enum video_format format)
{
	switch (format) {
		case VIDEO_FORMAT_UYVY:
			return "UYVY_Reverse";

		case VIDEO_FORMAT_YUY2:
			return "YUY2_Reverse";

		case VIDEO_FORMAT_YVYU:
			return "YVYU_Reverse";

		case VIDEO_FORMAT_I420:
			return "I420_Reverse";

		case VIDEO_FORMAT_NV12:
			assert(false && "Conversion not yet implemented");
			break;

		case VIDEO_FORMAT_BGRA:
		case VIDEO_FORMAT_BGRX:
		case VIDEO_FORMAT_RGBA:
		case VIDEO_FORMAT_NONE:
			assert(false && "No conversion requested");
			break;
	}
	return NULL;
}

static inline void set_eparam(effect_t effect, const char *name, float val)
{
	eparam_t param = effect_getparambyname(effect, name);
	effect_setfloat(param, val);
}

static bool update_async_texrender(struct obs_source *source,
		const struct source_frame *frame)
{
	texture_t   tex       = source->async_texture;
	texrender_t texrender = source->async_convert_texrender;

	texrender_reset(texrender);

	upload_raw_frame(tex, frame);

	uint32_t cx = source->async_width;
	uint32_t cy = source->async_height;

	float convert_width  = (float)source->async_convert_width;
	float convert_height = (float)source->async_convert_height;

	effect_t conv = obs->video.conversion_effect;
	technique_t tech = effect_gettechnique(conv,
			select_conversion_technique(frame->format));

	if (!texrender_begin(texrender, cx, cy))
		return false;

	technique_begin(tech);
	technique_beginpass(tech, 0);

	effect_settexture(effect_getparambyname(conv, "image"), tex);
	set_eparam(conv, "width",  (float)cx);
	set_eparam(conv, "height", (float)cy);
	set_eparam(conv, "width_i",  1.0f / cx);
	set_eparam(conv, "height_i", 1.0f / cy);
	set_eparam(conv, "width_d2",  cx * 0.5f);
	set_eparam(conv, "height_d2", cy * 0.5f);
	set_eparam(conv, "width_d2_i",  1.0f / (cx * 0.5f));
	set_eparam(conv, "height_d2_i", 1.0f / (cy * 0.5f));
	set_eparam(conv, "input_width",  convert_width);
	set_eparam(conv, "input_height", convert_height);
	set_eparam(conv, "input_width_i",  1.0f / convert_width);
	set_eparam(conv, "input_height_i", 1.0f / convert_height);
	set_eparam(conv, "input_width_i_d2",  (1.0f / convert_width)  * 0.5f);
	set_eparam(conv, "input_height_i_d2", (1.0f / convert_height) * 0.5f);
	set_eparam(conv, "u_plane_offset",
			(float)source->async_plane_offset[0]);
	set_eparam(conv, "v_plane_offset",
			(float)source->async_plane_offset[1]);

	gs_ortho(0.f, (float)cx, 0.f, (float)cy, -100.f, 100.f);

	gs_draw_sprite(tex, 0, cx, cy);

	technique_endpass(tech);
	technique_end(tech);

	texrender_end(texrender);

	return true;
}

static bool update_async_texture(struct obs_source *source,
		const struct source_frame *frame)
{
	texture_t         tex       = source->async_texture;
	texrender_t       texrender = source->async_convert_texrender;
	enum convert_type type      = get_convert_type(frame->format);
	uint8_t           *ptr;
	uint32_t          linesize;

	source->async_format     = frame->format;
	source->async_flip       = frame->flip;
	source->async_full_range = frame->full_range;
	memcpy(source->async_color_matrix, frame->color_matrix,
			sizeof(frame->color_matrix));
	memcpy(source->async_color_range_min, frame->color_range_min,
			sizeof frame->color_range_min);
	memcpy(source->async_color_range_max, frame->color_range_max,
			sizeof frame->color_range_max);

	if (source->async_gpu_conversion && texrender)
		return update_async_texrender(source, frame);

	if (type == CONVERT_NONE) {
		texture_setimage(tex, frame->data[0], frame->linesize[0],
				false);
		return true;
	}

	if (!texture_map(tex, &ptr, &linesize))
		return false;

	if (type == CONVERT_420)
		decompress_420((const uint8_t* const*)frame->data,
				frame->linesize,
				0, frame->height, ptr, linesize);

	else if (type == CONVERT_NV12)
		decompress_nv12((const uint8_t* const*)frame->data,
				frame->linesize,
				0, frame->height, ptr, linesize);

	else if (type == CONVERT_422_Y)
		decompress_422(frame->data[0], frame->linesize[0],
				0, frame->height, ptr, linesize, true);

	else if (type == CONVERT_422_U)
		decompress_422(frame->data[0], frame->linesize[0],
				0, frame->height, ptr, linesize, false);

	texture_unmap(tex);
	return true;
}

static inline void obs_source_draw_texture(struct obs_source *source,
		effect_t effect, float *color_matrix,
		float const *color_range_min, float const *color_range_max)
{
	texture_t tex = source->async_texture;
	eparam_t  param;

	if (source->async_convert_texrender)
		tex = texrender_gettexture(source->async_convert_texrender);

	if (color_range_min) {
		size_t const size = sizeof(float) * 3;
		param = effect_getparambyname(effect, "color_range_min");
		effect_setval(param, color_range_min, size);
	}

	if (color_range_max) {
		size_t const size = sizeof(float) * 3;
		param = effect_getparambyname(effect, "color_range_max");
		effect_setval(param, color_range_max, size);
	}

	if (color_matrix) {
		param = effect_getparambyname(effect, "color_matrix");
		effect_setval(param, color_matrix, sizeof(float) * 16);
	}

	param = effect_getparambyname(effect, "image");
	effect_settexture(param, tex);

	gs_draw_sprite(tex, source->async_flip ? GS_FLIP_V : 0, 0, 0);
}

static void obs_source_draw_async_texture(struct obs_source *source)
{
	effect_t    effect        = gs_geteffect();
	bool        yuv           = format_is_yuv(source->async_format);
	bool        limited_range = yuv && !source->async_full_range;
	const char  *type         = yuv ? "DrawMatrix" : "Draw";
	bool        def_draw      = (!effect);
	technique_t tech          = NULL;

	if (def_draw) {
		effect = obs_get_default_effect();
		tech = effect_gettechnique(effect, type);
		technique_begin(tech);
		technique_beginpass(tech, 0);
	}

	obs_source_draw_texture(source, effect,
			yuv ? source->async_color_matrix : NULL,
			limited_range ? source->async_color_range_min : NULL,
			limited_range ? source->async_color_range_max : NULL);

	if (def_draw) {
		technique_endpass(tech);
		technique_end(tech);
	}
}

static void obs_source_render_async_video(obs_source_t source)
{
	struct source_frame *frame = obs_source_getframe(source);
	if (frame) {
		if (!set_async_texture_size(source, frame))
			return;
		if (!update_async_texture(source, frame))
			return;
	}

	if (source->async_texture)
		obs_source_draw_async_texture(source);

	obs_source_releaseframe(source, frame);
}

static inline void obs_source_render_filters(obs_source_t source)
{
	source->rendering_filter = true;
	obs_source_video_render(source->filters.array[0]);
	source->rendering_filter = false;
}

static inline void obs_source_default_render(obs_source_t source,
		bool color_matrix)
{
	effect_t    effect     = obs->video.default_effect;
	const char  *tech_name = color_matrix ? "DrawMatrix" : "Draw";
	technique_t tech       = effect_gettechnique(effect, tech_name);
	size_t      passes, i;

	passes = technique_begin(tech);
	for (i = 0; i < passes; i++) {
		technique_beginpass(tech, i);
		if (source->context.data)
			source->info.video_render(source->context.data, effect);
		technique_endpass(tech);
	}
	technique_end(tech);
}

static inline void obs_source_main_render(obs_source_t source)
{
	uint32_t flags      = source->info.output_flags;
	bool color_matrix   = (flags & OBS_SOURCE_COLOR_MATRIX) != 0;
	bool custom_draw    = (flags & OBS_SOURCE_CUSTOM_DRAW) != 0;
	bool default_effect = !source->filter_parent &&
	                      source->filters.num == 0 &&
	                      !custom_draw;

	if (default_effect)
		obs_source_default_render(source, color_matrix);
	else if (source->context.data)
		source->info.video_render(source->context.data,
				custom_draw ? NULL : gs_geteffect());
}

void obs_source_video_render(obs_source_t source)
{
	if (!source_valid(source)) return;

	if (source->filters.num && !source->rendering_filter)
		obs_source_render_filters(source);

	else if (source->info.video_render)
		obs_source_main_render(source);

	else if (source->filter_target)
		obs_source_video_render(source->filter_target);

	else
		obs_source_render_async_video(source);
}

uint32_t obs_source_getwidth(obs_source_t source)
{
	if (!source_valid(source)) return 0;

	if (source->info.getwidth)
		return source->info.getwidth(source->context.data);
	return source->async_width;
}

uint32_t obs_source_getheight(obs_source_t source)
{
	if (!source_valid(source)) return 0;

	if (source->info.getheight)
		return source->info.getheight(source->context.data);
	return source->async_height;
}

obs_source_t obs_filter_getparent(obs_source_t filter)
{
	return filter ? filter->filter_parent : NULL;
}

obs_source_t obs_filter_gettarget(obs_source_t filter)
{
	return filter ? filter->filter_target : NULL;
}

void obs_source_filter_add(obs_source_t source, obs_source_t filter)
{
	if (!source || !filter)
		return;

	pthread_mutex_lock(&source->filter_mutex);

	if (da_find(source->filters, &filter, 0) != DARRAY_INVALID) {
		blog(LOG_WARNING, "Tried to add a filter that was already "
		                  "present on the source");
		return;
	}

	if (source->filters.num) {
		obs_source_t *back = da_end(source->filters);
		(*back)->filter_target = filter;
	}

	da_push_back(source->filters, &filter);

	pthread_mutex_unlock(&source->filter_mutex);

	filter->filter_parent = source;
	filter->filter_target = source;
}

void obs_source_filter_remove(obs_source_t source, obs_source_t filter)
{
	size_t idx;

	if (!source || !filter)
		return;

	pthread_mutex_lock(&source->filter_mutex);

	idx = da_find(source->filters, &filter, 0);
	if (idx == DARRAY_INVALID)
		return;

	if (idx > 0) {
		obs_source_t prev = source->filters.array[idx-1];
		prev->filter_target = filter->filter_target;
	}

	da_erase(source->filters, idx);

	pthread_mutex_unlock(&source->filter_mutex);

	filter->filter_parent = NULL;
	filter->filter_target = NULL;
}

void obs_source_filter_setorder(obs_source_t source, obs_source_t filter,
		enum order_movement movement)
{
	size_t idx, i;

	if (!source || !filter)
		return;

	idx = da_find(source->filters, &filter, 0);
	if (idx == DARRAY_INVALID)
		return;

	if (movement == ORDER_MOVE_UP) {
		if (idx == source->filters.num-1)
			return;
		da_move_item(source->filters, idx, idx+1);

	} else if (movement == ORDER_MOVE_DOWN) {
		if (idx == 0)
			return;
		da_move_item(source->filters, idx, idx-1);

	} else if (movement == ORDER_MOVE_TOP) {
		if (idx == source->filters.num-1)
			return;
		da_move_item(source->filters, idx, source->filters.num-1);

	} else if (movement == ORDER_MOVE_BOTTOM) {
		if (idx == 0)
			return;
		da_move_item(source->filters, idx, 0);
	}


	for (i = 0; i < source->filters.num; i++) {
		obs_source_t next_filter = (i == source->filters.num-1) ?
			source : source->filters.array[idx+1];
		source->filters.array[i]->filter_target = next_filter;
	}
}

obs_data_t obs_source_getsettings(obs_source_t source)
{
	if (!source) return NULL;

	obs_data_addref(source->context.settings);
	return source->context.settings;
}

static inline struct source_frame *filter_async_video(obs_source_t source,
		struct source_frame *in)
{
	size_t i;
	for (i = source->filters.num; i > 0; i--) {
		struct obs_source *filter = source->filters.array[i-1];

		if (filter->context.data && filter->info.filter_video) {
			in = filter->info.filter_video(filter->context.data,
					in);
			if (!in)
				return NULL;
		}
	}

	return in;
}

static inline void copy_frame_data_line(struct source_frame *dst,
		const struct source_frame *src, uint32_t plane, uint32_t y)
{
	uint32_t pos_src = y * src->linesize[plane];
	uint32_t pos_dst = y * dst->linesize[plane];
	uint32_t bytes = dst->linesize[plane] < src->linesize[plane] ?
		dst->linesize[plane] : src->linesize[plane];

	memcpy(dst->data[plane] + pos_dst, src->data[plane] + pos_src, bytes);
}

static inline void copy_frame_data_plane(struct source_frame *dst,
		const struct source_frame *src, uint32_t plane, uint32_t lines)
{
	if (dst->linesize[plane] != src->linesize[plane])
		for (uint32_t y = 0; y < lines; y++)
			copy_frame_data_line(dst, src, plane, y);
	else
		memcpy(dst->data[plane], src->data[plane],
				dst->linesize[plane] * lines);
}

static void copy_frame_data(struct source_frame *dst,
		const struct source_frame *src)
{
	dst->flip         = src->flip;
	dst->full_range   = src->full_range;
	dst->timestamp    = src->timestamp;
	memcpy(dst->color_matrix, src->color_matrix, sizeof(float) * 16);
	if (!dst->full_range) {
		size_t const size = sizeof(float) * 3;
		memcpy(dst->color_range_min, src->color_range_min, size);
		memcpy(dst->color_range_max, src->color_range_max, size);
	}

	switch (dst->format) {
	case VIDEO_FORMAT_I420:
		copy_frame_data_plane(dst, src, 0, dst->height);
		copy_frame_data_plane(dst, src, 1, dst->height/2);
		copy_frame_data_plane(dst, src, 2, dst->height/2);
		break;

	case VIDEO_FORMAT_NV12:
		copy_frame_data_plane(dst, src, 0, dst->height);
		copy_frame_data_plane(dst, src, 1, dst->height/2);
		break;

	case VIDEO_FORMAT_YVYU:
	case VIDEO_FORMAT_YUY2:
	case VIDEO_FORMAT_UYVY:
	case VIDEO_FORMAT_NONE:
	case VIDEO_FORMAT_RGBA:
	case VIDEO_FORMAT_BGRA:
	case VIDEO_FORMAT_BGRX:
		copy_frame_data_plane(dst, src, 0, dst->height);
	}
}

static inline struct source_frame *cache_video(const struct source_frame *frame)
{

	struct source_frame *new_frame = source_frame_create(frame->format,
			frame->width, frame->height);

	copy_frame_data(new_frame, frame);
	return new_frame;
}

static bool ready_async_frame(obs_source_t source, uint64_t sys_time);

static inline void cycle_frames(struct obs_source *source)
{
	if (source->video_frames.num && !source->activate_refs)
		ready_async_frame(source, os_gettime_ns());
}

void obs_source_output_video(obs_source_t source,
		const struct source_frame *frame)
{
	if (!source || !frame)
		return;

	struct source_frame *output = cache_video(frame);

	pthread_mutex_lock(&source->filter_mutex);
	output = filter_async_video(source, output);
	pthread_mutex_unlock(&source->filter_mutex);

	if (output) {
		pthread_mutex_lock(&source->video_mutex);
		cycle_frames(source);
		da_push_back(source->video_frames, &output);
		pthread_mutex_unlock(&source->video_mutex);
	}
}

static inline struct filtered_audio *filter_async_audio(obs_source_t source,
		struct filtered_audio *in)
{
	size_t i;
	for (i = source->filters.num; i > 0; i--) {
		struct obs_source *filter = source->filters.array[i-1];

		if (filter->context.data && filter->info.filter_audio) {
			in = filter->info.filter_audio(filter->context.data,
					in);
			if (!in)
				return NULL;
		}
	}

	return in;
}

static inline void reset_resampler(obs_source_t source,
		const struct source_audio *audio)
{
	const struct audio_output_info *obs_info;
	struct resample_info output_info;

	obs_info = audio_output_getinfo(obs->audio.audio);

	output_info.format           = obs_info->format;
	output_info.samples_per_sec  = obs_info->samples_per_sec;
	output_info.speakers         = obs_info->speakers;

	source->sample_info.format          = audio->format;
	source->sample_info.samples_per_sec = audio->samples_per_sec;
	source->sample_info.speakers        = audio->speakers;

	if (source->sample_info.samples_per_sec == obs_info->samples_per_sec &&
	    source->sample_info.format          == obs_info->format          &&
	    source->sample_info.speakers        == obs_info->speakers) {
		source->audio_failed = false;
		return;
	}

	audio_resampler_destroy(source->resampler);
	source->resampler = audio_resampler_create(&output_info,
			&source->sample_info);

	source->audio_failed = source->resampler == NULL;
	if (source->resampler == NULL)
		blog(LOG_ERROR, "creation of resampler failed");
}

static inline void copy_audio_data(obs_source_t source,
		const uint8_t *const data[], uint32_t frames, uint64_t ts)
{
	size_t planes    = audio_output_planes(obs->audio.audio);
	size_t blocksize = audio_output_blocksize(obs->audio.audio);
	size_t size      = (size_t)frames * blocksize;
	bool   resize    = source->audio_storage_size < size;

	source->audio_data.frames    = frames;
	source->audio_data.timestamp = ts;

	for (size_t i = 0; i < planes; i++) {

		if (resize) {
			bfree(source->audio_data.data[i]);
			source->audio_data.data[i] = bmalloc(size);
		}

		memcpy(source->audio_data.data[i], data[i], size);
	}

	if (resize)
		source->audio_storage_size = size;
}


static void process_audio(obs_source_t source, const struct source_audio *audio)
{
	if (source->sample_info.samples_per_sec != audio->samples_per_sec ||
	    source->sample_info.format          != audio->format          ||
	    source->sample_info.speakers        != audio->speakers)
		reset_resampler(source, audio);

	if (source->audio_failed)
		return;

	if (source->resampler) {
		uint8_t  *output[MAX_AV_PLANES];
		uint32_t frames;
		uint64_t offset;

		memset(output, 0, sizeof(output));

		audio_resampler_resample(source->resampler,
				output, &frames, &offset,
				audio->data, audio->frames);

		copy_audio_data(source, (const uint8_t *const *)output, frames,
				audio->timestamp - offset);
	} else {
		copy_audio_data(source, audio->data, audio->frames,
				audio->timestamp);
	}
}

void obs_source_output_audio(obs_source_t source,
		const struct source_audio *audio)
{
	uint32_t flags;
	struct filtered_audio *output;

	if (!source || !audio)
		return;

	flags = source->info.output_flags;
	process_audio(source, audio);

	pthread_mutex_lock(&source->filter_mutex);
	output = filter_async_audio(source, &source->audio_data);

	if (output) {
		bool async = (flags & OBS_SOURCE_ASYNC) != 0;

		pthread_mutex_lock(&source->audio_mutex);


		if (source->timing_set || !async) {
			struct audio_data data;

			for (int i = 0; i < MAX_AV_PLANES; i++)
				data.data[i] = output->data[i];

			data.frames    = output->frames;
			data.timestamp = output->timestamp;
			source_output_audio_line(source, &data);
		}

		pthread_mutex_unlock(&source->audio_mutex);
	}

	pthread_mutex_unlock(&source->filter_mutex);
}

static inline bool frame_out_of_bounds(obs_source_t source, uint64_t ts)
{
	return ((ts - source->last_frame_ts) > MAX_TIMESTAMP_JUMP);
}

static bool ready_async_frame(obs_source_t source, uint64_t sys_time)
{
	struct source_frame *next_frame = source->video_frames.array[0];
	struct source_frame *frame      = NULL;
	uint64_t sys_offset = sys_time - source->last_sys_timestamp;
	uint64_t frame_time = next_frame->timestamp;
	uint64_t frame_offset = 0;


	if (frame_out_of_bounds(source, frame_time)) {
		source->last_frame_ts = next_frame->timestamp;
		os_atomic_inc_long(&source->av_sync_ref);
	} else {
		frame_offset = frame_time - source->last_frame_ts;
		source->last_frame_ts += frame_offset;
	}

	while (frame_offset <= sys_offset) {
		source_frame_destroy(frame);

		if (source->video_frames.num == 1)
			return true;

		frame = next_frame;
		da_erase(source->video_frames, 0);
		next_frame = source->video_frames.array[0];


		if ((next_frame->timestamp - frame_time) > MAX_TIMESTAMP_JUMP) {
			source->last_frame_ts =
				next_frame->timestamp - frame_offset;
			os_atomic_inc_long(&source->av_sync_ref);
		}

		frame_time   = next_frame->timestamp;
		frame_offset = frame_time - source->last_frame_ts;
	}

	source_frame_destroy(frame);

	return frame != NULL;
}

static inline struct source_frame *get_closest_frame(obs_source_t source,
		uint64_t sys_time)
{
	if (ready_async_frame(source, sys_time)) {
		struct source_frame *frame = source->video_frames.array[0];
		da_erase(source->video_frames, 0);
		return frame;
	}

	return NULL;
}


struct source_frame *obs_source_getframe(obs_source_t source)
{
	struct source_frame *frame = NULL;
	uint64_t sys_time;

	if (!source)
		return NULL;

	pthread_mutex_lock(&source->video_mutex);

	if (!source->video_frames.num)
		goto unlock;

	sys_time = os_gettime_ns();

	if (!source->last_frame_ts) {
		frame = source->video_frames.array[0];
		da_erase(source->video_frames, 0);

		source->last_frame_ts = frame->timestamp;
	} else {
		frame = get_closest_frame(source, sys_time);
	}


	if (frame) {
		source->timing_adjust = sys_time - frame->timestamp;
		source->timing_set = true;
	}

	source->last_sys_timestamp = sys_time;

unlock:
	pthread_mutex_unlock(&source->video_mutex);

	if (frame)
		obs_source_addref(source);

	return frame;
}

void obs_source_releaseframe(obs_source_t source, struct source_frame *frame)
{
	if (source && frame) {
		source_frame_destroy(frame);
		obs_source_release(source);
	}
}

const char *obs_source_getname(obs_source_t source)
{
	return source ? source->context.name : NULL;
}

void obs_source_setname(obs_source_t source, const char *name)
{
	if (!source) return;

	if (!name || !*name || strcmp(name, source->context.name) != 0) {
		struct calldata data;
		char *prev_name = bstrdup(source->context.name);
		obs_context_data_setname(&source->context, name);

		calldata_init(&data);
		calldata_setptr(&data, "source", source);
		calldata_setstring(&data, "new_name", source->context.name);
		calldata_setstring(&data, "prev_name", prev_name);
		signal_handler_signal(obs->signals, "source_rename", &data);
		signal_handler_signal(source->context.signals, "rename", &data);
		calldata_free(&data);
		bfree(prev_name);
	}
}

void obs_source_gettype(obs_source_t source, enum obs_source_type *type,
		const char **id)
{
	if (!source) return;

	if (type) *type = source->info.type;
	if (id)   *id   = source->info.id;
}

static inline void render_filter_bypass(obs_source_t target, effect_t effect,
		bool use_matrix)
{
	const char  *tech_name = use_matrix ? "DrawMatrix" : "Draw";
	technique_t tech       = effect_gettechnique(effect, tech_name);
	size_t      passes, i;

	passes = technique_begin(tech);
	for (i = 0; i < passes; i++) {
		technique_beginpass(tech, i);
		obs_source_video_render(target);
		technique_endpass(tech);
	}
	technique_end(tech);
}

static inline void render_filter_tex(texture_t tex, effect_t effect,
		uint32_t width, uint32_t height, bool use_matrix)
{
	const char  *tech_name = use_matrix ? "DrawMatrix" : "Draw";
	technique_t tech       = effect_gettechnique(effect, tech_name);
	eparam_t    image      = effect_getparambyname(effect, "image");
	size_t      passes, i;

	effect_settexture(image, tex);

	passes = technique_begin(tech);
	for (i = 0; i < passes; i++) {
		technique_beginpass(tech, i);
		gs_draw_sprite(tex, width, height, 0);
		technique_endpass(tech);
	}
	technique_end(tech);
}

void obs_source_process_filter(obs_source_t filter, effect_t effect,
		uint32_t width, uint32_t height, enum gs_color_format format,
		enum allow_direct_render allow_direct)
{
	obs_source_t target, parent;
	uint32_t     target_flags, parent_flags;
	int          cx, cy;
	bool         use_matrix, expects_def, can_directly;

	if (!filter) return;

	target       = obs_filter_gettarget(filter);
	parent       = obs_filter_getparent(filter);
	target_flags = target->info.output_flags;
	parent_flags = parent->info.output_flags;
	cx           = obs_source_getwidth(target);
	cy           = obs_source_getheight(target);
	use_matrix   = !!(target_flags & OBS_SOURCE_COLOR_MATRIX);
	expects_def  = !(parent_flags & OBS_SOURCE_CUSTOM_DRAW);
	can_directly = allow_direct == ALLOW_DIRECT_RENDERING;


	if (can_directly && expects_def && target == parent) {
		render_filter_bypass(target, effect, use_matrix);
		return;
	}

	if (!filter->filter_texrender)
		filter->filter_texrender = texrender_create(format,
				GS_ZS_NONE);

	if (texrender_begin(filter->filter_texrender, cx, cy)) {
		gs_ortho(0.0f, (float)cx, 0.0f, (float)cy, -100.0f, 100.0f);
		if (expects_def && parent == target)
			obs_source_default_render(parent, use_matrix);
		else
			obs_source_video_render(target);
		texrender_end(filter->filter_texrender);
	}



	render_filter_tex(texrender_gettexture(filter->filter_texrender),
			effect, width, height, use_matrix);
}

signal_handler_t obs_source_signalhandler(obs_source_t source)
{
	return source ? source->context.signals : NULL;
}

proc_handler_t obs_source_prochandler(obs_source_t source)
{
	return source ? source->context.procs : NULL;
}

void obs_source_setvolume(obs_source_t source, float volume)
{
	if (source) {
		struct calldata data = {0};
		calldata_setptr(&data, "source", source);
		calldata_setfloat(&data, "volume", volume);

		signal_handler_signal(source->context.signals, "volume", &data);
		signal_handler_signal(obs->signals, "source_volume", &data);

		volume = (float)calldata_float(&data, "volume");
		calldata_free(&data);

		source->user_volume = volume;
	}
}

static void set_tree_preset_vol(obs_source_t parent, obs_source_t child,
		void *param)
{
	float *vol = param;
	child->present_volume = *vol;

	UNUSED_PARAMETER(parent);
}

void obs_source_set_present_volume(obs_source_t source, float volume)
{
	if (source) {
		source->present_volume = volume;


		if (source->info.type != OBS_SOURCE_TYPE_TRANSITION)
			obs_source_enum_tree(source, set_tree_preset_vol,
					&volume);
	}
}

float obs_source_getvolume(obs_source_t source)
{
	return source ? source->user_volume : 0.0f;
}

float obs_source_get_present_volume(obs_source_t source)
{
	return source ? source->present_volume : 0.0f;
}

void obs_source_set_sync_offset(obs_source_t source, int64_t offset)
{
	if (source)
		source->sync_offset = offset;
}

int64_t obs_source_get_sync_offset(obs_source_t source)
{
	return source ? source->sync_offset : 0;
}

struct source_enum_data {
	obs_source_enum_proc_t enum_callback;
	void *param;
};

static void enum_source_tree_callback(obs_source_t parent, obs_source_t child,
		void *param)
{
	struct source_enum_data *data = param;

	if (child->info.enum_sources && !child->enum_refs) {
		os_atomic_inc_long(&child->enum_refs);

		if (child->context.data)
			child->info.enum_sources(child->context.data,
					enum_source_tree_callback, data);

		os_atomic_dec_long(&child->enum_refs);
	}

	data->enum_callback(parent, child, data->param);
}

void obs_source_enum_sources(obs_source_t source,
		obs_source_enum_proc_t enum_callback,
		void *param)
{
	if (!source_valid(source)      ||
	    !source->info.enum_sources ||
	    source->enum_refs)
		return;

	obs_source_addref(source);

	os_atomic_inc_long(&source->enum_refs);
	source->info.enum_sources(source->context.data, enum_callback, param);
	os_atomic_dec_long(&source->enum_refs);

	obs_source_release(source);
}

void obs_source_enum_tree(obs_source_t source,
		obs_source_enum_proc_t enum_callback,
		void *param)
{
	struct source_enum_data data = {enum_callback, param};

	if (!source_valid(source)      ||
	    !source->info.enum_sources ||
	    source->enum_refs)
		return;

	obs_source_addref(source);

	os_atomic_inc_long(&source->enum_refs);
	source->info.enum_sources(source->context.data,
			enum_source_tree_callback,
			&data);
	os_atomic_dec_long(&source->enum_refs);

	obs_source_release(source);
}

void obs_source_add_child(obs_source_t parent, obs_source_t child)
{
	if (!parent || !child) return;

	for (int i = 0; i < parent->show_refs; i++) {
		enum view_type type;
		type = (i < parent->activate_refs) ? MAIN_VIEW : AUX_VIEW;
		obs_source_activate(child, type);
	}
}

void obs_source_remove_child(obs_source_t parent, obs_source_t child)
{
	if (!parent || !child) return;

	for (int i = 0; i < parent->show_refs; i++) {
		enum view_type type;
		type = (i < parent->activate_refs) ? MAIN_VIEW : AUX_VIEW;
		obs_source_deactivate(child, type);
	}
}

static void reset_transition_vol(obs_source_t parent, obs_source_t child,
		void *param)
{
	child->transition_volume = 0.0f;

	UNUSED_PARAMETER(parent);
	UNUSED_PARAMETER(param);
}

static void add_transition_vol(obs_source_t parent, obs_source_t child,
		void *param)
{
	float *vol = param;
	child->transition_volume += *vol;

	UNUSED_PARAMETER(parent);
}

static void apply_transition_vol(obs_source_t parent, obs_source_t child,
		void *param)
{
	child->present_volume = child->transition_volume;

	UNUSED_PARAMETER(parent);
	UNUSED_PARAMETER(param);
}

void obs_transition_begin_frame(obs_source_t transition)
{
	if (!transition) return;
	obs_source_enum_tree(transition, reset_transition_vol, NULL);
}

void obs_source_set_transition_vol(obs_source_t source, float vol)
{
	if (!source) return;

	add_transition_vol(NULL, source, &vol);
	obs_source_enum_tree(source, add_transition_vol, &vol);
}

void obs_transition_end_frame(obs_source_t transition)
{
	if (!transition) return;
	obs_source_enum_tree(transition, apply_transition_vol, NULL);
}

void obs_source_save(obs_source_t source)
{
	if (!source_valid(source) || !source->info.save) return;
	source->info.save(source->context.data, source->context.settings);
}

void obs_source_load(obs_source_t source)
{
	if (!source_valid(source) || !source->info.load) return;
	source->info.load(source->context.data, source->context.settings);
}
<code block>
#include "util/bmem.h"
#include "util/darray.h"
#include "obs-internal.h"
#include "obs-properties.h"

static inline void *get_property_data(struct obs_property *prop);



struct float_data {
	double min, max, step;
	enum obs_number_type type;
};

struct int_data {
	int min, max, step;
	enum obs_number_type type;
};

struct list_item {
	char *name;
	bool disabled;

	union {
		char      *str;
		long long ll;
		double    d;
	};
};

struct path_data {
	char               *filter;
	char               *default_path;
	enum obs_path_type type;
};

struct text_data {
	enum obs_text_type type;
};

struct list_data {
	DARRAY(struct list_item) items;
	enum obs_combo_type      type;
	enum obs_combo_format    format;
};

struct editable_list_data {
	enum obs_editable_list_type type;
	char                        *filter;
	char                        *default_path;
};

struct button_data {
	obs_property_clicked_t callback;
};

struct frame_rate_option {
	char *name;
	char *description;
};

struct frame_rate_range {
	struct media_frames_per_second min_time;
	struct media_frames_per_second max_time;
};

struct frame_rate_data {
	DARRAY(struct frame_rate_option) extra_options;
	DARRAY(struct frame_rate_range)  ranges;
};

static inline void path_data_free(struct path_data *data)
{
	bfree(data->default_path);
	if (data->type == OBS_PATH_FILE)
		bfree(data->filter);
}

static inline void editable_list_data_free(struct editable_list_data *data)
{
	bfree(data->default_path);
	bfree(data->filter);
}

static inline void list_item_free(struct list_data *data,
		struct list_item *item)
{
	bfree(item->name);
	if (data->format == OBS_COMBO_FORMAT_STRING)
		bfree(item->str);
}

static inline void list_data_free(struct list_data *data)
{
	for (size_t i = 0; i < data->items.num; i++)
		list_item_free(data, data->items.array+i);

	da_free(data->items);
}

static inline void frame_rate_data_options_free(struct frame_rate_data *data)
{
	for (size_t i = 0; i < data->extra_options.num; i++) {
		struct frame_rate_option *opt = &data->extra_options.array[i];
		bfree(opt->name);
		bfree(opt->description);
	}

	da_resize(data->extra_options, 0);
}

static inline void frame_rate_data_ranges_free(struct frame_rate_data *data)
{
	da_resize(data->ranges, 0);
}

static inline void frame_rate_data_free(struct frame_rate_data *data)
{
	frame_rate_data_options_free(data);
	frame_rate_data_ranges_free(data);

	da_free(data->extra_options);
	da_free(data->ranges);
}

struct obs_properties;

struct obs_property {
	char                    *name;
	char                    *desc;
	char                    *long_desc;
	void                    *priv;
	enum obs_property_type  type;
	bool                    visible;
	bool                    enabled;

	struct obs_properties   *parent;

	obs_property_modified_t modified;
	obs_property_modified2_t modified2;

	struct obs_property     *next;
};

struct obs_properties {
	void                    *param;
	void                    (*destroy)(void *param);
	uint32_t                flags;

	struct obs_property     *first_property;
	struct obs_property     **last;
};

obs_properties_t *obs_properties_create(void)
{
	struct obs_properties *props;
	props = bzalloc(sizeof(struct obs_properties));
	props->last = &props->first_property;
	return props;
}

void obs_properties_set_param(obs_properties_t *props,
		void *param, void (*destroy)(void *param))
{
	if (!props)
		return;

	if (props->param && props->destroy)
		props->destroy(props->param);

	props->param   = param;
	props->destroy = destroy;
}

void obs_properties_set_flags(obs_properties_t *props, uint32_t flags)
{
	if (props)
		props->flags = flags;
}

uint32_t obs_properties_get_flags(obs_properties_t *props)
{
	return props ? props->flags : 0;
}

void *obs_properties_get_param(obs_properties_t *props)
{
	return props ? props->param : NULL;
}

obs_properties_t *obs_properties_create_param(void *param,
		void (*destroy)(void *param))
{
	struct obs_properties *props = obs_properties_create();
	obs_properties_set_param(props, param, destroy);
	return props;
}

static void obs_property_destroy(struct obs_property *property)
{
	if (property->type == OBS_PROPERTY_LIST)
		list_data_free(get_property_data(property));
	else if (property->type == OBS_PROPERTY_PATH)
		path_data_free(get_property_data(property));
	else if (property->type == OBS_PROPERTY_EDITABLE_LIST)
		editable_list_data_free(get_property_data(property));
	else if (property->type == OBS_PROPERTY_FRAME_RATE)
		frame_rate_data_free(get_property_data(property));

	bfree(property->name);
	bfree(property->desc);
	bfree(property->long_desc);
	bfree(property);
}

void obs_properties_destroy(obs_properties_t *props)
{
	if (props) {
		struct obs_property *p = props->first_property;

		if (props->destroy && props->param)
			props->destroy(props->param);

		while (p) {
			struct obs_property *next = p->next;
			obs_property_destroy(p);
			p = next;
		}

		bfree(props);
	}
}

obs_property_t *obs_properties_first(obs_properties_t *props)
{
	return (props != NULL) ? props->first_property : NULL;
}

obs_property_t *obs_properties_get(obs_properties_t *props, const char *name)
{
	struct obs_property *property;

	if (!props)
		return NULL;

	property = props->first_property;
	while (property) {
		if (strcmp(property->name, name) == 0)
			return property;

		property = property->next;
	}

	return NULL;
}

void obs_properties_apply_settings(obs_properties_t *props, obs_data_t *settings)
{
	struct obs_property *p;

	if (!props)
		return;
	
	p = props->first_property;
	while (p) {
		if (p->modified)
			p->modified(props, p, settings);
		else if (p->modified2)
			p->modified2(p->priv, props, p, settings);
		p = p->next;
	}
}



static inline void propertes_add(struct obs_properties *props,
		struct obs_property *p)
{
	*props->last = p;
	props->last = &p->next;
}

static inline size_t get_property_size(enum obs_property_type type)
{
	switch (type) {
	case OBS_PROPERTY_INVALID:   return 0;
	case OBS_PROPERTY_BOOL:      return 0;
	case OBS_PROPERTY_INT:       return sizeof(struct int_data);
	case OBS_PROPERTY_FLOAT:     return sizeof(struct float_data);
	case OBS_PROPERTY_TEXT:      return sizeof(struct text_data);
	case OBS_PROPERTY_PATH:      return sizeof(struct path_data);
	case OBS_PROPERTY_LIST:      return sizeof(struct list_data);
	case OBS_PROPERTY_COLOR:     return 0;
	case OBS_PROPERTY_BUTTON:    return sizeof(struct button_data);
	case OBS_PROPERTY_FONT:      return 0;
	case OBS_PROPERTY_EDITABLE_LIST:
		return sizeof(struct editable_list_data);
	case OBS_PROPERTY_FRAME_RATE:return sizeof(struct frame_rate_data);
	}

	return 0;
}

static inline struct obs_property *new_prop(struct obs_properties *props,
		const char *name, const char *desc,
		enum obs_property_type type)
{
	size_t data_size = get_property_size(type);
	struct obs_property *p;

	p = bzalloc(sizeof(struct obs_property) + data_size);
	p->parent  = props;
	p->enabled = true;
	p->visible = true;
	p->type    = type;
	p->name    = bstrdup(name);
	p->desc    = bstrdup(desc);
	propertes_add(props, p);

	return p;
}

static inline bool has_prop(struct obs_properties *props, const char *name)
{
	struct obs_property *p = props->first_property;

	while (p) {
		if (strcmp(p->name, name) == 0) {
			blog(LOG_WARNING, "Property '%s' exists", name);
			return true;
		}

		p = p->next;
	}

	return false;
}

static inline void *get_property_data(struct obs_property *prop)
{
	return (uint8_t*)prop + sizeof(struct obs_property);
}

static inline void *get_type_data(struct obs_property *prop,
		enum obs_property_type type)
{
	if (!prop || prop->type != type)
		return NULL;

	return get_property_data(prop);
}

obs_property_t *obs_properties_add_bool(obs_properties_t *props,
		const char *name, const char *desc)
{
	if (!props || has_prop(props, name)) return NULL;
	return new_prop(props, name, desc, OBS_PROPERTY_BOOL);
}

static obs_property_t *add_int(obs_properties_t *props,
		const char *name, const char *desc, int min, int max, int step,
		enum obs_number_type type)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc, OBS_PROPERTY_INT);
	struct int_data *data = get_property_data(p);
	data->min  = min;
	data->max  = max;
	data->step = step;
	data->type = type;
	return p;
}

static obs_property_t *add_flt(obs_properties_t *props,
		const char *name, const char *desc,
		double min, double max, double step,
		enum obs_number_type type)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc,
			OBS_PROPERTY_FLOAT);
	struct float_data *data = get_property_data(p);
	data->min  = min;
	data->max  = max;
	data->step = step;
	data->type = type;
	return p;
}

obs_property_t *obs_properties_add_int(obs_properties_t *props,
		const char *name, const char *desc, int min, int max, int step)
{
	return add_int(props, name, desc, min, max, step, OBS_NUMBER_SCROLLER);
}

obs_property_t *obs_properties_add_float(obs_properties_t *props,
		const char *name, const char *desc,
		double min, double max, double step)
{
	return add_flt(props, name, desc, min, max, step, OBS_NUMBER_SCROLLER);
}

obs_property_t *obs_properties_add_int_slider(obs_properties_t *props,
		const char *name, const char *desc, int min, int max, int step)
{
	return add_int(props, name, desc, min, max, step, OBS_NUMBER_SLIDER);
}

obs_property_t *obs_properties_add_float_slider(obs_properties_t *props,
		const char *name, const char *desc,
		double min, double max, double step)
{
	return add_flt(props, name, desc, min, max, step, OBS_NUMBER_SLIDER);
}

obs_property_t *obs_properties_add_text(obs_properties_t *props,
		const char *name, const char *desc, enum obs_text_type type)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc, OBS_PROPERTY_TEXT);
	struct text_data *data = get_property_data(p);
	data->type = type;
	return p;
}

obs_property_t *obs_properties_add_path(obs_properties_t *props,
		const char *name, const char *desc, enum obs_path_type type,
		const char *filter, const char *default_path)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc, OBS_PROPERTY_PATH);
	struct path_data *data = get_property_data(p);
	data->type         = type;
	data->default_path = bstrdup(default_path);

	if (data->type == OBS_PATH_FILE)
		data->filter = bstrdup(filter);

	return p;
}

obs_property_t *obs_properties_add_list(obs_properties_t *props,
		const char *name, const char *desc,
		enum obs_combo_type type,
		enum obs_combo_format format)
{
	if (!props || has_prop(props, name)) return NULL;

	if (type   == OBS_COMBO_TYPE_EDITABLE &&
	    format != OBS_COMBO_FORMAT_STRING) {
		blog(LOG_WARNING, "List '%s', error: Editable combo boxes "
		                  "must be of the 'string' type", name);
		return NULL;
	}

	struct obs_property *p = new_prop(props, name, desc, OBS_PROPERTY_LIST);
	struct list_data *data = get_property_data(p);
	data->format = format;
	data->type   = type;

	return p;
}

obs_property_t *obs_properties_add_color(obs_properties_t *props,
		const char *name, const char *desc)
{
	if (!props || has_prop(props, name)) return NULL;
	return new_prop(props, name, desc, OBS_PROPERTY_COLOR);
}

obs_property_t *obs_properties_add_button(obs_properties_t *props,
		const char *name, const char *text,
		obs_property_clicked_t callback)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, text,
			OBS_PROPERTY_BUTTON);
	struct button_data *data = get_property_data(p);
	data->callback = callback;
	return p;
}

obs_property_t *obs_properties_add_button2(obs_properties_t *props,
		const char *name, const char *text,
		obs_property_clicked_t callback, void *priv)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, text,
			OBS_PROPERTY_BUTTON);
	struct button_data *data = get_property_data(p);
	data->callback = callback;
	p->priv = priv;
	return p;
}

obs_property_t *obs_properties_add_font(obs_properties_t *props,
		const char *name, const char *desc)
{
	if (!props || has_prop(props, name)) return NULL;
	return new_prop(props, name, desc, OBS_PROPERTY_FONT);
}

obs_property_t *obs_properties_add_editable_list(obs_properties_t *props,
		const char *name, const char *desc,
		enum obs_editable_list_type type, const char *filter,
		const char *default_path)
{
	if (!props || has_prop(props, name)) return NULL;
	struct obs_property *p = new_prop(props, name, desc,
			OBS_PROPERTY_EDITABLE_LIST);

	struct editable_list_data *data = get_property_data(p);
	data->type = type;
	data->filter = bstrdup(filter);
	data->default_path = bstrdup(default_path);
	return p;
}

obs_property_t *obs_properties_add_frame_rate(obs_properties_t *props,
		const char *name, const char *desc)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc,
			OBS_PROPERTY_FRAME_RATE);

	struct frame_rate_data *data = get_property_data(p);
	da_init(data->extra_options);
	da_init(data->ranges);
	return p;
}



static inline bool is_combo(struct obs_property *p)
{
	return p->type == OBS_PROPERTY_LIST;
}

static inline struct list_data *get_list_data(struct obs_property *p)
{
	if (!p || !is_combo(p))
		return NULL;

	return get_property_data(p);
}

static inline struct list_data *get_list_fmt_data(struct obs_property *p,
		enum obs_combo_format format)
{
	struct list_data *data = get_list_data(p);
	return (data && data->format == format) ? data : NULL;
}



bool obs_property_next(obs_property_t **p)
{
	if (!p || !*p)
		return false;

	*p = (*p)->next;
	return *p != NULL;
}

void obs_property_set_modified_callback(obs_property_t *p,
		obs_property_modified_t modified)
{
	if (p) p->modified = modified;
}

void obs_property_set_modified_callback2(obs_property_t *p,
		obs_property_modified2_t modified2, void *priv)
{
	if (p) {
		p->modified2 = modified2;
		p->priv = priv;
	}
}

bool obs_property_modified(obs_property_t *p, obs_data_t *settings)
{
	if (p) {
		if (p->modified) {
			return p->modified(p->parent, p, settings);
		} else if (p->modified2) {
			return p->modified2(p->priv, p->parent, p, settings);
		}
	}
	return false;
}

bool obs_property_button_clicked(obs_property_t *p, void *obj)
{
	struct obs_context_data *context = obj;
	if (p) {
		struct button_data *data = get_type_data(p,
				OBS_PROPERTY_BUTTON);
		if (data && data->callback) {
			if (p->priv)
				return data->callback(p->parent, p, p->priv);
			return data->callback(p->parent, p,
					(context ? context->data : NULL));
		}
	}

	return false;
}

void obs_property_set_visible(obs_property_t *p, bool visible)
{
	if (p) p->visible = visible;
}

void obs_property_set_enabled(obs_property_t *p, bool enabled)
{
	if (p) p->enabled = enabled;
}

void obs_property_set_description(obs_property_t *p, const char *description)
{
	if (p) {
		bfree(p->desc);
		p->desc = description && *description
			? bstrdup(description)
			: NULL;
	}
}

void obs_property_set_long_description(obs_property_t *p, const char *long_desc)
{
	if (p) {
		bfree(p->long_desc);
		p->long_desc = long_desc && *long_desc
			? bstrdup(long_desc)
			: NULL;
	}
}

const char *obs_property_name(obs_property_t *p)
{
	return p ? p->name : NULL;
}

const char *obs_property_description(obs_property_t *p)
{
	return p ? p->desc : NULL;
}

const char *obs_property_long_description(obs_property_t *p)
{
	return p ? p->long_desc : NULL;
}

enum obs_property_type obs_property_get_type(obs_property_t *p)
{
	return p ? p->type : OBS_PROPERTY_INVALID;
}

bool obs_property_enabled(obs_property_t *p)
{
	return p ? p->enabled : false;
}

bool obs_property_visible(obs_property_t *p)
{
	return p ? p->visible : false;
}

int obs_property_int_min(obs_property_t *p)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	return data ? data->min : 0;
}

int obs_property_int_max(obs_property_t *p)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	return data ? data->max : 0;
}

int obs_property_int_step(obs_property_t *p)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	return data ? data->step : 0;
}

enum obs_number_type obs_property_int_type(obs_property_t *p)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	return data ? data->type : OBS_NUMBER_SCROLLER;
}

double obs_property_float_min(obs_property_t *p)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_FLOAT);
	return data ? data->min : 0;
}

double obs_property_float_max(obs_property_t *p)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_FLOAT);
	return data ? data->max : 0;
}

double obs_property_float_step(obs_property_t *p)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_FLOAT);
	return data ? data->step : 0;
}

enum obs_number_type obs_property_float_type(obs_property_t *p)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_FLOAT);
	return data ? data->type : OBS_NUMBER_SCROLLER;
}

enum obs_text_type obs_property_text_type(obs_property_t *p)
{
	struct text_data *data = get_type_data(p, OBS_PROPERTY_TEXT);
	return data ? data->type : OBS_TEXT_DEFAULT;
}

enum obs_path_type obs_property_path_type(obs_property_t *p)
{
	struct path_data *data = get_type_data(p, OBS_PROPERTY_PATH);
	return data ? data->type : OBS_PATH_DIRECTORY;
}

const char *obs_property_path_filter(obs_property_t *p)
{
	struct path_data *data = get_type_data(p, OBS_PROPERTY_PATH);
	return data ? data->filter : NULL;
}

const char *obs_property_path_default_path(obs_property_t *p)
{
	struct path_data *data = get_type_data(p, OBS_PROPERTY_PATH);
	return data ? data->default_path : NULL;
}

enum obs_combo_type obs_property_list_type(obs_property_t *p)
{
	struct list_data *data = get_list_data(p);
	return data ? data->type : OBS_COMBO_TYPE_INVALID;
}

enum obs_combo_format obs_property_list_format(obs_property_t *p)
{
	struct list_data *data = get_list_data(p);
	return data ? data->format : OBS_COMBO_FORMAT_INVALID;
}

void obs_property_int_set_limits(obs_property_t *p,
		int min, int max, int step)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	if (!data)
		return;

	data->min = min;
	data->max = max;
	data->step = step;
}

void obs_property_float_set_limits(obs_property_t *p,
		double min, double max, double step)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_INT);
	if (!data)
		return;

	data->min = min;
	data->max = max;
	data->step = step;
}

void obs_property_list_clear(obs_property_t *p)
{
	struct list_data *data = get_list_data(p);
	if (data)
		list_data_free(data);
}

static size_t add_item(struct list_data *data, const char *name,
		const void *val)
{
	struct list_item item = { NULL };
	item.name  = bstrdup(name);

	if (data->format == OBS_COMBO_FORMAT_INT)
		item.ll  = *(const long long*)val;
	else if (data->format == OBS_COMBO_FORMAT_FLOAT)
		item.d   = *(const double*)val;
	else
		item.str = bstrdup(val);

	return da_push_back(data->items, &item);
}

static void insert_item(struct list_data *data, size_t idx, const char *name,
		const void *val)
{
	struct list_item item = { NULL };
	item.name  = bstrdup(name);

	if (data->format == OBS_COMBO_FORMAT_INT)
		item.ll  = *(const long long*)val;
	else if (data->format == OBS_COMBO_FORMAT_FLOAT)
		item.d   = *(const double*)val;
	else
		item.str = bstrdup(val);

	da_insert(data->items, idx, &item);
}

size_t obs_property_list_add_string(obs_property_t *p,
		const char *name, const char *val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_STRING)
		return add_item(data, name, val);
	return 0;
}

size_t obs_property_list_add_int(obs_property_t *p,
		const char *name, long long val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_INT)
		return add_item(data, name, &val);
	return 0;
}

size_t obs_property_list_add_float(obs_property_t *p,
		const char *name, double val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_FLOAT)
		return add_item(data, name, &val);
	return 0;
}

void obs_property_list_insert_string(obs_property_t *p, size_t idx,
		const char *name, const char *val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_STRING)
		insert_item(data, idx, name, val);
}

void obs_property_list_insert_int(obs_property_t *p, size_t idx,
		const char *name, long long val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_INT)
		insert_item(data, idx, name, &val);
}

void obs_property_list_insert_float(obs_property_t *p, size_t idx,
		const char *name, double val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_FLOAT)
		insert_item(data, idx, name, &val);
}

void obs_property_list_item_remove(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_data(p);
	if (data && idx < data->items.num) {
		list_item_free(data, data->items.array+idx);
		da_erase(data->items, idx);
	}
}

size_t obs_property_list_item_count(obs_property_t *p)
{
	struct list_data *data = get_list_data(p);
	return data ? data->items.num : 0;
}

bool obs_property_list_item_disabled(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_data(p);
	return (data && idx < data->items.num) ?
		data->items.array[idx].disabled : false;
}

void obs_property_list_item_disable(obs_property_t *p, size_t idx,
		bool disabled)
{
	struct list_data *data = get_list_data(p);
	if (!data || idx >= data->items.num)
		return;
	data->items.array[idx].disabled = disabled;
}

const char *obs_property_list_item_name(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_data(p);
	return (data && idx < data->items.num) ?
		data->items.array[idx].name : NULL;
}

const char *obs_property_list_item_string(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_fmt_data(p, OBS_COMBO_FORMAT_STRING);
	return (data && idx < data->items.num) ?
		data->items.array[idx].str : NULL;
}

long long obs_property_list_item_int(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_fmt_data(p, OBS_COMBO_FORMAT_INT);
	return (data && idx < data->items.num) ?
		data->items.array[idx].ll : 0;
}

double obs_property_list_item_float(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_fmt_data(p, OBS_COMBO_FORMAT_FLOAT);
	return (data && idx < data->items.num) ?
		data->items.array[idx].d : 0.0;
}

enum obs_editable_list_type obs_property_editable_list_type(obs_property_t *p)
{
	struct editable_list_data *data = get_type_data(p,
			OBS_PROPERTY_EDITABLE_LIST);
	return data ? data->type : OBS_EDITABLE_LIST_TYPE_STRINGS;
}

const char *obs_property_editable_list_filter(obs_property_t *p)
{
	struct editable_list_data *data = get_type_data(p,
			OBS_PROPERTY_EDITABLE_LIST);
	return data ? data->filter : NULL;
}

const char *obs_property_editable_list_default_path(obs_property_t *p)
{
	struct editable_list_data *data = get_type_data(p,
			OBS_PROPERTY_EDITABLE_LIST);
	return data ? data->default_path : NULL;
}




void obs_property_frame_rate_clear(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	frame_rate_data_options_free(data);
	frame_rate_data_ranges_free(data);
}

void obs_property_frame_rate_options_clear(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	frame_rate_data_options_free(data);
}

void obs_property_frame_rate_fps_ranges_clear(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	frame_rate_data_ranges_free(data);
}

size_t obs_property_frame_rate_option_add(obs_property_t *p,
		const char *name, const char *description)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return DARRAY_INVALID;

	struct frame_rate_option *opt = da_push_back_new(data->extra_options);

	opt->name        = bstrdup(name);
	opt->description = bstrdup(description);

	return data->extra_options.num - 1;
}

size_t obs_property_frame_rate_fps_range_add(obs_property_t *p,
		struct media_frames_per_second min,
		struct media_frames_per_second max)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return DARRAY_INVALID;

	struct frame_rate_range *rng = da_push_back_new(data->ranges);

	rng->min_time = min;
	rng->max_time = max;

	return data->ranges.num - 1;
}

void obs_property_frame_rate_option_insert(obs_property_t *p, size_t idx,
		const char *name, const char *description)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	struct frame_rate_option *opt = da_insert_new(data->extra_options, idx);

	opt->name        = bstrdup(name);
	opt->description = bstrdup(description);
}

void obs_property_frame_rate_fps_range_insert(obs_property_t *p, size_t idx,
		struct media_frames_per_second min,
		struct media_frames_per_second max)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	struct frame_rate_range *rng = da_insert_new(data->ranges, idx);

	rng->min_time = min;
	rng->max_time = max;
}

size_t obs_property_frame_rate_options_count(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data ? data->extra_options.num : 0;
}

const char *obs_property_frame_rate_option_name(obs_property_t *p,
		size_t idx)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data && data->extra_options.num > idx ?
		data->extra_options.array[idx].name : NULL;
}

const char *obs_property_frame_rate_option_description(
		obs_property_t *p, size_t idx)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data && data->extra_options.num > idx ?
		data->extra_options.array[idx].description : NULL;
}

size_t obs_property_frame_rate_fps_ranges_count(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data ? data->ranges.num : 0;
}

struct media_frames_per_second obs_property_frame_rate_fps_range_min(
		obs_property_t *p, size_t idx)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data && data->ranges.num > idx ?
		data->ranges.array[idx].min_time :
		(struct media_frames_per_second){0};
}
struct media_frames_per_second obs_property_frame_rate_fps_range_max(
		obs_property_t *p, size_t idx)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data && data->ranges.num > idx ?
		data->ranges.array[idx].max_time :
		(struct media_frames_per_second){0};
}

enum obs_text_type obs_proprety_text_type(obs_property_t *p)
{
	return obs_property_text_type(p);
}
<code block>
#include "util/bmem.h"
#include "util/darray.h"
#include "obs-internal.h"
#include "obs-properties.h"

static inline void *get_property_data(struct obs_property *prop);



struct float_data {
	double min, max, step;
	enum obs_number_type type;
};

struct int_data {
	int min, max, step;
	enum obs_number_type type;
};

struct list_item {
	char *name;
	bool disabled;

	union {
		char      *str;
		long long ll;
		double    d;
	};
};

struct path_data {
	char               *filter;
	char               *default_path;
	enum obs_path_type type;
};

struct text_data {
	enum obs_text_type type;
};

struct list_data {
	DARRAY(struct list_item) items;
	enum obs_combo_type      type;
	enum obs_combo_format    format;
};

struct editable_list_data {
	enum obs_editable_list_type type;
	char                        *filter;
	char                        *default_path;
};

struct button_data {
	obs_property_clicked_t callback;
};

struct frame_rate_option {
	char *name;
	char *description;
};

struct frame_rate_range {
	struct media_frames_per_second min_time;
	struct media_frames_per_second max_time;
};

struct frame_rate_data {
	DARRAY(struct frame_rate_option) extra_options;
	DARRAY(struct frame_rate_range)  ranges;
};

static inline void path_data_free(struct path_data *data)
{
	bfree(data->default_path);
	if (data->type == OBS_PATH_FILE)
		bfree(data->filter);
}

static inline void editable_list_data_free(struct editable_list_data *data)
{
	bfree(data->default_path);
	bfree(data->filter);
}

static inline void list_item_free(struct list_data *data,
		struct list_item *item)
{
	bfree(item->name);
	if (data->format == OBS_COMBO_FORMAT_STRING)
		bfree(item->str);
}

static inline void list_data_free(struct list_data *data)
{
	for (size_t i = 0; i < data->items.num; i++)
		list_item_free(data, data->items.array+i);

	da_free(data->items);
}

static inline void frame_rate_data_options_free(struct frame_rate_data *data)
{
	for (size_t i = 0; i < data->extra_options.num; i++) {
		struct frame_rate_option *opt = &data->extra_options.array[i];
		bfree(opt->name);
		bfree(opt->description);
	}

	da_resize(data->extra_options, 0);
}

static inline void frame_rate_data_ranges_free(struct frame_rate_data *data)
{
	da_resize(data->ranges, 0);
}

static inline void frame_rate_data_free(struct frame_rate_data *data)
{
	frame_rate_data_options_free(data);
	frame_rate_data_ranges_free(data);

	da_free(data->extra_options);
	da_free(data->ranges);
}

struct obs_properties;

struct obs_property {
	char                    *name;
	char                    *desc;
	char                    *long_desc;
	void                    *priv;
	enum obs_property_type  type;
	bool                    visible;
	bool                    enabled;

	struct obs_properties   *parent;

	obs_property_modified_t modified;
	obs_property_modified2_t modified2;

	struct obs_property     *next;
};

struct obs_properties {
	void                    *param;
	void                    (*destroy)(void *param);
	uint32_t                flags;

	struct obs_property     *first_property;
	struct obs_property     **last;
};

obs_properties_t *obs_properties_create(void)
{
	struct obs_properties *props;
	props = bzalloc(sizeof(struct obs_properties));
	props->last = &props->first_property;
	return props;
}

void obs_properties_set_param(obs_properties_t *props,
		void *param, void (*destroy)(void *param))
{
	if (!props)
		return;

	if (props->param && props->destroy)
		props->destroy(props->param);

	props->param   = param;
	props->destroy = destroy;
}

void obs_properties_set_flags(obs_properties_t *props, uint32_t flags)
{
	if (props)
		props->flags = flags;
}

uint32_t obs_properties_get_flags(obs_properties_t *props)
{
	return props ? props->flags : 0;
}

void *obs_properties_get_param(obs_properties_t *props)
{
	return props ? props->param : NULL;
}

obs_properties_t *obs_properties_create_param(void *param,
		void (*destroy)(void *param))
{
	struct obs_properties *props = obs_properties_create();
	obs_properties_set_param(props, param, destroy);
	return props;
}

static void obs_property_destroy(struct obs_property *property)
{
	if (property->type == OBS_PROPERTY_LIST)
		list_data_free(get_property_data(property));
	else if (property->type == OBS_PROPERTY_PATH)
		path_data_free(get_property_data(property));
	else if (property->type == OBS_PROPERTY_EDITABLE_LIST)
		editable_list_data_free(get_property_data(property));
	else if (property->type == OBS_PROPERTY_FRAME_RATE)
		frame_rate_data_free(get_property_data(property));

	bfree(property->name);
	bfree(property->desc);
	bfree(property->long_desc);
	bfree(property);
}

void obs_properties_destroy(obs_properties_t *props)
{
	if (props) {
		struct obs_property *p = props->first_property;

		if (props->destroy && props->param)
			props->destroy(props->param);

		while (p) {
			struct obs_property *next = p->next;
			obs_property_destroy(p);
			p = next;
		}

		bfree(props);
	}
}

obs_property_t *obs_properties_first(obs_properties_t *props)
{
	return (props != NULL) ? props->first_property : NULL;
}

obs_property_t *obs_properties_get(obs_properties_t *props, const char *name)
{
	struct obs_property *property;

	if (!props)
		return NULL;

	property = props->first_property;
	while (property) {
		if (strcmp(property->name, name) == 0)
			return property;

		property = property->next;
	}

	return NULL;
}

void obs_properties_apply_settings(obs_properties_t *props, obs_data_t *settings)
{
	struct obs_property *p;

	if (!props)
		return;
	
	p = props->first_property;
	while (p) {
		if (p->modified)
			p->modified(props, p, settings);
		else if (p->modified2)
			p->modified2(p->priv, props, p, settings);
		p = p->next;
	}
}



static inline void propertes_add(struct obs_properties *props,
		struct obs_property *p)
{
	*props->last = p;
	props->last = &p->next;
}

static inline size_t get_property_size(enum obs_property_type type)
{
	switch (type) {
	case OBS_PROPERTY_INVALID:   return 0;
	case OBS_PROPERTY_BOOL:      return 0;
	case OBS_PROPERTY_INT:       return sizeof(struct int_data);
	case OBS_PROPERTY_FLOAT:     return sizeof(struct float_data);
	case OBS_PROPERTY_TEXT:      return sizeof(struct text_data);
	case OBS_PROPERTY_PATH:      return sizeof(struct path_data);
	case OBS_PROPERTY_LIST:      return sizeof(struct list_data);
	case OBS_PROPERTY_COLOR:     return 0;
	case OBS_PROPERTY_BUTTON:    return sizeof(struct button_data);
	case OBS_PROPERTY_FONT:      return 0;
	case OBS_PROPERTY_EDITABLE_LIST:
		return sizeof(struct editable_list_data);
	case OBS_PROPERTY_FRAME_RATE:return sizeof(struct frame_rate_data);
	}

	return 0;
}

static inline struct obs_property *new_prop(struct obs_properties *props,
		const char *name, const char *desc,
		enum obs_property_type type)
{
	size_t data_size = get_property_size(type);
	struct obs_property *p;

	p = bzalloc(sizeof(struct obs_property) + data_size);
	p->parent  = props;
	p->enabled = true;
	p->visible = true;
	p->type    = type;
	p->name    = bstrdup(name);
	p->desc    = bstrdup(desc);
	propertes_add(props, p);

	return p;
}

static inline bool has_prop(struct obs_properties *props, const char *name)
{
	struct obs_property *p = props->first_property;

	while (p) {
		if (strcmp(p->name, name) == 0) {
			blog(LOG_WARNING, "Property '%s' exists", name);
			return true;
		}

		p = p->next;
	}

	return false;
}

static inline void *get_property_data(struct obs_property *prop)
{
	return (uint8_t*)prop + sizeof(struct obs_property);
}

static inline void *get_type_data(struct obs_property *prop,
		enum obs_property_type type)
{
	if (!prop || prop->type != type)
		return NULL;

	return get_property_data(prop);
}

obs_property_t *obs_properties_add_bool(obs_properties_t *props,
		const char *name, const char *desc)
{
	if (!props || has_prop(props, name)) return NULL;
	return new_prop(props, name, desc, OBS_PROPERTY_BOOL);
}

static obs_property_t *add_int(obs_properties_t *props,
		const char *name, const char *desc, int min, int max, int step,
		enum obs_number_type type)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc, OBS_PROPERTY_INT);
	struct int_data *data = get_property_data(p);
	data->min  = min;
	data->max  = max;
	data->step = step;
	data->type = type;
	return p;
}

static obs_property_t *add_flt(obs_properties_t *props,
		const char *name, const char *desc,
		double min, double max, double step,
		enum obs_number_type type)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc,
			OBS_PROPERTY_FLOAT);
	struct float_data *data = get_property_data(p);
	data->min  = min;
	data->max  = max;
	data->step = step;
	data->type = type;
	return p;
}

obs_property_t *obs_properties_add_int(obs_properties_t *props,
		const char *name, const char *desc, int min, int max, int step)
{
	return add_int(props, name, desc, min, max, step, OBS_NUMBER_SCROLLER);
}

obs_property_t *obs_properties_add_float(obs_properties_t *props,
		const char *name, const char *desc,
		double min, double max, double step)
{
	return add_flt(props, name, desc, min, max, step, OBS_NUMBER_SCROLLER);
}

obs_property_t *obs_properties_add_int_slider(obs_properties_t *props,
		const char *name, const char *desc, int min, int max, int step)
{
	return add_int(props, name, desc, min, max, step, OBS_NUMBER_SLIDER);
}

obs_property_t *obs_properties_add_float_slider(obs_properties_t *props,
		const char *name, const char *desc,
		double min, double max, double step)
{
	return add_flt(props, name, desc, min, max, step, OBS_NUMBER_SLIDER);
}

obs_property_t *obs_properties_add_text(obs_properties_t *props,
		const char *name, const char *desc, enum obs_text_type type)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc, OBS_PROPERTY_TEXT);
	struct text_data *data = get_property_data(p);
	data->type = type;
	return p;
}

obs_property_t *obs_properties_add_path(obs_properties_t *props,
		const char *name, const char *desc, enum obs_path_type type,
		const char *filter, const char *default_path)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc, OBS_PROPERTY_PATH);
	struct path_data *data = get_property_data(p);
	data->type         = type;
	data->default_path = bstrdup(default_path);

	if (data->type == OBS_PATH_FILE)
		data->filter = bstrdup(filter);

	return p;
}

obs_property_t *obs_properties_add_list(obs_properties_t *props,
		const char *name, const char *desc,
		enum obs_combo_type type,
		enum obs_combo_format format)
{
	if (!props || has_prop(props, name)) return NULL;

	if (type   == OBS_COMBO_TYPE_EDITABLE &&
	    format != OBS_COMBO_FORMAT_STRING) {
		blog(LOG_WARNING, "List '%s', error: Editable combo boxes "
		                  "must be of the 'string' type", name);
		return NULL;
	}

	struct obs_property *p = new_prop(props, name, desc, OBS_PROPERTY_LIST);
	struct list_data *data = get_property_data(p);
	data->format = format;
	data->type   = type;

	return p;
}

obs_property_t *obs_properties_add_color(obs_properties_t *props,
		const char *name, const char *desc)
{
	if (!props || has_prop(props, name)) return NULL;
	return new_prop(props, name, desc, OBS_PROPERTY_COLOR);
}

obs_property_t *obs_properties_add_button(obs_properties_t *props,
		const char *name, const char *text,
		obs_property_clicked_t callback)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, text,
			OBS_PROPERTY_BUTTON);
	struct button_data *data = get_property_data(p);
	data->callback = callback;
	return p;
}

obs_property_t *obs_properties_add_button2(obs_properties_t *props,
		const char *name, const char *text,
		obs_property_clicked_t callback, void *priv)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, text,
			OBS_PROPERTY_BUTTON);
	struct button_data *data = get_property_data(p);
	data->callback = callback;
	p->priv = priv;
	return p;
}

obs_property_t *obs_properties_add_font(obs_properties_t *props,
		const char *name, const char *desc)
{
	if (!props || has_prop(props, name)) return NULL;
	return new_prop(props, name, desc, OBS_PROPERTY_FONT);
}

obs_property_t *obs_properties_add_editable_list(obs_properties_t *props,
		const char *name, const char *desc,
		enum obs_editable_list_type type, const char *filter,
		const char *default_path)
{
	if (!props || has_prop(props, name)) return NULL;
	struct obs_property *p = new_prop(props, name, desc,
			OBS_PROPERTY_EDITABLE_LIST);

	struct editable_list_data *data = get_property_data(p);
	data->type = type;
	data->filter = bstrdup(filter);
	data->default_path = bstrdup(default_path);
	return p;
}

obs_property_t *obs_properties_add_frame_rate(obs_properties_t *props,
		const char *name, const char *desc)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc,
			OBS_PROPERTY_FRAME_RATE);

	struct frame_rate_data *data = get_property_data(p);
	da_init(data->extra_options);
	da_init(data->ranges);
	return p;
}



static inline bool is_combo(struct obs_property *p)
{
	return p->type == OBS_PROPERTY_LIST;
}

static inline struct list_data *get_list_data(struct obs_property *p)
{
	if (!p || !is_combo(p))
		return NULL;

	return get_property_data(p);
}

static inline struct list_data *get_list_fmt_data(struct obs_property *p,
		enum obs_combo_format format)
{
	struct list_data *data = get_list_data(p);
	return (data && data->format == format) ? data : NULL;
}



bool obs_property_next(obs_property_t **p)
{
	if (!p || !*p)
		return false;

	*p = (*p)->next;
	return *p != NULL;
}

void obs_property_set_modified_callback(obs_property_t *p,
		obs_property_modified_t modified)
{
	if (p) p->modified = modified;
}

void obs_property_set_modified_callback2(obs_property_t *p,
		obs_property_modified2_t modified2, void *priv)
{
	if (p) {
		p->modified2 = modified2;
		p->priv = priv;
	}
}

bool obs_property_modified(obs_property_t *p, obs_data_t *settings)
{
	if (p) {
		if (p->modified) {
			return p->modified(p->parent, p, settings);
		} else if (p->modified2) {
			return p->modified2(p->priv, p->parent, p, settings);
		}
	}
	return false;
}

bool obs_property_button_clicked(obs_property_t *p, void *obj)
{
	struct obs_context_data *context = obj;
	if (p) {
		struct button_data *data = get_type_data(p,
				OBS_PROPERTY_BUTTON);
		if (data && data->callback) {
			if (p->priv)
				return data->callback(p->parent, p, p->priv);
			return data->callback(p->parent, p,
					(context ? context->data : NULL));
		}
	}

	return false;
}

void obs_property_set_visible(obs_property_t *p, bool visible)
{
	if (p) p->visible = visible;
}

void obs_property_set_enabled(obs_property_t *p, bool enabled)
{
	if (p) p->enabled = enabled;
}

void obs_property_set_description(obs_property_t *p, const char *description)
{
	if (p) {
		bfree(p->desc);
		p->desc = description && *description
			? bstrdup(description)
			: NULL;
	}
}

void obs_property_set_long_description(obs_property_t *p, const char *long_desc)
{
	if (p) {
		bfree(p->long_desc);
		p->long_desc = long_desc && *long_desc
			? bstrdup(long_desc)
			: NULL;
	}
}

const char *obs_property_name(obs_property_t *p)
{
	return p ? p->name : NULL;
}

const char *obs_property_description(obs_property_t *p)
{
	return p ? p->desc : NULL;
}

const char *obs_property_long_description(obs_property_t *p)
{
	return p ? p->long_desc : NULL;
}

enum obs_property_type obs_property_get_type(obs_property_t *p)
{
	return p ? p->type : OBS_PROPERTY_INVALID;
}

bool obs_property_enabled(obs_property_t *p)
{
	return p ? p->enabled : false;
}

bool obs_property_visible(obs_property_t *p)
{
	return p ? p->visible : false;
}

int obs_property_int_min(obs_property_t *p)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	return data ? data->min : 0;
}

int obs_property_int_max(obs_property_t *p)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	return data ? data->max : 0;
}

int obs_property_int_step(obs_property_t *p)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	return data ? data->step : 0;
}

enum obs_number_type obs_property_int_type(obs_property_t *p)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	return data ? data->type : OBS_NUMBER_SCROLLER;
}

double obs_property_float_min(obs_property_t *p)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_FLOAT);
	return data ? data->min : 0;
}

double obs_property_float_max(obs_property_t *p)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_FLOAT);
	return data ? data->max : 0;
}

double obs_property_float_step(obs_property_t *p)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_FLOAT);
	return data ? data->step : 0;
}

enum obs_number_type obs_property_float_type(obs_property_t *p)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_FLOAT);
	return data ? data->type : OBS_NUMBER_SCROLLER;
}

enum obs_text_type obs_proprety_text_type(obs_property_t *p)
{
	struct text_data *data = get_type_data(p, OBS_PROPERTY_TEXT);
	return data ? data->type : OBS_TEXT_DEFAULT;
}

enum obs_path_type obs_property_path_type(obs_property_t *p)
{
	struct path_data *data = get_type_data(p, OBS_PROPERTY_PATH);
	return data ? data->type : OBS_PATH_DIRECTORY;
}

const char *obs_property_path_filter(obs_property_t *p)
{
	struct path_data *data = get_type_data(p, OBS_PROPERTY_PATH);
	return data ? data->filter : NULL;
}

const char *obs_property_path_default_path(obs_property_t *p)
{
	struct path_data *data = get_type_data(p, OBS_PROPERTY_PATH);
	return data ? data->default_path : NULL;
}

enum obs_combo_type obs_property_list_type(obs_property_t *p)
{
	struct list_data *data = get_list_data(p);
	return data ? data->type : OBS_COMBO_TYPE_INVALID;
}

enum obs_combo_format obs_property_list_format(obs_property_t *p)
{
	struct list_data *data = get_list_data(p);
	return data ? data->format : OBS_COMBO_FORMAT_INVALID;
}

void obs_property_int_set_limits(obs_property_t *p,
		int min, int max, int step)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	if (!data)
		return;

	data->min = min;
	data->max = max;
	data->step = step;
}

void obs_property_float_set_limits(obs_property_t *p,
		double min, double max, double step)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_INT);
	if (!data)
		return;

	data->min = min;
	data->max = max;
	data->step = step;
}

void obs_property_list_clear(obs_property_t *p)
{
	struct list_data *data = get_list_data(p);
	if (data)
		list_data_free(data);
}

static size_t add_item(struct list_data *data, const char *name,
		const void *val)
{
	struct list_item item = { NULL };
	item.name  = bstrdup(name);

	if (data->format == OBS_COMBO_FORMAT_INT)
		item.ll  = *(const long long*)val;
	else if (data->format == OBS_COMBO_FORMAT_FLOAT)
		item.d   = *(const double*)val;
	else
		item.str = bstrdup(val);

	return da_push_back(data->items, &item);
}

static void insert_item(struct list_data *data, size_t idx, const char *name,
		const void *val)
{
	struct list_item item = { NULL };
	item.name  = bstrdup(name);

	if (data->format == OBS_COMBO_FORMAT_INT)
		item.ll  = *(const long long*)val;
	else if (data->format == OBS_COMBO_FORMAT_FLOAT)
		item.d   = *(const double*)val;
	else
		item.str = bstrdup(val);

	da_insert(data->items, idx, &item);
}

size_t obs_property_list_add_string(obs_property_t *p,
		const char *name, const char *val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_STRING)
		return add_item(data, name, val);
	return 0;
}

size_t obs_property_list_add_int(obs_property_t *p,
		const char *name, long long val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_INT)
		return add_item(data, name, &val);
	return 0;
}

size_t obs_property_list_add_float(obs_property_t *p,
		const char *name, double val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_FLOAT)
		return add_item(data, name, &val);
	return 0;
}

void obs_property_list_insert_string(obs_property_t *p, size_t idx,
		const char *name, const char *val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_STRING)
		insert_item(data, idx, name, val);
}

void obs_property_list_insert_int(obs_property_t *p, size_t idx,
		const char *name, long long val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_INT)
		insert_item(data, idx, name, &val);
}

void obs_property_list_insert_float(obs_property_t *p, size_t idx,
		const char *name, double val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_FLOAT)
		insert_item(data, idx, name, &val);
}

void obs_property_list_item_remove(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_data(p);
	if (data && idx < data->items.num) {
		list_item_free(data, data->items.array+idx);
		da_erase(data->items, idx);
	}
}

size_t obs_property_list_item_count(obs_property_t *p)
{
	struct list_data *data = get_list_data(p);
	return data ? data->items.num : 0;
}

bool obs_property_list_item_disabled(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_data(p);
	return (data && idx < data->items.num) ?
		data->items.array[idx].disabled : false;
}

void obs_property_list_item_disable(obs_property_t *p, size_t idx,
		bool disabled)
{
	struct list_data *data = get_list_data(p);
	if (!data || idx >= data->items.num)
		return;
	data->items.array[idx].disabled = disabled;
}

const char *obs_property_list_item_name(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_data(p);
	return (data && idx < data->items.num) ?
		data->items.array[idx].name : NULL;
}

const char *obs_property_list_item_string(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_fmt_data(p, OBS_COMBO_FORMAT_STRING);
	return (data && idx < data->items.num) ?
		data->items.array[idx].str : NULL;
}

long long obs_property_list_item_int(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_fmt_data(p, OBS_COMBO_FORMAT_INT);
	return (data && idx < data->items.num) ?
		data->items.array[idx].ll : 0;
}

double obs_property_list_item_float(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_fmt_data(p, OBS_COMBO_FORMAT_FLOAT);
	return (data && idx < data->items.num) ?
		data->items.array[idx].d : 0.0;
}

enum obs_editable_list_type obs_property_editable_list_type(obs_property_t *p)
{
	struct editable_list_data *data = get_type_data(p,
			OBS_PROPERTY_EDITABLE_LIST);
	return data ? data->type : OBS_EDITABLE_LIST_TYPE_STRINGS;
}

const char *obs_property_editable_list_filter(obs_property_t *p)
{
	struct editable_list_data *data = get_type_data(p,
			OBS_PROPERTY_EDITABLE_LIST);
	return data ? data->filter : NULL;
}

const char *obs_property_editable_list_default_path(obs_property_t *p)
{
	struct editable_list_data *data = get_type_data(p,
			OBS_PROPERTY_EDITABLE_LIST);
	return data ? data->default_path : NULL;
}




void obs_property_frame_rate_clear(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	frame_rate_data_options_free(data);
	frame_rate_data_ranges_free(data);
}

void obs_property_frame_rate_options_clear(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	frame_rate_data_options_free(data);
}

void obs_property_frame_rate_fps_ranges_clear(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	frame_rate_data_ranges_free(data);
}

size_t obs_property_frame_rate_option_add(obs_property_t *p,
		const char *name, const char *description)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return DARRAY_INVALID;

	struct frame_rate_option *opt = da_push_back_new(data->extra_options);

	opt->name        = bstrdup(name);
	opt->description = bstrdup(description);

	return data->extra_options.num - 1;
}

size_t obs_property_frame_rate_fps_range_add(obs_property_t *p,
		struct media_frames_per_second min,
		struct media_frames_per_second max)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return DARRAY_INVALID;

	struct frame_rate_range *rng = da_push_back_new(data->ranges);

	rng->min_time = min;
	rng->max_time = max;

	return data->ranges.num - 1;
}

void obs_property_frame_rate_option_insert(obs_property_t *p, size_t idx,
		const char *name, const char *description)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	struct frame_rate_option *opt = da_insert_new(data->extra_options, idx);

	opt->name        = bstrdup(name);
	opt->description = bstrdup(description);
}

void obs_property_frame_rate_fps_range_insert(obs_property_t *p, size_t idx,
		struct media_frames_per_second min,
		struct media_frames_per_second max)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	struct frame_rate_range *rng = da_insert_new(data->ranges, idx);

	rng->min_time = min;
	rng->max_time = max;
}

size_t obs_property_frame_rate_options_count(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data ? data->extra_options.num : 0;
}

const char *obs_property_frame_rate_option_name(obs_property_t *p,
		size_t idx)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data && data->extra_options.num > idx ?
		data->extra_options.array[idx].name : NULL;
}

const char *obs_property_frame_rate_option_description(
		obs_property_t *p, size_t idx)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data && data->extra_options.num > idx ?
		data->extra_options.array[idx].description : NULL;
}

size_t obs_property_frame_rate_fps_ranges_count(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data ? data->ranges.num : 0;
}

struct media_frames_per_second obs_property_frame_rate_fps_range_min(
		obs_property_t *p, size_t idx)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data && data->ranges.num > idx ?
		data->ranges.array[idx].min_time :
		(struct media_frames_per_second){0};
}
struct media_frames_per_second obs_property_frame_rate_fps_range_max(
		obs_property_t *p, size_t idx)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data && data->ranges.num > idx ?
		data->ranges.array[idx].max_time :
		(struct media_frames_per_second){0};
}
<code block>
#include <assert.h>

#include <graphics/vec2.h>
#include <graphics/vec3.h>
#include <graphics/vec4.h>
#include <graphics/matrix3.h>
#include <graphics/matrix4.h>
#include "gl-subsystem.h"
#include "gl-shaderparser.h"

static inline void shader_param_init(struct gs_shader_param *param)
{
	memset(param, 0, sizeof(struct gs_shader_param));
}

static inline void shader_param_free(struct gs_shader_param *param)
{
	bfree(param->name);
	da_free(param->cur_value);
	da_free(param->def_value);
}

static inline void shader_attrib_free(struct shader_attrib *attrib)
{
	bfree(attrib->name);
}

static void gl_get_shader_info(GLuint shader, const char *file,
		char **error_string)
{
	char    *errors;
	GLint   info_len = 0;
	GLsizei chars_written = 0;

	glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &info_len);
	if (!gl_success("glGetProgramiv") || !info_len)
		return;

	errors = bzalloc(info_len+1);
	glGetShaderInfoLog(shader, info_len, &chars_written, errors);
	gl_success("glGetShaderInfoLog");

	blog(LOG_DEBUG, "Compiler warnings/errors for %s:\n%s", file, errors);

	if (error_string)
		*error_string = errors;
	else
		bfree(errors);
}

static bool gl_add_param(struct gs_shader *shader, struct shader_var *var,
		GLint *texture_id)
{
	struct gs_shader_param param = {0};

	param.array_count = var->array_count;
	param.name        = bstrdup(var->name);
	param.shader      = shader;
	param.type        = get_shader_param_type(var->type);

	if (param.type == GS_SHADER_PARAM_TEXTURE) {
		param.sampler_id  = var->gl_sampler_id;
		param.texture_id  = (*texture_id)++;
	} else {
		param.changed = true;
	}

	da_move(param.def_value, var->default_val);
	da_copy(param.cur_value, param.def_value);

	da_push_back(shader->params, &param);
	return true;
}

static inline bool gl_add_params(struct gs_shader *shader,
		struct gl_shader_parser *glsp)
{
	size_t i;
	GLint tex_id = 0;

	for (i = 0; i < glsp->parser.params.num; i++)
		if (!gl_add_param(shader, glsp->parser.params.array+i, &tex_id))
			return false;

	shader->viewproj = gs_shader_get_param_by_name(shader, "ViewProj");
	shader->world    = gs_shader_get_param_by_name(shader, "World");

	return true;
}

static inline void gl_add_sampler(struct gs_shader *shader,
		struct shader_sampler *sampler)
{
	gs_samplerstate_t *new_sampler;
	struct gs_sampler_info info;

	shader_sampler_convert(sampler, &info);
	new_sampler = device_samplerstate_create(shader->device, &info);

	da_push_back(shader->samplers, &new_sampler);
}

static inline void gl_add_samplers(struct gs_shader *shader,
		struct gl_shader_parser *glsp)
{
	size_t i;
	for (i = 0; i < glsp->parser.samplers.num; i++) {
		struct shader_sampler *sampler = glsp->parser.samplers.array+i;
		gl_add_sampler(shader, sampler);
	}
}

static void get_attrib_type(const char *mapping, enum attrib_type *type,
		size_t *index)
{
	if (strcmp(mapping, "POSITION") == 0) {
		*type  = ATTRIB_POSITION;

	} else if (strcmp(mapping, "NORMAL") == 0) {
		*type  = ATTRIB_NORMAL;

	} else if (strcmp(mapping, "TANGENT") == 0) {
		*type  = ATTRIB_TANGENT;

	} else if (strcmp(mapping, "COLOR") == 0) {
		*type  = ATTRIB_COLOR;

	} else if (astrcmp_n(mapping, "TEXCOORD", 8) == 0) {
		*type  = ATTRIB_TEXCOORD;
		*index = (*(mapping+8)) - '0';
		return;

	} else if (strcmp(mapping, "TARGET") == 0) {
		*type  = ATTRIB_TARGET;
	}

	*index = 0;
}

static inline bool gl_process_attrib(struct gs_shader *program,
		struct gl_parser_attrib *pa)
{
	struct shader_attrib attrib = {0};


	if (!pa->input)
		return true;

	get_attrib_type(pa->mapping, &attrib.type, &attrib.index);
	attrib.name = pa->name.array;

	pa->name.array    = NULL;
	pa->name.len      = 0;
	pa->name.capacity = 0;

	da_push_back(program->attribs, &attrib);
	return true;
}

static inline bool gl_process_attribs(struct gs_shader *shader,
		struct gl_shader_parser *glsp)
{
	size_t i;
	for (i = 0; i < glsp->attribs.num; i++) {
		struct gl_parser_attrib *pa = glsp->attribs.array+i;
		if (!gl_process_attrib(shader, pa))
			return false;
	}

	return true;
}

static bool gl_shader_init(struct gs_shader *shader,
		struct gl_shader_parser *glsp,
		const char *file, char **error_string)
{
	GLenum type = convert_shader_type(shader->type);
	int compiled = 0;
	bool success = true;

	shader->obj = glCreateShader(type);
	if (!gl_success("glCreateShader") || !shader->obj)
		return false;

	glShaderSource(shader->obj, 1, (const GLchar**)&glsp->gl_string.array,
			0);
	if (!gl_success("glShaderSource"))
		return false;

	glCompileShader(shader->obj);
	if (!gl_success("glCompileShader"))
		return false;

#if 0
	blog(LOG_DEBUG, "+++++++++++++++++++++++++++++++++++");
	blog(LOG_DEBUG, "  GL shader string for: %s", file);
	blog(LOG_DEBUG, "-----------------------------------");
	blog(LOG_DEBUG, "%s", glsp->gl_string.array);
	blog(LOG_DEBUG, "+++++++++++++++++++++++++++++++++++");
#endif

	glGetShaderiv(shader->obj, GL_COMPILE_STATUS, &compiled);
	if (!gl_success("glGetShaderiv"))
		return false;

	if (!compiled)
		success = false;

	gl_get_shader_info(shader->obj, file, error_string);

	if (success)
		success = gl_add_params(shader, glsp);

	if (success && shader->type == GS_SHADER_VERTEX)
		success = gl_process_attribs(shader, glsp);
	if (success)
		gl_add_samplers(shader, glsp);

	return success;
}

static struct gs_shader *shader_create(gs_device_t *device,
		enum gs_shader_type type, const char *shader_str,
		const char *file, char **error_string)
{
	struct gs_shader *shader = bzalloc(sizeof(struct gs_shader));
	struct gl_shader_parser glsp;
	bool success = true;

	shader->device = device;
	shader->type   = type;

	gl_shader_parser_init(&glsp, type);
	if (!gl_shader_parse(&glsp, shader_str, file))
		success = false;
	else
		success = gl_shader_init(shader, &glsp, file, error_string);

	if (!success) {
		gs_shader_destroy(shader);
		shader = NULL;
	}

	gl_shader_parser_free(&glsp);
	return shader;
}

gs_shader_t *device_vertexshader_create(gs_device_t *device,
		const char *shader, const char *file,
		char **error_string)
{
	struct gs_shader *ptr;
	ptr = shader_create(device, GS_SHADER_VERTEX, shader, file,
			error_string);
	if (!ptr)
		blog(LOG_ERROR, "device_vertexshader_create (GL) failed");
	return ptr;
}

gs_shader_t *device_pixelshader_create(gs_device_t *device,
		const char *shader, const char *file,
		char **error_string)
{
	struct gs_shader *ptr;
	ptr = shader_create(device, GS_SHADER_PIXEL, shader, file,
			error_string);
	if (!ptr)
		blog(LOG_ERROR, "device_pixelshader_create (GL) failed");
	return ptr;
}

static void remove_program_references(struct gs_shader *shader)
{
	struct gs_program *program = shader->device->first_program;

	while (program) {
		struct gs_program *next = program->next;
		bool destroy = false;

		if (shader->type == GS_SHADER_VERTEX &&
				program->vertex_shader == shader)
			destroy = true;

		else if (shader->type == GS_SHADER_PIXEL &&
				program->pixel_shader == shader)
			destroy = true;

		if (destroy)
			gs_program_destroy(program);

		program = next;
	}
}

void gs_shader_destroy(gs_shader_t *shader)
{
	size_t i;

	if (!shader)
		return;

	remove_program_references(shader);

	for (i = 0; i < shader->attribs.num; i++)
		shader_attrib_free(shader->attribs.array+i);

	for (i = 0; i < shader->samplers.num; i++)
		gs_samplerstate_destroy(shader->samplers.array[i]);

	for (i = 0; i < shader->params.num; i++)
		shader_param_free(shader->params.array+i);

	if (shader->obj) {
		glDeleteShader(shader->obj);
		gl_success("glDeleteShader");
	}

	da_free(shader->samplers);
	da_free(shader->params);
	da_free(shader->attribs);
	bfree(shader);
}

int gs_shader_get_num_params(const gs_shader_t *shader)
{
	return (int)shader->params.num;
}

gs_sparam_t *gs_shader_get_param_by_idx(gs_shader_t *shader, uint32_t param)
{
	assert(param < shader->params.num);
	return shader->params.array+param;
}

gs_sparam_t *gs_shader_get_param_by_name(gs_shader_t *shader, const char *name)
{
	size_t i;
	for (i = 0; i < shader->params.num; i++) {
		struct gs_shader_param *param = shader->params.array+i;

		if (strcmp(param->name, name) == 0)
			return param;
	}

	return NULL;
}

gs_sparam_t *gs_shader_get_viewproj_matrix(const gs_shader_t *shader)
{
	return shader->viewproj;
}

gs_sparam_t *gs_shader_get_world_matrix(const gs_shader_t *shader)
{
	return shader->world;
}

void gs_shader_get_param_info(const gs_sparam_t *param,
		struct gs_shader_param_info *info)
{
	info->type = param->type;
	info->name = param->name;
}

void gs_shader_set_bool(gs_sparam_t *param, bool val)
{
	int int_val = val;
	da_copy_array(param->cur_value, &int_val, sizeof(int_val));
}

void gs_shader_set_float(gs_sparam_t *param, float val)
{
	da_copy_array(param->cur_value, &val, sizeof(val));
}

void gs_shader_set_int(gs_sparam_t *param, int val)
{
	da_copy_array(param->cur_value, &val, sizeof(val));
}

void gs_shader_set_matrix3(gs_sparam_t *param, const struct matrix3 *val)
{
	struct matrix4 mat;
	matrix4_from_matrix3(&mat, val);

	da_copy_array(param->cur_value, &mat, sizeof(mat));
}

void gs_shader_set_matrix4(gs_sparam_t *param, const struct matrix4 *val)
{
	da_copy_array(param->cur_value, val, sizeof(*val));
}

void gs_shader_set_vec2(gs_sparam_t *param, const struct vec2 *val)
{
	da_copy_array(param->cur_value, val->ptr, sizeof(*val));
}

void gs_shader_set_vec3(gs_sparam_t *param, const struct vec3 *val)
{
	da_copy_array(param->cur_value, val->ptr, sizeof(*val));
}

void gs_shader_set_vec4(gs_sparam_t *param, const struct vec4 *val)
{
	da_copy_array(param->cur_value, val->ptr, sizeof(*val));
}

void gs_shader_set_texture(gs_sparam_t *param, gs_texture_t *val)
{
	param->texture = val;
}

static inline bool validate_param(struct program_param *pp,
		size_t expected_size)
{
	if (pp->param->cur_value.num != expected_size) {
		blog(LOG_ERROR, "Parameter '%s' set to invalid size %u, "
		                "expected %u",
		                pp->param->name,
		                (unsigned int)pp->param->cur_value.num,
		                (unsigned int)expected_size);
		return false;
	}

	return true;
}

static void program_set_param_data(struct gs_program *program,
		struct program_param *pp)
{
	void *array = pp->param->cur_value.array;

	if (pp->param->type == GS_SHADER_PARAM_BOOL ||
	    pp->param->type == GS_SHADER_PARAM_INT) {
		if (validate_param(pp, sizeof(int))) {
			glUniform1iv(pp->obj, 1, (int*)array);
			gl_success("glUniform1iv");
		}

	} else if (pp->param->type == GS_SHADER_PARAM_FLOAT) {
		if (validate_param(pp, sizeof(float))) {
			glUniform1fv(pp->obj, 1, (float*)array);
			gl_success("glUniform1fv");
		}

	} else if (pp->param->type == GS_SHADER_PARAM_VEC2) {
		if (validate_param(pp, sizeof(struct vec2))) {
			glUniform2fv(pp->obj, 1, (float*)array);
			gl_success("glUniform2fv");
		}

	} else if (pp->param->type == GS_SHADER_PARAM_VEC3) {
		if (validate_param(pp, sizeof(float) * 3)) {
			glUniform3fv(pp->obj, 1, (float*)array);
			gl_success("glUniform3fv");
		}

	} else if (pp->param->type == GS_SHADER_PARAM_VEC4) {
		if (validate_param(pp, sizeof(struct vec4))) {
			glUniform4fv(pp->obj, 1, (float*)array);
			gl_success("glUniform4fv");
		}

	} else if (pp->param->type == GS_SHADER_PARAM_MATRIX4X4) {
		if (validate_param(pp, sizeof(struct matrix4))) {
			glUniformMatrix4fv(pp->obj, 1, false,
					(float*)array);
			gl_success("glUniformMatrix4fv");
		}

	} else if (pp->param->type == GS_SHADER_PARAM_TEXTURE) {
		glUniform1i(pp->obj, pp->param->texture_id);
		device_load_texture(program->device, pp->param->texture,
				pp->param->texture_id);
	}
}

void program_update_params(struct gs_program *program)
{
	for (size_t i = 0; i < program->params.num; i++) {
		struct program_param *pp = program->params.array + i;
		program_set_param_data(program, pp);
	}
}

static void print_link_errors(GLuint program)
{
	char    *errors = NULL;
	GLint   info_len = 0;
	GLsizei chars_written = 0;

	glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_len);
	if (!gl_success("glGetProgramiv") || !info_len)
		return;

	errors = calloc(1, info_len+1);
	glGetProgramInfoLog(program, info_len, &chars_written, errors);
	gl_success("glGetShaderInfoLog");

	blog(LOG_DEBUG, "Linker warnings/errors:\n%s", errors);

	free(errors);
}

static bool assign_program_attrib(struct gs_program *program,
		struct shader_attrib *attrib)
{
	GLint attrib_obj = glGetAttribLocation(program->obj, attrib->name);
	if (!gl_success("glGetAttribLocation"))
		return false;

	if (attrib_obj == -1) {
		blog(LOG_ERROR, "glGetAttribLocation: Could not find "
		                "attribute '%s'", attrib->name);
		return false;
	}

	da_push_back(program->attribs, &attrib_obj);
	return true;
}

static inline bool assign_program_attribs(struct gs_program *program)
{
	struct gs_shader *shader = program->vertex_shader;

	for (size_t i = 0; i < shader->attribs.num; i++) {
		struct shader_attrib *attrib = shader->attribs.array + i;
		if (!assign_program_attrib(program, attrib))
			return false;
	}

	return true;
}

static bool assign_program_param(struct gs_program *program,
		struct gs_shader_param *param)
{
	struct program_param info;

	info.obj = glGetUniformLocation(program->obj, param->name);
	if (!gl_success("glGetUniformLocation"))
		return false;

	if (info.obj == -1) {
		return true;
	}

	info.param = param;
	da_push_back(program->params, &info);
	return true;
}

static inline bool assign_program_shader_params(struct gs_program *program,
		struct gs_shader *shader)
{
	for (size_t i = 0; i < shader->params.num; i++) {
		struct gs_shader_param *param = shader->params.array + i;
		if (!assign_program_param(program, param))
			return false;
	}

	return true;
}

static inline bool assign_program_params(struct gs_program *program)
{
	if (!assign_program_shader_params(program, program->vertex_shader))
		return false;
	if (!assign_program_shader_params(program, program->pixel_shader))
		return false;

	return true;
}

struct gs_program *gs_program_create(struct gs_device *device)
{
	struct gs_program *program = bzalloc(sizeof(*program));
	int linked = false;

	program->device        = device;
	program->vertex_shader = device->cur_vertex_shader;
	program->pixel_shader  = device->cur_pixel_shader;

	program->obj = glCreateProgram();
	if (!gl_success("glCreateProgram"))
		goto error_detach_neither;

	glAttachShader(program->obj, program->vertex_shader->obj);
	if (!gl_success("glAttachShader (vertex)"))
		goto error_detach_neither;

	glAttachShader(program->obj, program->pixel_shader->obj);
	if (!gl_success("glAttachShader (pixel)"))
		goto error_detach_vertex;

	glLinkProgram(program->obj);
	if (!gl_success("glLinkProgram"))
		goto error;

	glGetProgramiv(program->obj, GL_LINK_STATUS, &linked);
	if (!gl_success("glGetProgramiv"))
		goto error;

	if (linked == GL_FALSE) {
		print_link_errors(program->obj);
		goto error;
	}

	if (!assign_program_attribs(program))
		goto error;
	if (!assign_program_params(program))
		goto error;

	glDetachShader(program->obj, program->vertex_shader->obj);
	gl_success("glDetachShader (vertex)");

	glDetachShader(program->obj, program->pixel_shader->obj);
	gl_success("glDetachShader (pixel)");

	program->next = device->first_program;
	program->prev_next = &device->first_program;
	device->first_program = program;
	if (program->next)
		program->next->prev_next = &program->next;

	return program;

error:
	glDetachShader(program->obj, program->pixel_shader->obj);
	gl_success("glDetachShader (pixel)");

error_detach_vertex:
	glDetachShader(program->obj, program->vertex_shader->obj);
	gl_success("glDetachShader (vertex)");

error_detach_neither:
	gs_program_destroy(program);
	return NULL;
}

void gs_program_destroy(struct gs_program *program)
{
	if (!program)
		return;

	if (program->device->cur_program == program) {
		program->device->cur_program = 0;
		glUseProgram(0);
		gl_success("glUseProgram (zero)");
	}

	da_free(program->attribs);
	da_free(program->params);

	if (program->next)
		program->next->prev_next = program->prev_next;
	if (program->prev_next)
		*program->prev_next = program->next;

	glDeleteProgram(program->obj);
	gl_success("glDeleteProgram");

	bfree(program);
}

void gs_shader_set_val(gs_sparam_t *param, const void *val, size_t size)
{
	int count = param->array_count;
	size_t expected_size = 0;
	if (!count)
		count = 1;

	switch ((uint32_t)param->type) {
	case GS_SHADER_PARAM_FLOAT:     expected_size = sizeof(float); break;
	case GS_SHADER_PARAM_BOOL:
	case GS_SHADER_PARAM_INT:       expected_size = sizeof(int); break;
	case GS_SHADER_PARAM_VEC2:      expected_size = sizeof(float)*2; break;
	case GS_SHADER_PARAM_VEC3:      expected_size = sizeof(float)*3; break;
	case GS_SHADER_PARAM_VEC4:      expected_size = sizeof(float)*4; break;
	case GS_SHADER_PARAM_MATRIX4X4: expected_size = sizeof(float)*4*4;break;
	case GS_SHADER_PARAM_TEXTURE:   expected_size = sizeof(void*); break;
	default:                        expected_size = 0;
	}

	expected_size *= count;
	if (!expected_size)
		return;

	if (expected_size != size) {
		blog(LOG_ERROR, "gs_shader_set_val (GL): Size of shader "
		                "param does not match the size of the input");
		return;
	}

	if (param->type == GS_SHADER_PARAM_TEXTURE)
		gs_shader_set_texture(param, *(gs_texture_t**)val);
	else
		da_copy_array(param->cur_value, val, size);
}

void gs_shader_set_default(gs_sparam_t *param)
{
	gs_shader_set_val(param, param->def_value.array, param->def_value.num);
}
<code block>
#include <assert.h>

#include <graphics/vec2.h>
#include <graphics/vec3.h>
#include <graphics/vec4.h>
#include <graphics/matrix3.h>
#include <graphics/matrix4.h>
#include "gl-subsystem.h"
#include "gl-shaderparser.h"

static inline void shader_param_init(struct gs_shader_param *param)
{
	memset(param, 0, sizeof(struct gs_shader_param));
}

static inline void shader_param_free(struct gs_shader_param *param)
{
	bfree(param->name);
	da_free(param->cur_value);
	da_free(param->def_value);
}

static inline void shader_attrib_free(struct shader_attrib *attrib)
{
	bfree(attrib->name);
}

static void gl_get_shader_info(GLuint shader, const char *file,
		char **error_string)
{
	char    *errors;
	GLint   info_len = 0;
	GLsizei chars_written = 0;

	glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &info_len);
	if (!gl_success("glGetProgramiv") || !info_len)
		return;

	errors = bzalloc(info_len+1);
	glGetShaderInfoLog(shader, info_len, &chars_written, errors);
	gl_success("glGetShaderInfoLog");

	blog(LOG_DEBUG, "Compiler warnings/errors for %s:\n%s", file, errors);

	if (error_string)
		*error_string = errors;
	else
		bfree(errors);
}

static bool gl_add_param(struct gs_shader *shader, struct shader_var *var,
		GLint *texture_id)
{
	struct gs_shader_param param = {0};

	param.array_count = var->array_count;
	param.name        = bstrdup(var->name);
	param.shader      = shader;
	param.type        = get_shader_param_type(var->type);

	if (param.type == GS_SHADER_PARAM_TEXTURE) {
		param.sampler_id  = var->gl_sampler_id;
		param.texture_id  = (*texture_id)++;
	} else {
		param.changed = true;
	}

	da_move(param.def_value, var->default_val);
	da_copy(param.cur_value, param.def_value);

	da_push_back(shader->params, &param);
	return true;
}

static inline bool gl_add_params(struct gs_shader *shader,
		struct gl_shader_parser *glsp)
{
	size_t i;
	GLint tex_id = 0;

	for (i = 0; i < glsp->parser.params.num; i++)
		if (!gl_add_param(shader, glsp->parser.params.array+i, &tex_id))
			return false;

	shader->viewproj = gs_shader_get_param_by_name(shader, "ViewProj");
	shader->world    = gs_shader_get_param_by_name(shader, "World");

	return true;
}

static inline void gl_add_sampler(struct gs_shader *shader,
		struct shader_sampler *sampler)
{
	gs_samplerstate_t *new_sampler;
	struct gs_sampler_info info;

	shader_sampler_convert(sampler, &info);
	new_sampler = device_samplerstate_create(shader->device, &info);

	da_push_back(shader->samplers, &new_sampler);
}

static inline void gl_add_samplers(struct gs_shader *shader,
		struct gl_shader_parser *glsp)
{
	size_t i;
	for (i = 0; i < glsp->parser.samplers.num; i++) {
		struct shader_sampler *sampler = glsp->parser.samplers.array+i;
		gl_add_sampler(shader, sampler);
	}
}

static void get_attrib_type(const char *mapping, enum attrib_type *type,
		size_t *index)
{
	if (strcmp(mapping, "POSITION") == 0) {
		*type  = ATTRIB_POSITION;

	} else if (strcmp(mapping, "NORMAL") == 0) {
		*type  = ATTRIB_NORMAL;

	} else if (strcmp(mapping, "TANGENT") == 0) {
		*type  = ATTRIB_TANGENT;

	} else if (strcmp(mapping, "COLOR") == 0) {
		*type  = ATTRIB_COLOR;

	} else if (astrcmp_n(mapping, "TEXCOORD", 8) == 0) {
		*type  = ATTRIB_TEXCOORD;
		*index = (*(mapping+8)) - '0';
		return;

	} else if (strcmp(mapping, "TARGET") == 0) {
		*type  = ATTRIB_TARGET;
	}

	*index = 0;
}

static inline bool gl_process_attrib(struct gs_shader *program,
		struct gl_parser_attrib *pa)
{
	struct shader_attrib attrib = {0};


	if (!pa->input)
		return true;

	get_attrib_type(pa->mapping, &attrib.type, &attrib.index);
	attrib.name = pa->name.array;

	pa->name.array    = NULL;
	pa->name.len      = 0;
	pa->name.capacity = 0;

	da_push_back(program->attribs, &attrib);
	return true;
}

static inline bool gl_process_attribs(struct gs_shader *shader,
		struct gl_shader_parser *glsp)
{
	size_t i;
	for (i = 0; i < glsp->attribs.num; i++) {
		struct gl_parser_attrib *pa = glsp->attribs.array+i;
		if (!gl_process_attrib(shader, pa))
			return false;
	}

	return true;
}

static bool gl_shader_init(struct gs_shader *shader,
		struct gl_shader_parser *glsp,
		const char *file, char **error_string)
{
	GLenum type = convert_shader_type(shader->type);
	int compiled = 0;
	bool success = true;

	shader->obj = glCreateShader(type);
	if (!gl_success("glCreateShader") || !shader->obj)
		return false;

	glShaderSource(shader->obj, 1, (const GLchar**)&glsp->gl_string.array,
			0);
	if (!gl_success("glShaderSource"))
		return false;

	glCompileShader(shader->obj);
	if (!gl_success("glCompileShader"))
		return false;

#if 0
	blog(LOG_DEBUG, "+++++++++++++++++++++++++++++++++++");
	blog(LOG_DEBUG, "  GL shader string for: %s", file);
	blog(LOG_DEBUG, "-----------------------------------");
	blog(LOG_DEBUG, "%s", glsp->gl_string.array);
	blog(LOG_DEBUG, "+++++++++++++++++++++++++++++++++++");
#endif

	glGetShaderiv(shader->obj, GL_COMPILE_STATUS, &compiled);
	if (!gl_success("glGetShaderiv"))
		return false;

	if (!compiled)
		success = false;

	gl_get_shader_info(shader->obj, file, error_string);

	if (success)
		success = gl_add_params(shader, glsp);

	if (success && shader->type == GS_SHADER_VERTEX)
		success = gl_process_attribs(shader, glsp);
	if (success)
		gl_add_samplers(shader, glsp);

	return success;
}

static struct gs_shader *shader_create(gs_device_t *device,
		enum gs_shader_type type, const char *shader_str,
		const char *file, char **error_string)
{
	struct gs_shader *shader = bzalloc(sizeof(struct gs_shader));
	struct gl_shader_parser glsp;
	bool success = true;

	shader->device = device;
	shader->type   = type;

	gl_shader_parser_init(&glsp, type);
	if (!gl_shader_parse(&glsp, shader_str, file))
		success = false;
	else
		success = gl_shader_init(shader, &glsp, file, error_string);

	if (!success) {
		gs_shader_destroy(shader);
		shader = NULL;
	}

	gl_shader_parser_free(&glsp);
	return shader;
}

gs_shader_t *device_vertexshader_create(gs_device_t *device,
		const char *shader, const char *file,
		char **error_string)
{
	struct gs_shader *ptr;
	ptr = shader_create(device, GS_SHADER_VERTEX, shader, file,
			error_string);
	if (!ptr)
		blog(LOG_ERROR, "device_vertexshader_create (GL) failed");
	return ptr;
}

gs_shader_t *device_pixelshader_create(gs_device_t *device,
		const char *shader, const char *file,
		char **error_string)
{
	struct gs_shader *ptr;
	ptr = shader_create(device, GS_SHADER_PIXEL, shader, file,
			error_string);
	if (!ptr)
		blog(LOG_ERROR, "device_pixelshader_create (GL) failed");
	return ptr;
}

static void remove_program_references(struct gs_shader *shader)
{
	struct gs_program *program = shader->device->first_program;

	while (program) {
		struct gs_program *next = program->next;
		bool destroy = false;

		if (shader->type == GS_SHADER_VERTEX &&
				program->vertex_shader == shader)
			destroy = true;

		else if (shader->type == GS_SHADER_PIXEL &&
				program->pixel_shader == shader)
			destroy = true;

		if (destroy)
			gs_program_destroy(program);

		program = next;
	}
}

void gs_shader_destroy(gs_shader_t *shader)
{
	size_t i;

	if (!shader)
		return;

	remove_program_references(shader);

	for (i = 0; i < shader->attribs.num; i++)
		shader_attrib_free(shader->attribs.array+i);

	for (i = 0; i < shader->samplers.num; i++)
		gs_samplerstate_destroy(shader->samplers.array[i]);

	for (i = 0; i < shader->params.num; i++)
		shader_param_free(shader->params.array+i);

	if (shader->obj) {
		glDeleteShader(shader->obj);
		gl_success("glDeleteShader");
	}

	da_free(shader->samplers);
	da_free(shader->params);
	da_free(shader->attribs);
	bfree(shader);
}

int gs_shader_get_num_params(const gs_shader_t *shader)
{
	return (int)shader->params.num;
}

gs_sparam_t *gs_shader_get_param_by_idx(gs_shader_t *shader, uint32_t param)
{
	assert(param < shader->params.num);
	return shader->params.array+param;
}

gs_sparam_t *gs_shader_get_param_by_name(gs_shader_t *shader, const char *name)
{
	size_t i;
	for (i = 0; i < shader->params.num; i++) {
		struct gs_shader_param *param = shader->params.array+i;

		if (strcmp(param->name, name) == 0)
			return param;
	}

	return NULL;
}

gs_sparam_t *gs_shader_get_viewproj_matrix(const gs_shader_t *shader)
{
	return shader->viewproj;
}

gs_sparam_t *gs_shader_get_world_matrix(const gs_shader_t *shader)
{
	return shader->world;
}

void gs_shader_get_param_info(const gs_sparam_t *param,
		struct gs_shader_param_info *info)
{
	info->type = param->type;
	info->name = param->name;
}

void gs_shader_set_bool(gs_sparam_t *param, bool val)
{
	int int_val = val;
	da_copy_array(param->cur_value, &int_val, sizeof(int_val));
}

void gs_shader_set_float(gs_sparam_t *param, float val)
{
	da_copy_array(param->cur_value, &val, sizeof(val));
}

void gs_shader_set_int(gs_sparam_t *param, int val)
{
	da_copy_array(param->cur_value, &val, sizeof(val));
}

void gs_shader_setmatrix3(gs_sparam_t *param, const struct matrix3 *val)
{
	struct matrix4 mat;
	matrix4_from_matrix3(&mat, val);

	da_copy_array(param->cur_value, &mat, sizeof(mat));
}

void gs_shader_set_matrix4(gs_sparam_t *param, const struct matrix4 *val)
{
	da_copy_array(param->cur_value, val, sizeof(*val));
}

void gs_shader_set_vec2(gs_sparam_t *param, const struct vec2 *val)
{
	da_copy_array(param->cur_value, val->ptr, sizeof(*val));
}

void gs_shader_set_vec3(gs_sparam_t *param, const struct vec3 *val)
{
	da_copy_array(param->cur_value, val->ptr, sizeof(*val));
}

void gs_shader_set_vec4(gs_sparam_t *param, const struct vec4 *val)
{
	da_copy_array(param->cur_value, val->ptr, sizeof(*val));
}

void gs_shader_set_texture(gs_sparam_t *param, gs_texture_t *val)
{
	param->texture = val;
}

static inline bool validate_param(struct program_param *pp,
		size_t expected_size)
{
	if (pp->param->cur_value.num != expected_size) {
		blog(LOG_ERROR, "Parameter '%s' set to invalid size %u, "
		                "expected %u",
		                pp->param->name,
		                (unsigned int)pp->param->cur_value.num,
		                (unsigned int)expected_size);
		return false;
	}

	return true;
}

static void program_set_param_data(struct gs_program *program,
		struct program_param *pp)
{
	void *array = pp->param->cur_value.array;

	if (pp->param->type == GS_SHADER_PARAM_BOOL ||
	    pp->param->type == GS_SHADER_PARAM_INT) {
		if (validate_param(pp, sizeof(int))) {
			glUniform1iv(pp->obj, 1, (int*)array);
			gl_success("glUniform1iv");
		}

	} else if (pp->param->type == GS_SHADER_PARAM_FLOAT) {
		if (validate_param(pp, sizeof(float))) {
			glUniform1fv(pp->obj, 1, (float*)array);
			gl_success("glUniform1fv");
		}

	} else if (pp->param->type == GS_SHADER_PARAM_VEC2) {
		if (validate_param(pp, sizeof(struct vec2))) {
			glUniform2fv(pp->obj, 1, (float*)array);
			gl_success("glUniform2fv");
		}

	} else if (pp->param->type == GS_SHADER_PARAM_VEC3) {
		if (validate_param(pp, sizeof(float) * 3)) {
			glUniform3fv(pp->obj, 1, (float*)array);
			gl_success("glUniform3fv");
		}

	} else if (pp->param->type == GS_SHADER_PARAM_VEC4) {
		if (validate_param(pp, sizeof(struct vec4))) {
			glUniform4fv(pp->obj, 1, (float*)array);
			gl_success("glUniform4fv");
		}

	} else if (pp->param->type == GS_SHADER_PARAM_MATRIX4X4) {
		if (validate_param(pp, sizeof(struct matrix4))) {
			glUniformMatrix4fv(pp->obj, 1, false,
					(float*)array);
			gl_success("glUniformMatrix4fv");
		}

	} else if (pp->param->type == GS_SHADER_PARAM_TEXTURE) {
		glUniform1i(pp->obj, pp->param->texture_id);
		device_load_texture(program->device, pp->param->texture,
				pp->param->texture_id);
	}
}

void program_update_params(struct gs_program *program)
{
	for (size_t i = 0; i < program->params.num; i++) {
		struct program_param *pp = program->params.array + i;
		program_set_param_data(program, pp);
	}
}

static void print_link_errors(GLuint program)
{
	char    *errors = NULL;
	GLint   info_len = 0;
	GLsizei chars_written = 0;

	glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_len);
	if (!gl_success("glGetProgramiv") || !info_len)
		return;

	errors = calloc(1, info_len+1);
	glGetProgramInfoLog(program, info_len, &chars_written, errors);
	gl_success("glGetShaderInfoLog");

	blog(LOG_DEBUG, "Linker warnings/errors:\n%s", errors);

	free(errors);
}

static bool assign_program_attrib(struct gs_program *program,
		struct shader_attrib *attrib)
{
	GLint attrib_obj = glGetAttribLocation(program->obj, attrib->name);
	if (!gl_success("glGetAttribLocation"))
		return false;

	if (attrib_obj == -1) {
		blog(LOG_ERROR, "glGetAttribLocation: Could not find "
		                "attribute '%s'", attrib->name);
		return false;
	}

	da_push_back(program->attribs, &attrib_obj);
	return true;
}

static inline bool assign_program_attribs(struct gs_program *program)
{
	struct gs_shader *shader = program->vertex_shader;

	for (size_t i = 0; i < shader->attribs.num; i++) {
		struct shader_attrib *attrib = shader->attribs.array + i;
		if (!assign_program_attrib(program, attrib))
			return false;
	}

	return true;
}

static bool assign_program_param(struct gs_program *program,
		struct gs_shader_param *param)
{
	struct program_param info;

	info.obj = glGetUniformLocation(program->obj, param->name);
	if (!gl_success("glGetUniformLocation"))
		return false;

	if (info.obj == -1) {
		return true;
	}

	info.param = param;
	da_push_back(program->params, &info);
	return true;
}

static inline bool assign_program_shader_params(struct gs_program *program,
		struct gs_shader *shader)
{
	for (size_t i = 0; i < shader->params.num; i++) {
		struct gs_shader_param *param = shader->params.array + i;
		if (!assign_program_param(program, param))
			return false;
	}

	return true;
}

static inline bool assign_program_params(struct gs_program *program)
{
	if (!assign_program_shader_params(program, program->vertex_shader))
		return false;
	if (!assign_program_shader_params(program, program->pixel_shader))
		return false;

	return true;
}

struct gs_program *gs_program_create(struct gs_device *device)
{
	struct gs_program *program = bzalloc(sizeof(*program));
	int linked = false;

	program->device        = device;
	program->vertex_shader = device->cur_vertex_shader;
	program->pixel_shader  = device->cur_pixel_shader;

	program->obj = glCreateProgram();
	if (!gl_success("glCreateProgram"))
		goto error_detach_neither;

	glAttachShader(program->obj, program->vertex_shader->obj);
	if (!gl_success("glAttachShader (vertex)"))
		goto error_detach_neither;

	glAttachShader(program->obj, program->pixel_shader->obj);
	if (!gl_success("glAttachShader (pixel)"))
		goto error_detach_vertex;

	glLinkProgram(program->obj);
	if (!gl_success("glLinkProgram"))
		goto error;

	glGetProgramiv(program->obj, GL_LINK_STATUS, &linked);
	if (!gl_success("glGetProgramiv"))
		goto error;

	if (linked == GL_FALSE) {
		print_link_errors(program->obj);
		goto error;
	}

	if (!assign_program_attribs(program))
		goto error;
	if (!assign_program_params(program))
		goto error;

	glDetachShader(program->obj, program->vertex_shader->obj);
	gl_success("glDetachShader (vertex)");

	glDetachShader(program->obj, program->pixel_shader->obj);
	gl_success("glDetachShader (pixel)");

	program->next = device->first_program;
	program->prev_next = &device->first_program;
	device->first_program = program;
	if (program->next)
		program->next->prev_next = &program->next;

	return program;

error:
	glDetachShader(program->obj, program->pixel_shader->obj);
	gl_success("glDetachShader (pixel)");

error_detach_vertex:
	glDetachShader(program->obj, program->vertex_shader->obj);
	gl_success("glDetachShader (vertex)");

error_detach_neither:
	gs_program_destroy(program);
	return NULL;
}

void gs_program_destroy(struct gs_program *program)
{
	if (!program)
		return;

	if (program->device->cur_program == program) {
		program->device->cur_program = 0;
		glUseProgram(0);
		gl_success("glUseProgram (zero)");
	}

	da_free(program->attribs);
	da_free(program->params);

	if (program->next)
		program->next->prev_next = program->prev_next;
	if (program->prev_next)
		*program->prev_next = program->next;

	glDeleteProgram(program->obj);
	gl_success("glDeleteProgram");

	bfree(program);
}

void gs_shader_set_val(gs_sparam_t *param, const void *val, size_t size)
{
	int count = param->array_count;
	size_t expected_size = 0;
	if (!count)
		count = 1;

	switch ((uint32_t)param->type) {
	case GS_SHADER_PARAM_FLOAT:     expected_size = sizeof(float); break;
	case GS_SHADER_PARAM_BOOL:
	case GS_SHADER_PARAM_INT:       expected_size = sizeof(int); break;
	case GS_SHADER_PARAM_VEC2:      expected_size = sizeof(float)*2; break;
	case GS_SHADER_PARAM_VEC3:      expected_size = sizeof(float)*3; break;
	case GS_SHADER_PARAM_VEC4:      expected_size = sizeof(float)*4; break;
	case GS_SHADER_PARAM_MATRIX4X4: expected_size = sizeof(float)*4*4;break;
	case GS_SHADER_PARAM_TEXTURE:   expected_size = sizeof(void*); break;
	default:                        expected_size = 0;
	}

	expected_size *= count;
	if (!expected_size)
		return;

	if (expected_size != size) {
		blog(LOG_ERROR, "gs_shader_set_val (GL): Size of shader "
		                "param does not match the size of the input");
		return;
	}

	if (param->type == GS_SHADER_PARAM_TEXTURE)
		gs_shader_set_texture(param, *(gs_texture_t**)val);
	else
		da_copy_array(param->cur_value, val, size);
}

void gs_shader_set_default(gs_sparam_t *param)
{
	gs_shader_set_val(param, param->def_value.array, param->def_value.num);
}
<code block>
#pragma once

#include "util/c99defs.h"
#include "util/darray.h"
#include "util/circlebuf.h"
#include "util/dstr.h"
#include "util/threading.h"
#include "util/platform.h"
#include "util/profiler.h"
#include "callback/signal.h"
#include "callback/proc.h"

#include "graphics/graphics.h"
#include "graphics/matrix4.h"

#include "media-io/audio-resampler.h"
#include "media-io/video-io.h"
#include "media-io/audio-io.h"

#include "obs.h"

#define NUM_TEXTURES 2
#define MICROSECOND_DEN 1000000

static inline int64_t packet_dts_usec(struct encoder_packet *packet)
{
	return packet->dts * MICROSECOND_DEN / packet->timebase_den;
}

struct tick_callback {
	void (*tick)(void *param, float seconds);
	void *param;
};

struct draw_callback {
	void (*draw)(void *param, uint32_t cx, uint32_t cy);
	void *param;
};




static inline bool obs_object_valid(const void *obj, const char *f,
		const char *t)
{
	if (!obj) {
		blog(LOG_DEBUG, "%s: Null '%s' parameter", f, t);
		return false;
	}

	return true;
}

#define obs_ptr_valid(ptr, func) obs_object_valid(ptr, func, #ptr)
#define obs_source_valid  obs_ptr_valid
#define obs_output_valid  obs_ptr_valid
#define obs_encoder_valid obs_ptr_valid
#define obs_service_valid obs_ptr_valid




struct obs_module {
	char *mod_name;
	const char *file;
	char *bin_path;
	char *data_path;
	void *module;
	bool loaded;

	bool        (*load)(void);
	void        (*unload)(void);
	void        (*post_load)(void);
	void        (*set_locale)(const char *locale);
	void        (*free_locale)(void);
	uint32_t    (*ver)(void);
	void        (*set_pointer)(obs_module_t *module);
	const char *(*name)(void);
	const char *(*description)(void);
	const char *(*author)(void);

	struct obs_module *next;
};

extern void free_module(struct obs_module *mod);

struct obs_module_path {
	char *bin;
	char *data;
};

static inline void free_module_path(struct obs_module_path *omp)
{
	if (omp) {
		bfree(omp->bin);
		bfree(omp->data);
	}
}

static inline bool check_path(const char *data, const char *path,
		struct dstr *output)
{
	dstr_copy(output, path);
	dstr_cat(output, data);

	return os_file_exists(output->array);
}





struct obs_hotkey {
	obs_hotkey_id               id;
	char                        *name;
	char                        *description;

	obs_hotkey_func             func;
	void                        *data;
	int                         pressed;

	obs_hotkey_registerer_t     registerer_type;
	void                        *registerer;

	obs_hotkey_id               pair_partner_id;
};

struct obs_hotkey_pair {
	obs_hotkey_pair_id          pair_id;
	obs_hotkey_id               id[2];
	obs_hotkey_active_func      func[2];
	bool                        pressed0;
	bool                        pressed1;
	void                        *data[2];
};

typedef struct obs_hotkey_pair obs_hotkey_pair_t;

typedef struct obs_hotkeys_platform obs_hotkeys_platform_t;

void *obs_hotkey_thread(void *param);

struct obs_core_hotkeys;
bool obs_hotkeys_platform_init(struct obs_core_hotkeys *hotkeys);
void obs_hotkeys_platform_free(struct obs_core_hotkeys *hotkeys);
bool obs_hotkeys_platform_is_pressed(obs_hotkeys_platform_t *context,
		obs_key_t key);

const char *obs_get_hotkey_translation(obs_key_t key, const char *def);

struct obs_context_data;
void obs_hotkeys_context_release(struct obs_context_data *context);

void obs_hotkeys_free(void);

struct obs_hotkey_binding {
	obs_key_combination_t       key;
	bool                        pressed;
	bool                        modifiers_match;

	obs_hotkey_id               hotkey_id;
	obs_hotkey_t                *hotkey;
};

struct obs_hotkey_name_map;
void obs_hotkey_name_map_free(void);





struct obs_view {
	pthread_mutex_t                 channels_mutex;
	obs_source_t                    *channels[MAX_CHANNELS];
};

extern bool obs_view_init(struct obs_view *view);
extern void obs_view_free(struct obs_view *view);





struct obs_display {
	bool                            size_changed;
	bool                            enabled;
	uint32_t                        cx, cy;
	uint32_t                        background_color;
	gs_swapchain_t                  *swap;
	pthread_mutex_t                 draw_callbacks_mutex;
	pthread_mutex_t                 draw_info_mutex;
	DARRAY(struct draw_callback)    draw_callbacks;

	struct obs_display              *next;
	struct obs_display              **prev_next;
};

extern bool obs_display_init(struct obs_display *display,
		const struct gs_init_data *graphics_data);
extern void obs_display_free(struct obs_display *display);





struct obs_vframe_info {
	uint64_t timestamp;
	int count;
};

struct obs_core_video {
	graphics_t                      *graphics;
	gs_stagesurf_t                  *copy_surfaces[NUM_TEXTURES];
	gs_texture_t                    *render_textures[NUM_TEXTURES];
	gs_texture_t                    *output_textures[NUM_TEXTURES];
	gs_texture_t                    *convert_textures[NUM_TEXTURES];
	bool                            textures_rendered[NUM_TEXTURES];
	bool                            textures_output[NUM_TEXTURES];
	bool                            textures_copied[NUM_TEXTURES];
	bool                            textures_converted[NUM_TEXTURES];
	struct circlebuf                vframe_info_buffer;
	gs_effect_t                     *default_effect;
	gs_effect_t                     *default_rect_effect;
	gs_effect_t                     *opaque_effect;
	gs_effect_t                     *solid_effect;
	gs_effect_t                     *conversion_effect;
	gs_effect_t                     *bicubic_effect;
	gs_effect_t                     *lanczos_effect;
	gs_effect_t                     *bilinear_lowres_effect;
	gs_effect_t                     *premultiplied_alpha_effect;
	gs_samplerstate_t               *point_sampler;
	gs_stagesurf_t                  *mapped_surface;
	int                             cur_texture;

	uint64_t                        video_time;
	uint64_t                        video_avg_frame_time_ns;
	double                          video_fps;
	video_t                         *video;
	pthread_t                       video_thread;
	uint32_t                        total_frames;
	uint32_t                        lagged_frames;
	bool                            thread_initialized;

	bool                            gpu_conversion;
	const char                      *conversion_tech;
	uint32_t                        conversion_height;
	uint32_t                        plane_offsets[3];
	uint32_t                        plane_sizes[3];
	uint32_t                        plane_linewidth[3];

	uint32_t                        output_width;
	uint32_t                        output_height;
	uint32_t                        base_width;
	uint32_t                        base_height;
	float                           color_matrix[16];
	enum obs_scale_type             scale_type;

	gs_texture_t                    *transparent_texture;

	gs_effect_t                     *deinterlace_discard_effect;
	gs_effect_t                     *deinterlace_discard_2x_effect;
	gs_effect_t                     *deinterlace_linear_effect;
	gs_effect_t                     *deinterlace_linear_2x_effect;
	gs_effect_t                     *deinterlace_blend_effect;
	gs_effect_t                     *deinterlace_blend_2x_effect;
	gs_effect_t                     *deinterlace_yadif_effect;
	gs_effect_t                     *deinterlace_yadif_2x_effect;

	struct obs_video_info           ovi;
};

struct audio_monitor;

struct obs_core_audio {
	audio_t                         *audio;

	DARRAY(struct obs_source*)      render_order;
	DARRAY(struct obs_source*)      root_nodes;

	uint64_t                        buffered_ts;
	struct circlebuf                buffered_timestamps;
	int                             buffering_wait_ticks;
	int                             total_buffering_ticks;

	float                           user_volume;

	pthread_mutex_t                 monitoring_mutex;
	DARRAY(struct audio_monitor*)   monitors;
	char                            *monitoring_device_name;
	char                            *monitoring_device_id;
};


struct obs_core_data {
	struct obs_source               *first_source;
	struct obs_source               *first_audio_source;
	struct obs_display              *first_display;
	struct obs_output               *first_output;
	struct obs_encoder              *first_encoder;
	struct obs_service              *first_service;

	pthread_mutex_t                 sources_mutex;
	pthread_mutex_t                 displays_mutex;
	pthread_mutex_t                 outputs_mutex;
	pthread_mutex_t                 encoders_mutex;
	pthread_mutex_t                 services_mutex;
	pthread_mutex_t                 audio_sources_mutex;
	pthread_mutex_t                 draw_callbacks_mutex;
	DARRAY(struct draw_callback)    draw_callbacks;
	DARRAY(struct tick_callback)    tick_callbacks;

	struct obs_view                 main_view;

	long long                       unnamed_index;

	volatile bool                   valid;
};


struct obs_core_hotkeys {
	pthread_mutex_t                 mutex;
	DARRAY(obs_hotkey_t)            hotkeys;
	obs_hotkey_id                   next_id;
	DARRAY(obs_hotkey_pair_t)       hotkey_pairs;
	obs_hotkey_pair_id              next_pair_id;

	pthread_t                       hotkey_thread;
	bool                            hotkey_thread_initialized;
	os_event_t                      *stop_event;
	bool                            thread_disable_press;
	bool                            strict_modifiers;
	bool                            reroute_hotkeys;
	DARRAY(obs_hotkey_binding_t)    bindings;

	obs_hotkey_callback_router_func router_func;
	void                            *router_func_data;

	obs_hotkeys_platform_t          *platform_context;

	pthread_once_t                  name_map_init_token;
	struct obs_hotkey_name_map      *name_map;

	signal_handler_t                *signals;

	char                            *translations[OBS_KEY_LAST_VALUE];
	char                            *mute;
	char                            *unmute;
	char                            *push_to_mute;
	char                            *push_to_talk;
	char                            *sceneitem_show;
	char                            *sceneitem_hide;
};

struct obs_core {
	struct obs_module               *first_module;
	DARRAY(struct obs_module_path)  module_paths;

	DARRAY(struct obs_source_info)  source_types;
	DARRAY(struct obs_source_info)  input_types;
	DARRAY(struct obs_source_info)  filter_types;
	DARRAY(struct obs_source_info)  transition_types;
	DARRAY(struct obs_output_info)  output_types;
	DARRAY(struct obs_encoder_info) encoder_types;
	DARRAY(struct obs_service_info) service_types;
	DARRAY(struct obs_modal_ui)     modal_ui_callbacks;
	DARRAY(struct obs_modeless_ui)  modeless_ui_callbacks;

	signal_handler_t                *signals;
	proc_handler_t                  *procs;

	char                            *locale;
	char                            *module_config_path;
	bool                            name_store_owned;
	profiler_name_store_t           *name_store;


	struct obs_core_video           video;
	struct obs_core_audio           audio;
	struct obs_core_data            data;
	struct obs_core_hotkeys         hotkeys;
};

extern struct obs_core *obs;

extern void *obs_graphics_thread(void *param);

extern gs_effect_t *obs_load_effect(gs_effect_t **effect, const char *file);

extern bool audio_callback(void *param,
		uint64_t start_ts_in, uint64_t end_ts_in, uint64_t *out_ts,
		uint32_t mixers, struct audio_output_data *mixes);





struct obs_context_data {
	char                            *name;
	void                            *data;
	obs_data_t                      *settings;
	signal_handler_t                *signals;
	proc_handler_t                  *procs;
	enum obs_obj_type               type;

	DARRAY(obs_hotkey_id)           hotkeys;
	DARRAY(obs_hotkey_pair_id)      hotkey_pairs;
	obs_data_t                      *hotkey_data;

	DARRAY(char*)                   rename_cache;
	pthread_mutex_t                 rename_cache_mutex;

	pthread_mutex_t                 *mutex;
	struct obs_context_data         *next;
	struct obs_context_data         **prev_next;

	bool                            private;
};

extern bool obs_context_data_init(
		struct obs_context_data *context,
		enum obs_obj_type       type,
		obs_data_t              *settings,
		const char              *name,
		obs_data_t              *hotkey_data,
		bool                    private);
extern void obs_context_data_free(struct obs_context_data *context);

extern void obs_context_data_insert(struct obs_context_data *context,
		pthread_mutex_t *mutex, void *first);
extern void obs_context_data_remove(struct obs_context_data *context);

extern void obs_context_data_setname(struct obs_context_data *context,
		const char *name);





struct obs_weak_ref {
	volatile long refs;
	volatile long weak_refs;
};

static inline void obs_ref_addref(struct obs_weak_ref *ref)
{
	os_atomic_inc_long(&ref->refs);
}

static inline bool obs_ref_release(struct obs_weak_ref *ref)
{
	return os_atomic_dec_long(&ref->refs) == -1;
}

static inline void obs_weak_ref_addref(struct obs_weak_ref *ref)
{
	os_atomic_inc_long(&ref->weak_refs);
}

static inline bool obs_weak_ref_release(struct obs_weak_ref *ref)
{
	return os_atomic_dec_long(&ref->weak_refs) == -1;
}

static inline bool obs_weak_ref_get_ref(struct obs_weak_ref *ref)
{
	long owners = ref->refs;
	while (owners > -1) {
		if (os_atomic_compare_swap_long(&ref->refs, owners, owners + 1))
			return true;

		owners = ref->refs;
	}

	return false;
}





struct async_frame {
	struct obs_source_frame *frame;
	long unused_count;
	bool used;
};

enum audio_action_type {
	AUDIO_ACTION_VOL,
	AUDIO_ACTION_MUTE,
	AUDIO_ACTION_PTT,
	AUDIO_ACTION_PTM,
};

struct audio_action {
	uint64_t timestamp;
	enum audio_action_type type;
	union {
		float vol;
		bool  set;
	};
};

struct obs_weak_source {
	struct obs_weak_ref ref;
	struct obs_source *source;
};

struct audio_cb_info {
	obs_source_audio_capture_t callback;
	void *param;
};

struct obs_source {
	struct obs_context_data         context;
	struct obs_source_info          info;
	struct obs_weak_source          *control;


	uint32_t                        flags;
	uint32_t                        default_flags;


	bool                            owns_info_id;


	bool                            defer_update;


	volatile long                   show_refs;


	volatile long                   activate_refs;


	bool                            removed;

	bool                            active;
	bool                            showing;


	bool                            enabled;


	volatile bool                   timing_set;
	volatile uint64_t               timing_adjust;
	uint64_t                        resample_offset;
	uint64_t                        last_audio_ts;
	uint64_t                        next_audio_ts_min;
	uint64_t                        next_audio_sys_ts_min;
	uint64_t                        last_frame_ts;
	uint64_t                        last_sys_timestamp;
	bool                            async_rendered;


	bool                            audio_failed;
	bool                            audio_pending;
	bool                            pending_stop;
	bool                            user_muted;
	bool                            muted;
	struct obs_source               *next_audio_source;
	struct obs_source               **prev_next_audio_source;
	uint64_t                        audio_ts;
	struct circlebuf                audio_input_buf[MAX_AUDIO_CHANNELS];
	size_t                          last_audio_input_buf_size;
	DARRAY(struct audio_action)     audio_actions;
	float                           *audio_output_buf[MAX_AUDIO_MIXES][MAX_AUDIO_CHANNELS];
	struct resample_info            sample_info;
	audio_resampler_t               *resampler;
	pthread_mutex_t                 audio_actions_mutex;
	pthread_mutex_t                 audio_buf_mutex;
	pthread_mutex_t                 audio_mutex;
	pthread_mutex_t                 audio_cb_mutex;
	DARRAY(struct audio_cb_info)    audio_cb_list;
	struct obs_audio_data           audio_data;
	size_t                          audio_storage_size;
	uint32_t                        audio_mixers;
	float                           user_volume;
	float                           volume;
	int64_t                         sync_offset;
	int64_t                         last_sync_offset;


	gs_texture_t                    *async_texture;
	gs_texrender_t                  *async_texrender;
	struct obs_source_frame         *cur_async_frame;
	bool                            async_gpu_conversion;
	enum video_format               async_format;
	enum video_format               async_cache_format;
	enum gs_color_format            async_texture_format;
	float                           async_color_matrix[16];
	bool                            async_full_range;
	float                           async_color_range_min[3];
	float                           async_color_range_max[3];
	int                             async_plane_offset[2];
	bool                            async_flip;
	bool                            async_active;
	bool                            async_update_texture;
	bool                            async_unbuffered;
	bool                            async_decoupled;
	struct obs_source_frame         *async_preload_frame;
	DARRAY(struct async_frame)      async_cache;
	DARRAY(struct obs_source_frame*)async_frames;
	pthread_mutex_t                 async_mutex;
	uint32_t                        async_width;
	uint32_t                        async_height;
	uint32_t                        async_cache_width;
	uint32_t                        async_cache_height;
	uint32_t                        async_convert_width;
	uint32_t                        async_convert_height;


	uint64_t                        deinterlace_offset;
	uint64_t                        deinterlace_frame_ts;
	gs_effect_t                     *deinterlace_effect;
	struct obs_source_frame         *prev_async_frame;
	gs_texture_t                    *async_prev_texture;
	gs_texrender_t                  *async_prev_texrender;
	uint32_t                        deinterlace_half_duration;
	enum obs_deinterlace_mode       deinterlace_mode;
	bool                            deinterlace_top_first;
	bool                            deinterlace_rendered;


	struct obs_source               *filter_parent;
	struct obs_source               *filter_target;
	DARRAY(struct obs_source*)      filters;
	pthread_mutex_t                 filter_mutex;
	gs_texrender_t                  *filter_texrender;
	enum obs_allow_direct_render    allow_direct;
	bool                            rendering_filter;


	obs_hotkey_pair_id              mute_unmute_key;
	obs_hotkey_id                   push_to_mute_key;
	obs_hotkey_id                   push_to_talk_key;
	bool                            push_to_mute_enabled;
	bool                            push_to_mute_pressed;
	bool                            user_push_to_mute_pressed;
	bool                            push_to_talk_enabled;
	bool                            push_to_talk_pressed;
	bool                            user_push_to_talk_pressed;
	uint64_t                        push_to_mute_delay;
	uint64_t                        push_to_mute_stop_time;
	uint64_t                        push_to_talk_delay;
	uint64_t                        push_to_talk_stop_time;


	uint64_t                        transition_start_time;
	uint64_t                        transition_duration;
	pthread_mutex_t                 transition_tex_mutex;
	gs_texrender_t                  *transition_texrender[2];
	pthread_mutex_t                 transition_mutex;
	obs_source_t                    *transition_sources[2];
	bool                            transitioning_video;
	bool                            transitioning_audio;
	bool                            transition_source_active[2];
	uint32_t                        transition_alignment;
	uint32_t                        transition_actual_cx;
	uint32_t                        transition_actual_cy;
	uint32_t                        transition_cx;
	uint32_t                        transition_cy;
	uint32_t                        transition_fixed_duration;
	bool                            transition_use_fixed_duration;
	enum obs_transition_mode        transition_mode;
	enum obs_transition_scale_type  transition_scale_type;
	struct matrix4                  transition_matrices[2];

	struct audio_monitor            *monitor;
	enum obs_monitoring_type        monitoring_type;

	obs_data_t                      *private_settings;
};

extern struct obs_source_info *get_source_info(const char *id);
extern bool obs_source_init_context(struct obs_source *source,
		obs_data_t *settings, const char *name,
		obs_data_t *hotkey_data, bool private);

extern bool obs_transition_init(obs_source_t *transition);
extern void obs_transition_free(obs_source_t *transition);
extern void obs_transition_tick(obs_source_t *transition);
extern void obs_transition_enum_sources(obs_source_t *transition,
		obs_source_enum_proc_t enum_callback, void *param);
extern void obs_transition_save(obs_source_t *source, obs_data_t *data);
extern void obs_transition_load(obs_source_t *source, obs_data_t *data);

struct audio_monitor *audio_monitor_create(obs_source_t *source);
void audio_monitor_reset(struct audio_monitor *monitor);
extern void audio_monitor_destroy(struct audio_monitor *monitor);

extern void obs_source_destroy(struct obs_source *source);

enum view_type {
	MAIN_VIEW,
	AUX_VIEW
};

static inline void obs_source_dosignal(struct obs_source *source,
		const char *signal_obs, const char *signal_source)
{
	struct calldata data;
	uint8_t stack[128];

	calldata_init_fixed(&data, stack, sizeof(stack));
	calldata_set_ptr(&data, "source", source);
	if (signal_obs && !source->context.private)
		signal_handler_signal(obs->signals, signal_obs, &data);
	if (signal_source)
		signal_handler_signal(source->context.signals, signal_source,
				&data);
}


#define MAX_TS_VAR          2000000000ULL

static inline bool frame_out_of_bounds(const obs_source_t *source, uint64_t ts)
{
	if (ts < source->last_frame_ts)
		return ((source->last_frame_ts - ts) > MAX_TS_VAR);
	else
		return ((ts - source->last_frame_ts) > MAX_TS_VAR);
}

static inline enum gs_color_format convert_video_format(
		enum video_format format)
{
	if (format == VIDEO_FORMAT_RGBA)
		return GS_RGBA;
	else if (format == VIDEO_FORMAT_BGRA)
		return GS_BGRA;

	return GS_BGRX;
}

extern void obs_source_activate(obs_source_t *source, enum view_type type);
extern void obs_source_deactivate(obs_source_t *source, enum view_type type);
extern void obs_source_video_tick(obs_source_t *source, float seconds);
extern float obs_source_get_target_volume(obs_source_t *source,
		obs_source_t *target);

extern void obs_source_audio_render(obs_source_t *source, uint32_t mixers,
		size_t channels, size_t sample_rate, size_t size);

extern void add_alignment(struct vec2 *v, uint32_t align, int cx, int cy);

extern struct obs_source_frame *filter_async_video(obs_source_t *source,
		struct obs_source_frame *in);
extern bool update_async_texture(struct obs_source *source,
		const struct obs_source_frame *frame,
		gs_texture_t *tex, gs_texrender_t *texrender);
extern bool set_async_texture_size(struct obs_source *source,
		const struct obs_source_frame *frame);
extern void remove_async_frame(obs_source_t *source,
		struct obs_source_frame *frame);

extern void set_deinterlace_texture_size(obs_source_t *source);
extern void deinterlace_process_last_frame(obs_source_t *source,
		uint64_t sys_time);
extern void deinterlace_update_async_video(obs_source_t *source);
extern void deinterlace_render(obs_source_t *s);





enum delay_msg {
	DELAY_MSG_PACKET,
	DELAY_MSG_START,
	DELAY_MSG_STOP,
};

struct delay_data {
	enum delay_msg msg;
	uint64_t ts;
	struct encoder_packet packet;
};

typedef void (*encoded_callback_t)(void *data, struct encoder_packet *packet);

struct obs_weak_output {
	struct obs_weak_ref ref;
	struct obs_output *output;
};

#define CAPTION_LINE_CHARS (32)
#define CAPTION_LINE_BYTES (4*CAPTION_LINE_CHARS)
struct caption_text {
	char text[CAPTION_LINE_BYTES+1];
	struct caption_text *next;
};

struct obs_output {
	struct obs_context_data         context;
	struct obs_output_info          info;
	struct obs_weak_output          *control;


	bool                            owns_info_id;

	bool                            received_video;
	bool                            received_audio;
	volatile bool                   data_active;
	volatile bool                   end_data_capture_thread_active;
	int64_t                         video_offset;
	int64_t                         audio_offsets[MAX_AUDIO_MIXES];
	int64_t                         highest_audio_ts;
	int64_t                         highest_video_ts;
	pthread_t                       end_data_capture_thread;
	os_event_t                      *stopping_event;
	pthread_mutex_t                 interleaved_mutex;
	DARRAY(struct encoder_packet)   interleaved_packets;
	int                             stop_code;

	int                             reconnect_retry_sec;
	int                             reconnect_retry_max;
	int                             reconnect_retries;
	int                             reconnect_retry_cur_sec;
	pthread_t                       reconnect_thread;
	os_event_t                      *reconnect_stop_event;
	volatile bool                   reconnecting;
	volatile bool                   reconnect_thread_active;

	uint32_t                        starting_drawn_count;
	uint32_t                        starting_lagged_count;
	uint32_t                        starting_frame_count;

	int                             total_frames;

	volatile bool                   active;
	video_t                         *video;
	audio_t                         *audio;
	obs_encoder_t                   *video_encoder;
	obs_encoder_t                   *audio_encoders[MAX_AUDIO_MIXES];
	obs_service_t                   *service;
	size_t                          mixer_idx;

	uint32_t                        scaled_width;
	uint32_t                        scaled_height;

	bool                            video_conversion_set;
	bool                            audio_conversion_set;
	struct video_scale_info         video_conversion;
	struct audio_convert_info       audio_conversion;

	pthread_mutex_t                 caption_mutex;
	double                          caption_timestamp;
	struct caption_text             *caption_head;
	struct caption_text             *caption_tail;

	bool                            valid;

	uint64_t                        active_delay_ns;
	encoded_callback_t              delay_callback;
	struct circlebuf                delay_data; 
	pthread_mutex_t                 delay_mutex;
	uint32_t                        delay_sec;
	uint32_t                        delay_flags;
	uint32_t                        delay_cur_flags;
	volatile long                   delay_restart_refs;
	volatile bool                   delay_active;
	volatile bool                   delay_capturing;

	char                            *last_error_message;
};

static inline void do_output_signal(struct obs_output *output,
		const char *signal)
{
	struct calldata params = {0};
	calldata_set_ptr(&params, "output", output);
	signal_handler_signal(output->context.signals, signal, &params);
	calldata_free(&params);
}

extern void process_delay(void *data, struct encoder_packet *packet);
extern void obs_output_cleanup_delay(obs_output_t *output);
extern bool obs_output_delay_start(obs_output_t *output);
extern void obs_output_delay_stop(obs_output_t *output);
extern bool obs_output_actual_start(obs_output_t *output);
extern void obs_output_actual_stop(obs_output_t *output, bool force,
		uint64_t ts);

extern const struct obs_output_info *find_output(const char *id);

extern void obs_output_remove_encoder(struct obs_output *output,
		struct obs_encoder *encoder);

extern void obs_encoder_packet_create_instance(struct encoder_packet *dst,
		const struct encoder_packet *src);
void obs_output_destroy(obs_output_t *output);





struct obs_weak_encoder {
	struct obs_weak_ref ref;
	struct obs_encoder *encoder;
};

struct encoder_callback {
	bool sent_first_packet;
	void (*new_packet)(void *param, struct encoder_packet *packet);
	void *param;
};

struct obs_encoder {
	struct obs_context_data         context;
	struct obs_encoder_info         info;
	struct obs_weak_encoder         *control;

	pthread_mutex_t                 init_mutex;

	uint32_t                        samplerate;
	size_t                          planes;
	size_t                          blocksize;
	size_t                          framesize;
	size_t                          framesize_bytes;

	size_t                          mixer_idx;

	uint32_t                        scaled_width;
	uint32_t                        scaled_height;
	enum video_format               preferred_format;

	volatile bool                   active;
	bool                            initialized;


	bool                            owns_info_id;

	uint32_t                        timebase_num;
	uint32_t                        timebase_den;

	int64_t                         cur_pts;

	struct circlebuf                audio_input_buffer[MAX_AV_PLANES];
	uint8_t                         *audio_output_buffer[MAX_AV_PLANES];


	bool                            wait_for_video;
	bool                            first_received;
	struct obs_encoder              *paired_encoder;
	int64_t                         offset_usec;
	uint64_t                        first_raw_ts;
	uint64_t                        start_ts;

	pthread_mutex_t                 outputs_mutex;
	DARRAY(obs_output_t*)            outputs;

	bool                            destroy_on_stop;


	void                            *media;

	pthread_mutex_t                 callbacks_mutex;
	DARRAY(struct encoder_callback) callbacks;

	const char                      *profile_encoder_encode_name;
};

extern struct obs_encoder_info *find_encoder(const char *id);

extern bool obs_encoder_initialize(obs_encoder_t *encoder);
extern void obs_encoder_shutdown(obs_encoder_t *encoder);

extern void obs_encoder_start(obs_encoder_t *encoder,
		void (*new_packet)(void *param, struct encoder_packet *packet),
		void *param);
extern void obs_encoder_stop(obs_encoder_t *encoder,
		void (*new_packet)(void *param, struct encoder_packet *packet),
		void *param);

extern void obs_encoder_add_output(struct obs_encoder *encoder,
		struct obs_output *output);
extern void obs_encoder_remove_output(struct obs_encoder *encoder,
		struct obs_output *output);

void obs_encoder_destroy(obs_encoder_t *encoder);




struct obs_weak_service {
	struct obs_weak_ref ref;
	struct obs_service *service;
};

struct obs_service {
	struct obs_context_data         context;
	struct obs_service_info         info;
	struct obs_weak_service         *control;


	bool                            owns_info_id;

	bool                            active;
	bool                            destroy;
	struct obs_output               *output;
};

extern const struct obs_service_info *find_service(const char *id);

extern void obs_service_activate(struct obs_service *service);
extern void obs_service_deactivate(struct obs_service *service, bool remove);
extern bool obs_service_initialize(struct obs_service *service,
		struct obs_output *output);

void obs_service_destroy(obs_service_t *service);
<code block>
#pragma once

#include "util/c99defs.h"
#include "util/bmem.h"
#include "util/profiler.h"
#include "util/text-lookup.h"
#include "graphics/graphics.h"
#include "graphics/vec2.h"
#include "graphics/vec3.h"
#include "media-io/audio-io.h"
#include "media-io/video-io.h"
#include "callback/signal.h"
#include "callback/proc.h"

#include "obs-config.h"
#include "obs-defs.h"
#include "obs-data.h"
#include "obs-ui.h"
#include "obs-properties.h"
#include "obs-interaction.h"

struct matrix4;


struct obs_display;
struct obs_view;
struct obs_source;
struct obs_scene;
struct obs_scene_item;
struct obs_output;
struct obs_encoder;
struct obs_service;
struct obs_module;
struct obs_fader;
struct obs_volmeter;

typedef struct obs_display    obs_display_t;
typedef struct obs_view       obs_view_t;
typedef struct obs_source     obs_source_t;
typedef struct obs_scene      obs_scene_t;
typedef struct obs_scene_item obs_sceneitem_t;
typedef struct obs_output     obs_output_t;
typedef struct obs_encoder    obs_encoder_t;
typedef struct obs_service    obs_service_t;
typedef struct obs_module     obs_module_t;
typedef struct obs_fader      obs_fader_t;
typedef struct obs_volmeter   obs_volmeter_t;

typedef struct obs_weak_source  obs_weak_source_t;
typedef struct obs_weak_output  obs_weak_output_t;
typedef struct obs_weak_encoder obs_weak_encoder_t;
typedef struct obs_weak_service obs_weak_service_t;

#include "obs-source.h"
#include "obs-encoder.h"
#include "obs-output.h"
#include "obs-service.h"
#include "obs-audio-controls.h"
#include "obs-hotkey.h"



#ifdef __cplusplus
extern "C" {
#endif


enum obs_order_movement {
	OBS_ORDER_MOVE_UP,
	OBS_ORDER_MOVE_DOWN,
	OBS_ORDER_MOVE_TOP,
	OBS_ORDER_MOVE_BOTTOM
};


enum obs_allow_direct_render {
	OBS_NO_DIRECT_RENDERING,
	OBS_ALLOW_DIRECT_RENDERING,
};

enum obs_scale_type {
	OBS_SCALE_DISABLE,
	OBS_SCALE_POINT,
	OBS_SCALE_BICUBIC,
	OBS_SCALE_BILINEAR,
	OBS_SCALE_LANCZOS
};


enum obs_bounds_type {
	OBS_BOUNDS_NONE,            
	OBS_BOUNDS_STRETCH,         
	OBS_BOUNDS_SCALE_INNER,     
	OBS_BOUNDS_SCALE_OUTER,     
	OBS_BOUNDS_SCALE_TO_WIDTH,  
	OBS_BOUNDS_SCALE_TO_HEIGHT, 
	OBS_BOUNDS_MAX_ONLY,        
};

struct obs_transform_info {
	struct vec2          pos;
	float                rot;
	struct vec2          scale;
	uint32_t             alignment;

	enum obs_bounds_type bounds_type;
	uint32_t             bounds_alignment;
	struct vec2          bounds;
};


struct obs_video_info {
#ifndef SWIG

	const char          *graphics_module;
#endif

	uint32_t            fps_num;       
	uint32_t            fps_den;       

	uint32_t            base_width;    
	uint32_t            base_height;   

	uint32_t            output_width;  
	uint32_t            output_height; 
	enum video_format   output_format; 


	uint32_t            adapter;


	bool                gpu_conversion;

	enum video_colorspace colorspace;  
	enum video_range_type range;       

	enum obs_scale_type scale_type;    
};


struct obs_audio_info {
	uint32_t            samples_per_sec;
	enum speaker_layout speakers;
};


struct obs_audio_data {
	uint8_t             *data[MAX_AV_PLANES];
	uint32_t            frames;
	uint64_t            timestamp;
};


struct obs_source_audio {
	const uint8_t       *data[MAX_AV_PLANES];
	uint32_t            frames;

	enum speaker_layout speakers;
	enum audio_format   format;
	uint32_t            samples_per_sec;

	uint64_t            timestamp;
};


struct obs_source_frame {
	uint8_t             *data[MAX_AV_PLANES];
	uint32_t            linesize[MAX_AV_PLANES];
	uint32_t            width;
	uint32_t            height;
	uint64_t            timestamp;

	enum video_format   format;
	float               color_matrix[16];
	bool                full_range;
	float               color_range_min[3];
	float               color_range_max[3];
	bool                flip;


	volatile long       refs;
	bool                prev_frame;
};





EXPORT bool obs_startup(const char *locale, const char *module_config_path,
		profiler_name_store_t *store);


EXPORT void obs_shutdown(void);


EXPORT bool obs_initialized(void);


EXPORT uint32_t obs_get_version(void);


EXPORT const char *obs_get_version_string(void);


EXPORT void obs_set_locale(const char *locale);


EXPORT const char *obs_get_locale(void);


EXPORT profiler_name_store_t *obs_get_profiler_name_store(void);


EXPORT int obs_reset_video(struct obs_video_info *ovi);


EXPORT bool obs_reset_audio(const struct obs_audio_info *oai);


EXPORT bool obs_get_video_info(struct obs_video_info *ovi);


EXPORT bool obs_get_audio_info(struct obs_audio_info *oai);


EXPORT int obs_open_module(obs_module_t **module, const char *path,
		const char *data_path);


EXPORT bool obs_init_module(obs_module_t *module);


EXPORT void obs_log_loaded_modules(void);


EXPORT const char *obs_get_module_file_name(obs_module_t *module);


EXPORT const char *obs_get_module_name(obs_module_t *module);


EXPORT const char *obs_get_module_author(obs_module_t *module);


EXPORT const char *obs_get_module_description(obs_module_t *module);


EXPORT const char *obs_get_module_binary_path(obs_module_t *module);


EXPORT const char *obs_get_module_data_path(obs_module_t *module);


EXPORT void obs_add_module_path(const char *bin, const char *data);


EXPORT void obs_load_all_modules(void);


EXPORT void obs_post_load_modules(void);

#ifndef SWIG
struct obs_module_info {
	const char *bin_path;
	const char *data_path;
};

typedef void (*obs_find_module_callback_t)(void *param,
		const struct obs_module_info *info);


EXPORT void obs_find_modules(obs_find_module_callback_t callback, void *param);
#endif

typedef void (*obs_enum_module_callback_t)(void *param, obs_module_t *module);


EXPORT void obs_enum_modules(obs_enum_module_callback_t callback, void *param);


EXPORT lookup_t *obs_module_load_locale(obs_module_t *module,
		const char *default_locale, const char *locale);


EXPORT char *obs_find_module_file(obs_module_t *module, const char *file);


EXPORT char *obs_module_get_config_path(obs_module_t *module, const char *file);


EXPORT bool obs_enum_source_types(size_t idx, const char **id);


EXPORT bool obs_enum_input_types(size_t idx, const char **id);


EXPORT bool obs_enum_filter_types(size_t idx, const char **id);


EXPORT bool obs_enum_transition_types(size_t idx, const char **id);


EXPORT bool obs_enum_output_types(size_t idx, const char **id);


EXPORT bool obs_enum_encoder_types(size_t idx, const char **id);


EXPORT bool obs_enum_service_types(size_t idx, const char **id);


EXPORT void obs_enter_graphics(void);


EXPORT void obs_leave_graphics(void);


EXPORT audio_t *obs_get_audio(void);


EXPORT video_t *obs_get_video(void);


EXPORT void obs_set_output_source(uint32_t channel, obs_source_t *source);


EXPORT obs_source_t *obs_get_output_source(uint32_t channel);


EXPORT void obs_enum_sources(bool (*enum_proc)(void*, obs_source_t*),
		void *param);


EXPORT void obs_enum_outputs(bool (*enum_proc)(void*, obs_output_t*),
		void *param);


EXPORT void obs_enum_encoders(bool (*enum_proc)(void*, obs_encoder_t*),
		void *param);


EXPORT void obs_enum_services(bool (*enum_proc)(void*, obs_service_t*),
		void *param);


EXPORT obs_source_t *obs_get_source_by_name(const char *name);


EXPORT obs_output_t *obs_get_output_by_name(const char *name);


EXPORT obs_encoder_t *obs_get_encoder_by_name(const char *name);


EXPORT obs_service_t *obs_get_service_by_name(const char *name);

enum obs_base_effect {
	OBS_EFFECT_DEFAULT,            
	OBS_EFFECT_DEFAULT_RECT,       
	OBS_EFFECT_OPAQUE,             
	OBS_EFFECT_SOLID,              
	OBS_EFFECT_BICUBIC,            
	OBS_EFFECT_LANCZOS,            
	OBS_EFFECT_BILINEAR_LOWRES,    
	OBS_EFFECT_PREMULTIPLIED_ALPHA,
};


EXPORT gs_effect_t *obs_get_base_effect(enum obs_base_effect effect);

#ifndef SWIG

DEPRECATED
EXPORT gs_effect_t *obs_get_default_rect_effect(void);
#endif


EXPORT signal_handler_t *obs_get_signal_handler(void);


EXPORT proc_handler_t *obs_get_proc_handler(void);

#ifndef SWIG

DEPRECATED
EXPORT void obs_render_main_view(void);
#endif


EXPORT void obs_render_main_texture(void);


EXPORT void obs_set_master_volume(float volume);


EXPORT float obs_get_master_volume(void);


EXPORT obs_data_t *obs_save_source(obs_source_t *source);


EXPORT obs_source_t *obs_load_source(obs_data_t *data);


EXPORT void obs_source_save(obs_source_t *source);


EXPORT void obs_source_load(obs_source_t *source);

typedef void (*obs_load_source_cb)(void *private_data, obs_source_t *source);


EXPORT void obs_load_sources(obs_data_array_t *array, obs_load_source_cb cb,
		void *private_data);


EXPORT obs_data_array_t *obs_save_sources(void);

typedef bool (*obs_save_source_filter_cb)(void *data, obs_source_t *source);
EXPORT obs_data_array_t *obs_save_sources_filtered(obs_save_source_filter_cb cb,
		void *data);

enum obs_obj_type {
	OBS_OBJ_TYPE_INVALID,
	OBS_OBJ_TYPE_SOURCE,
	OBS_OBJ_TYPE_OUTPUT,
	OBS_OBJ_TYPE_ENCODER,
	OBS_OBJ_TYPE_SERVICE
};

EXPORT enum obs_obj_type obs_obj_get_type(void *obj);
EXPORT const char *obs_obj_get_id(void *obj);
EXPORT bool obs_obj_invalid(void *obj);

typedef bool (*obs_enum_audio_device_cb)(void *data, const char *name,
		const char *id);

EXPORT void obs_enum_audio_monitoring_devices(obs_enum_audio_device_cb cb,
		void *data);

EXPORT bool obs_set_audio_monitoring_device(const char *name, const char *id);
EXPORT void obs_get_audio_monitoring_device(const char **name, const char **id);

EXPORT void obs_add_tick_callback(
		void (*tick)(void *param, float seconds),
		void *param);
EXPORT void obs_remove_tick_callback(
		void (*tick)(void *param, float seconds),
		void *param);

EXPORT void obs_add_main_render_callback(
		void (*draw)(void *param, uint32_t cx, uint32_t cy),
		void *param);
EXPORT void obs_remove_main_render_callback(
		void (*draw)(void *param, uint32_t cx, uint32_t cy),
		void *param);






EXPORT obs_view_t *obs_view_create(void);


EXPORT void obs_view_destroy(obs_view_t *view);


EXPORT void obs_view_set_source(obs_view_t *view, uint32_t channel,
		obs_source_t *source);


EXPORT obs_source_t *obs_view_get_source(obs_view_t *view,
		uint32_t channel);


EXPORT void obs_view_render(obs_view_t *view);

EXPORT uint64_t obs_get_video_frame_time(void);

EXPORT double obs_get_active_fps(void);
EXPORT uint64_t obs_get_average_frame_time_ns(void);

EXPORT uint32_t obs_get_total_frames(void);
EXPORT uint32_t obs_get_lagged_frames(void);






EXPORT obs_display_t *obs_display_create(
		const struct gs_init_data *graphics_data);


EXPORT void obs_display_destroy(obs_display_t *display);


EXPORT void obs_display_resize(obs_display_t *display, uint32_t cx,
		uint32_t cy);


EXPORT void obs_display_add_draw_callback(obs_display_t *display,
		void (*draw)(void *param, uint32_t cx, uint32_t cy),
		void *param);


EXPORT void obs_display_remove_draw_callback(obs_display_t *display,
		void (*draw)(void *param, uint32_t cx, uint32_t cy),
		void *param);

EXPORT void obs_display_set_enabled(obs_display_t *display, bool enable);
EXPORT bool obs_display_enabled(obs_display_t *display);

EXPORT void obs_display_set_background_color(obs_display_t *display,
		uint32_t color);






EXPORT const char *obs_source_get_display_name(const char *id);


EXPORT obs_source_t *obs_source_create(const char *id, const char *name,
		obs_data_t *settings, obs_data_t *hotkey_data);

EXPORT obs_source_t *obs_source_create_private(const char *id,
		const char *name, obs_data_t *settings);


EXPORT obs_source_t *obs_source_duplicate(obs_source_t *source,
		const char *desired_name, bool create_private);

EXPORT void obs_source_addref(obs_source_t *source);
EXPORT void obs_source_release(obs_source_t *source);

EXPORT void obs_weak_source_addref(obs_weak_source_t *weak);
EXPORT void obs_weak_source_release(obs_weak_source_t *weak);

EXPORT obs_source_t *obs_source_get_ref(obs_source_t *source);
EXPORT obs_weak_source_t *obs_source_get_weak_source(obs_source_t *source);
EXPORT obs_source_t *obs_weak_source_get_source(obs_weak_source_t *weak);

EXPORT bool obs_weak_source_references_source(obs_weak_source_t *weak,
		obs_source_t *source);


EXPORT void obs_source_remove(obs_source_t *source);


EXPORT bool obs_source_removed(const obs_source_t *source);


EXPORT uint32_t obs_source_get_output_flags(const obs_source_t *source);


EXPORT uint32_t obs_get_source_output_flags(const char *id);


EXPORT obs_data_t *obs_get_source_defaults(const char *id);


EXPORT obs_properties_t *obs_get_source_properties(const char *id);


EXPORT bool obs_is_source_configurable(const char *id);

EXPORT bool obs_source_configurable(const obs_source_t *source);


EXPORT obs_properties_t *obs_source_properties(const obs_source_t *source);


EXPORT void obs_source_update(obs_source_t *source, obs_data_t *settings);


EXPORT void obs_source_video_render(obs_source_t *source);


EXPORT uint32_t obs_source_get_width(obs_source_t *source);


EXPORT uint32_t obs_source_get_height(obs_source_t *source);


EXPORT obs_source_t *obs_filter_get_parent(const obs_source_t *filter);


EXPORT obs_source_t *obs_filter_get_target(const obs_source_t *filter);


EXPORT void obs_source_default_render(obs_source_t *source);


EXPORT void obs_source_filter_add(obs_source_t *source, obs_source_t *filter);


EXPORT void obs_source_filter_remove(obs_source_t *source,
		obs_source_t *filter);


EXPORT void obs_source_filter_set_order(obs_source_t *source,
		obs_source_t *filter, enum obs_order_movement movement);


EXPORT obs_data_t *obs_source_get_settings(const obs_source_t *source);


EXPORT const char *obs_source_get_name(const obs_source_t *source);


EXPORT void obs_source_set_name(obs_source_t *source, const char *name);


EXPORT enum obs_source_type obs_source_get_type(const obs_source_t *source);


EXPORT const char *obs_source_get_id(const obs_source_t *source);


EXPORT signal_handler_t *obs_source_get_signal_handler(
		const obs_source_t *source);


EXPORT proc_handler_t *obs_source_get_proc_handler(const obs_source_t *source);


EXPORT void obs_source_set_volume(obs_source_t *source, float volume);


EXPORT float obs_source_get_volume(const obs_source_t *source);


EXPORT void obs_source_set_sync_offset(obs_source_t *source, int64_t offset);


EXPORT int64_t obs_source_get_sync_offset(const obs_source_t *source);


EXPORT void obs_source_enum_active_sources(obs_source_t *source,
		obs_source_enum_proc_t enum_callback,
		void *param);


EXPORT void obs_source_enum_active_tree(obs_source_t *source,
		obs_source_enum_proc_t enum_callback,
		void *param);


EXPORT bool obs_source_active(const obs_source_t *source);


EXPORT bool obs_source_showing(const obs_source_t *source);


#define OBS_SOURCE_FLAG_UNUSED_1               (1<<0)

#define OBS_SOURCE_FLAG_FORCE_MONO             (1<<1)


EXPORT void obs_source_set_flags(obs_source_t *source, uint32_t flags);


EXPORT uint32_t obs_source_get_flags(const obs_source_t *source);


EXPORT void obs_source_set_audio_mixers(obs_source_t *source, uint32_t mixers);


EXPORT uint32_t obs_source_get_audio_mixers(const obs_source_t *source);


EXPORT void obs_source_inc_showing(obs_source_t *source);


EXPORT void obs_source_dec_showing(obs_source_t *source);


EXPORT void obs_source_enum_filters(obs_source_t *source,
		obs_source_enum_proc_t callback, void *param);


EXPORT obs_source_t *obs_source_get_filter_by_name(obs_source_t *source,
		const char *name);

EXPORT void obs_source_copy_filters(obs_source_t *dst, obs_source_t *src);

EXPORT bool obs_source_enabled(const obs_source_t *source);
EXPORT void obs_source_set_enabled(obs_source_t *source, bool enabled);

EXPORT bool obs_source_muted(const obs_source_t *source);
EXPORT void obs_source_set_muted(obs_source_t *source, bool muted);

EXPORT bool obs_source_push_to_mute_enabled(obs_source_t *source);
EXPORT void obs_source_enable_push_to_mute(obs_source_t *source, bool enabled);

EXPORT uint64_t obs_source_get_push_to_mute_delay(obs_source_t *source);
EXPORT void obs_source_set_push_to_mute_delay(obs_source_t *source,
		uint64_t delay);

EXPORT bool obs_source_push_to_talk_enabled(obs_source_t *source);
EXPORT void obs_source_enable_push_to_talk(obs_source_t *source, bool enabled);

EXPORT uint64_t obs_source_get_push_to_talk_delay(obs_source_t *source);
EXPORT void obs_source_set_push_to_talk_delay(obs_source_t *source,
		uint64_t delay);

typedef void (*obs_source_audio_capture_t)(void *param, obs_source_t *source,
		const struct audio_data *audio_data, bool muted);

EXPORT void obs_source_add_audio_capture_callback(obs_source_t *source,
		obs_source_audio_capture_t callback, void *param);
EXPORT void obs_source_remove_audio_capture_callback(obs_source_t *source,
		obs_source_audio_capture_t callback, void *param);

enum obs_deinterlace_mode {
	OBS_DEINTERLACE_MODE_DISABLE,
	OBS_DEINTERLACE_MODE_DISCARD,
	OBS_DEINTERLACE_MODE_RETRO,
	OBS_DEINTERLACE_MODE_BLEND,
	OBS_DEINTERLACE_MODE_BLEND_2X,
	OBS_DEINTERLACE_MODE_LINEAR,
	OBS_DEINTERLACE_MODE_LINEAR_2X,
	OBS_DEINTERLACE_MODE_YADIF,
	OBS_DEINTERLACE_MODE_YADIF_2X
};

enum obs_deinterlace_field_order {
	OBS_DEINTERLACE_FIELD_ORDER_TOP,
	OBS_DEINTERLACE_FIELD_ORDER_BOTTOM
};

EXPORT void obs_source_set_deinterlace_mode(obs_source_t *source,
		enum obs_deinterlace_mode mode);
EXPORT enum obs_deinterlace_mode obs_source_get_deinterlace_mode(
		const obs_source_t *source);
EXPORT void obs_source_set_deinterlace_field_order(obs_source_t *source,
		enum obs_deinterlace_field_order field_order);
EXPORT enum obs_deinterlace_field_order obs_source_get_deinterlace_field_order(
		const obs_source_t *source);

enum obs_monitoring_type {
	OBS_MONITORING_TYPE_NONE,
	OBS_MONITORING_TYPE_MONITOR_ONLY,
	OBS_MONITORING_TYPE_MONITOR_AND_OUTPUT
};

EXPORT void obs_source_set_monitoring_type(obs_source_t *source,
		enum obs_monitoring_type type);
EXPORT enum obs_monitoring_type obs_source_get_monitoring_type(
		const obs_source_t *source);


EXPORT obs_data_t *obs_source_get_private_settings(obs_source_t *item);




EXPORT void *obs_source_get_type_data(obs_source_t *source);


EXPORT void obs_source_draw_set_color_matrix(
		const struct matrix4 *color_matrix,
		const struct vec3 *color_range_min,
		const struct vec3 *color_range_max);


EXPORT void obs_source_draw(gs_texture_t *image, int x, int y,
		uint32_t cx, uint32_t cy, bool flip);


EXPORT void obs_source_output_video(obs_source_t *source,
		const struct obs_source_frame *frame);


EXPORT void obs_source_preload_video(obs_source_t *source,
		const struct obs_source_frame *frame);


EXPORT void obs_source_show_preloaded_video(obs_source_t *source);


EXPORT void obs_source_output_audio(obs_source_t *source,
		const struct obs_source_audio *audio);


EXPORT void obs_source_update_properties(obs_source_t *source);


EXPORT struct obs_source_frame *obs_source_get_frame(obs_source_t *source);


EXPORT void obs_source_release_frame(obs_source_t *source,
		struct obs_source_frame *frame);


EXPORT bool obs_source_process_filter_begin(obs_source_t *filter,
		enum gs_color_format format,
		enum obs_allow_direct_render allow_direct);


EXPORT void obs_source_process_filter_end(obs_source_t *filter,
		gs_effect_t *effect, uint32_t width, uint32_t height);


EXPORT void obs_source_process_filter_tech_end(obs_source_t *filter,
		gs_effect_t *effect, uint32_t width, uint32_t height,
		const char *tech_name);


EXPORT void obs_source_skip_video_filter(obs_source_t *filter);


EXPORT bool obs_source_add_active_child(obs_source_t *parent,
		obs_source_t *child);


EXPORT void obs_source_remove_active_child(obs_source_t *parent,
		obs_source_t *child);


EXPORT void obs_source_send_mouse_click(obs_source_t *source,
		const struct obs_mouse_event *event,
		int32_t type, bool mouse_up,
		uint32_t click_count);


EXPORT void obs_source_send_mouse_move(obs_source_t *source,
		const struct obs_mouse_event *event, bool mouse_leave);


EXPORT void obs_source_send_mouse_wheel(obs_source_t *source,
		const struct obs_mouse_event *event, int x_delta, int y_delta);


EXPORT void obs_source_send_focus(obs_source_t *source, bool focus);


EXPORT void obs_source_send_key_click(obs_source_t *source,
		const struct obs_key_event *event, bool key_up);


EXPORT void obs_source_set_default_flags(obs_source_t *source, uint32_t flags);


EXPORT uint32_t obs_source_get_base_width(obs_source_t *source);


EXPORT uint32_t obs_source_get_base_height(obs_source_t *source);

EXPORT bool obs_source_audio_pending(const obs_source_t *source);
EXPORT uint64_t obs_source_get_audio_timestamp(const obs_source_t *source);
EXPORT void obs_source_get_audio_mix(const obs_source_t *source,
		struct obs_source_audio_mix *audio);

EXPORT void obs_source_set_async_unbuffered(obs_source_t *source,
		bool unbuffered);
EXPORT bool obs_source_async_unbuffered(const obs_source_t *source);


EXPORT void obs_source_set_async_decoupled(obs_source_t *source, bool decouple);
EXPORT bool obs_source_async_decoupled(const obs_source_t *source);



enum obs_transition_target {
	OBS_TRANSITION_SOURCE_A,
	OBS_TRANSITION_SOURCE_B
};

EXPORT obs_source_t *obs_transition_get_source(obs_source_t *transition,
		enum obs_transition_target target);
EXPORT void obs_transition_clear(obs_source_t *transition);

EXPORT obs_source_t *obs_transition_get_active_source(obs_source_t *transition);

enum obs_transition_mode {
	OBS_TRANSITION_MODE_AUTO,
};

EXPORT bool obs_transition_start(obs_source_t *transition,
		enum obs_transition_mode mode, uint32_t duration_ms,
		obs_source_t *dest);

EXPORT void obs_transition_set(obs_source_t *transition, obs_source_t *source);

enum obs_transition_scale_type {
	OBS_TRANSITION_SCALE_MAX_ONLY,
	OBS_TRANSITION_SCALE_ASPECT,
	OBS_TRANSITION_SCALE_STRETCH,
};

EXPORT void obs_transition_set_scale_type(obs_source_t *transition,
		enum obs_transition_scale_type type);
EXPORT enum obs_transition_scale_type obs_transition_get_scale_type(
		const obs_source_t *transition);

EXPORT void obs_transition_set_alignment(obs_source_t *transition,
		uint32_t alignment);
EXPORT uint32_t obs_transition_get_alignment(const obs_source_t *transition);

EXPORT void obs_transition_set_size(obs_source_t *transition,
		uint32_t cx, uint32_t cy);
EXPORT void obs_transition_get_size(const obs_source_t *transition,
		uint32_t *cx, uint32_t *cy);




EXPORT void obs_transition_enable_fixed(obs_source_t *transition, bool enable,
		uint32_t duration_ms);
EXPORT bool obs_transition_fixed(obs_source_t *transition);

typedef void (*obs_transition_video_render_callback_t)(void *data,
		gs_texture_t *a, gs_texture_t *b, float t,
		uint32_t cx, uint32_t cy);
typedef float (*obs_transition_audio_mix_callback_t)(void *data, float t);

EXPORT float obs_transition_get_time(obs_source_t *transition);

EXPORT void obs_transition_video_render(obs_source_t *transition,
		obs_transition_video_render_callback_t callback);


EXPORT bool obs_transition_video_render_direct(obs_source_t *transition,
		enum obs_transition_target target);

EXPORT bool obs_transition_audio_render(obs_source_t *transition,
		uint64_t *ts_out, struct obs_source_audio_mix *audio,
		uint32_t mixers, size_t channels, size_t sample_rate,
		obs_transition_audio_mix_callback_t mix_a_callback,
		obs_transition_audio_mix_callback_t mix_b_callback);


EXPORT void obs_transition_swap_begin(obs_source_t *tr_dest,
		obs_source_t *tr_source);
EXPORT void obs_transition_swap_end(obs_source_t *tr_dest,
		obs_source_t *tr_source);






EXPORT obs_scene_t *obs_scene_create(const char *name);

EXPORT obs_scene_t *obs_scene_create_private(const char *name);

enum obs_scene_duplicate_type {
	OBS_SCENE_DUP_REFS,         
	OBS_SCENE_DUP_COPY,         
	OBS_SCENE_DUP_PRIVATE_REFS, 
	OBS_SCENE_DUP_PRIVATE_COPY  
};


EXPORT obs_scene_t *obs_scene_duplicate(obs_scene_t *scene, const char *name,
		enum obs_scene_duplicate_type type);

EXPORT void        obs_scene_addref(obs_scene_t *scene);
EXPORT void        obs_scene_release(obs_scene_t *scene);


EXPORT obs_source_t *obs_scene_get_source(const obs_scene_t *scene);


EXPORT obs_scene_t *obs_scene_from_source(const obs_source_t *source);


EXPORT obs_sceneitem_t *obs_scene_find_source(obs_scene_t *scene,
		const char *name);

EXPORT obs_sceneitem_t *obs_scene_find_sceneitem_by_id(obs_scene_t *scene,
		int64_t id);


EXPORT void obs_scene_enum_items(obs_scene_t *scene,
		bool (*callback)(obs_scene_t*, obs_sceneitem_t*, void*),
		void *param);

EXPORT bool obs_scene_reorder_items(obs_scene_t *scene,
		obs_sceneitem_t * const *item_order, size_t item_order_size);


EXPORT obs_sceneitem_t *obs_scene_add(obs_scene_t *scene, obs_source_t *source);

typedef void (*obs_scene_atomic_update_func)(void *, obs_scene_t *scene);
EXPORT void obs_scene_atomic_update(obs_scene_t *scene,
		obs_scene_atomic_update_func func, void *data);

EXPORT void obs_sceneitem_addref(obs_sceneitem_t *item);
EXPORT void obs_sceneitem_release(obs_sceneitem_t *item);


EXPORT void obs_sceneitem_remove(obs_sceneitem_t *item);


EXPORT obs_scene_t *obs_sceneitem_get_scene(const obs_sceneitem_t *item);


EXPORT obs_source_t *obs_sceneitem_get_source(const obs_sceneitem_t *item);


EXPORT void obs_sceneitem_select(obs_sceneitem_t *item, bool select);
EXPORT bool obs_sceneitem_selected(const obs_sceneitem_t *item);
EXPORT bool obs_sceneitem_locked(const obs_sceneitem_t *item);
EXPORT bool obs_sceneitem_set_locked(obs_sceneitem_t *item, bool lock);


EXPORT void obs_sceneitem_set_pos(obs_sceneitem_t *item, const struct vec2 *pos);
EXPORT void obs_sceneitem_set_rot(obs_sceneitem_t *item, float rot_deg);
EXPORT void obs_sceneitem_set_scale(obs_sceneitem_t *item,
		const struct vec2 *scale);
EXPORT void obs_sceneitem_set_alignment(obs_sceneitem_t *item,
		uint32_t alignment);
EXPORT void obs_sceneitem_set_order(obs_sceneitem_t *item,
		enum obs_order_movement movement);
EXPORT void obs_sceneitem_set_order_position(obs_sceneitem_t *item,
		int position);
EXPORT void obs_sceneitem_set_bounds_type(obs_sceneitem_t *item,
		enum obs_bounds_type type);
EXPORT void obs_sceneitem_set_bounds_alignment(obs_sceneitem_t *item,
		uint32_t alignment);
EXPORT void obs_sceneitem_set_bounds(obs_sceneitem_t *item,
		const struct vec2 *bounds);

EXPORT int64_t obs_sceneitem_get_id(const obs_sceneitem_t *item);

EXPORT void  obs_sceneitem_get_pos(const obs_sceneitem_t *item,
		struct vec2 *pos);
EXPORT float obs_sceneitem_get_rot(const obs_sceneitem_t *item);
EXPORT void  obs_sceneitem_get_scale(const obs_sceneitem_t *item,
		struct vec2 *scale);
EXPORT uint32_t obs_sceneitem_get_alignment(const obs_sceneitem_t *item);

EXPORT enum obs_bounds_type obs_sceneitem_get_bounds_type(
		const obs_sceneitem_t *item);
EXPORT uint32_t obs_sceneitem_get_bounds_alignment(const obs_sceneitem_t *item);
EXPORT void obs_sceneitem_get_bounds(const obs_sceneitem_t *item,
		struct vec2 *bounds);

EXPORT void obs_sceneitem_get_info(const obs_sceneitem_t *item,
		struct obs_transform_info *info);
EXPORT void obs_sceneitem_set_info(obs_sceneitem_t *item,
		const struct obs_transform_info *info);

EXPORT void obs_sceneitem_get_draw_transform(const obs_sceneitem_t *item,
		struct matrix4 *transform);
EXPORT void obs_sceneitem_get_box_transform(const obs_sceneitem_t *item,
		struct matrix4 *transform);

EXPORT bool obs_sceneitem_visible(const obs_sceneitem_t *item);
EXPORT bool obs_sceneitem_set_visible(obs_sceneitem_t *item, bool visible);

struct obs_sceneitem_crop {
	int left;
	int top;
	int right;
	int bottom;
};

EXPORT void obs_sceneitem_set_crop(obs_sceneitem_t *item,
		const struct obs_sceneitem_crop *crop);
EXPORT void obs_sceneitem_get_crop(const obs_sceneitem_t *item,
		struct obs_sceneitem_crop *crop);

EXPORT void obs_sceneitem_set_scale_filter(obs_sceneitem_t *item,
		enum obs_scale_type filter);
EXPORT enum obs_scale_type obs_sceneitem_get_scale_filter(
		obs_sceneitem_t *item);

EXPORT void obs_sceneitem_defer_update_begin(obs_sceneitem_t *item);
EXPORT void obs_sceneitem_defer_update_end(obs_sceneitem_t *item);


EXPORT obs_data_t *obs_sceneitem_get_private_settings(obs_sceneitem_t *item);





EXPORT const char *obs_output_get_display_name(const char *id);


EXPORT obs_output_t *obs_output_create(const char *id, const char *name,
		obs_data_t *settings, obs_data_t *hotkey_data);


EXPORT void obs_output_addref(obs_output_t *output);
EXPORT void obs_output_release(obs_output_t *output);

EXPORT void obs_weak_output_addref(obs_weak_output_t *weak);
EXPORT void obs_weak_output_release(obs_weak_output_t *weak);

EXPORT obs_output_t *obs_output_get_ref(obs_output_t *output);
EXPORT obs_weak_output_t *obs_output_get_weak_output(obs_output_t *output);
EXPORT obs_output_t *obs_weak_output_get_output(obs_weak_output_t *weak);

EXPORT bool obs_weak_output_references_output(obs_weak_output_t *weak,
		obs_output_t *output);

EXPORT const char *obs_output_get_name(const obs_output_t *output);


EXPORT bool obs_output_start(obs_output_t *output);


EXPORT void obs_output_stop(obs_output_t *output);


#define OBS_OUTPUT_DELAY_PRESERVE (1<<0)


EXPORT void obs_output_set_delay(obs_output_t *output, uint32_t delay_sec,
		uint32_t flags);


EXPORT uint32_t obs_output_get_delay(const obs_output_t *output);


EXPORT uint32_t obs_output_get_active_delay(const obs_output_t *output);


EXPORT void obs_output_force_stop(obs_output_t *output);


EXPORT bool obs_output_active(const obs_output_t *output);


EXPORT obs_data_t *obs_output_defaults(const char *id);


EXPORT obs_properties_t *obs_get_output_properties(const char *id);


EXPORT obs_properties_t *obs_output_properties(const obs_output_t *output);


EXPORT void obs_output_update(obs_output_t *output, obs_data_t *settings);


EXPORT bool obs_output_can_pause(const obs_output_t *output);


EXPORT void obs_output_pause(obs_output_t *output);


EXPORT obs_data_t *obs_output_get_settings(const obs_output_t *output);


EXPORT signal_handler_t *obs_output_get_signal_handler(
		const obs_output_t *output);


EXPORT proc_handler_t *obs_output_get_proc_handler(const obs_output_t *output);


EXPORT void obs_output_set_media(obs_output_t *output,
		video_t *video, audio_t *audio);


EXPORT video_t *obs_output_video(const obs_output_t *output);


EXPORT audio_t *obs_output_audio(const obs_output_t *output);


EXPORT void obs_output_set_mixer(obs_output_t *output, size_t mixer_idx);


EXPORT size_t obs_output_get_mixer(const obs_output_t *output);


EXPORT void obs_output_set_video_encoder(obs_output_t *output,
		obs_encoder_t *encoder);


EXPORT void obs_output_set_audio_encoder(obs_output_t *output,
		obs_encoder_t *encoder, size_t idx);


EXPORT obs_encoder_t *obs_output_get_video_encoder(const obs_output_t *output);


EXPORT obs_encoder_t *obs_output_get_audio_encoder(const obs_output_t *output,
		size_t idx);


EXPORT void obs_output_set_service(obs_output_t *output,
		obs_service_t *service);


EXPORT obs_service_t *obs_output_get_service(const obs_output_t *output);


EXPORT void obs_output_set_reconnect_settings(obs_output_t *output,
		int retry_count, int retry_sec);

EXPORT uint64_t obs_output_get_total_bytes(const obs_output_t *output);
EXPORT int obs_output_get_frames_dropped(const obs_output_t *output);
EXPORT int obs_output_get_total_frames(const obs_output_t *output);


EXPORT void obs_output_set_preferred_size(obs_output_t *output, uint32_t width,
		uint32_t height);


EXPORT uint32_t obs_output_get_width(const obs_output_t *output);


EXPORT uint32_t obs_output_get_height(const obs_output_t *output);

EXPORT const char *obs_output_get_id(const obs_output_t *output);

#if BUILD_CAPTIONS
EXPORT void obs_output_output_caption_text1(obs_output_t *output,
		const char *text);
#endif

EXPORT float obs_output_get_congestion(obs_output_t *output);
EXPORT int obs_output_get_connect_time_ms(obs_output_t *output);

EXPORT bool obs_output_reconnecting(const obs_output_t *output);


EXPORT void obs_output_set_last_error(obs_output_t *output,
		const char *message);
EXPORT const char *obs_output_get_last_error(obs_output_t *output);

EXPORT const char *obs_output_get_supported_video_codecs(
		const obs_output_t *output);
EXPORT const char *obs_output_get_supported_audio_codecs(
		const obs_output_t *output);




EXPORT void *obs_output_get_type_data(obs_output_t *output);


EXPORT void obs_output_set_video_conversion(obs_output_t *output,
		const struct video_scale_info *conversion);


EXPORT void obs_output_set_audio_conversion(obs_output_t *output,
		const struct audio_convert_info *conversion);


EXPORT bool obs_output_can_begin_data_capture(const obs_output_t *output,
		uint32_t flags);


EXPORT bool obs_output_initialize_encoders(obs_output_t *output,
		uint32_t flags);


EXPORT bool obs_output_begin_data_capture(obs_output_t *output, uint32_t flags);


EXPORT void obs_output_end_data_capture(obs_output_t *output);


EXPORT void obs_output_signal_stop(obs_output_t *output, int code);





EXPORT const char *obs_encoder_get_display_name(const char *id);


EXPORT obs_encoder_t *obs_video_encoder_create(const char *id, const char *name,
		obs_data_t *settings, obs_data_t *hotkey_data);


EXPORT obs_encoder_t *obs_audio_encoder_create(const char *id, const char *name,
		obs_data_t *settings, size_t mixer_idx,
		obs_data_t *hotkey_data);


EXPORT void obs_encoder_addref(obs_encoder_t *encoder);
EXPORT void obs_encoder_release(obs_encoder_t *encoder);

EXPORT void obs_weak_encoder_addref(obs_weak_encoder_t *weak);
EXPORT void obs_weak_encoder_release(obs_weak_encoder_t *weak);

EXPORT obs_encoder_t *obs_encoder_get_ref(obs_encoder_t *encoder);
EXPORT obs_weak_encoder_t *obs_encoder_get_weak_encoder(obs_encoder_t *encoder);
EXPORT obs_encoder_t *obs_weak_encoder_get_encoder(obs_weak_encoder_t *weak);

EXPORT bool obs_weak_encoder_references_encoder(obs_weak_encoder_t *weak,
		obs_encoder_t *encoder);

EXPORT void obs_encoder_set_name(obs_encoder_t *encoder, const char *name);
EXPORT const char *obs_encoder_get_name(const obs_encoder_t *encoder);


EXPORT const char *obs_get_encoder_codec(const char *id);


EXPORT enum obs_encoder_type obs_get_encoder_type(const char *id);


EXPORT const char *obs_encoder_get_codec(const obs_encoder_t *encoder);


EXPORT enum obs_encoder_type obs_encoder_get_type(const obs_encoder_t *encoder);


EXPORT void obs_encoder_set_scaled_size(obs_encoder_t *encoder, uint32_t width,
		uint32_t height);


EXPORT uint32_t obs_encoder_get_width(const obs_encoder_t *encoder);


EXPORT uint32_t obs_encoder_get_height(const obs_encoder_t *encoder);


EXPORT uint32_t obs_encoder_get_sample_rate(const obs_encoder_t *encoder);


EXPORT void obs_encoder_set_preferred_video_format(obs_encoder_t *encoder,
		enum video_format format);
EXPORT enum video_format obs_encoder_get_preferred_video_format(
		const obs_encoder_t *encoder);


EXPORT obs_data_t *obs_encoder_defaults(const char *id);


EXPORT obs_properties_t *obs_get_encoder_properties(const char *id);


EXPORT obs_properties_t *obs_encoder_properties(const obs_encoder_t *encoder);


EXPORT void obs_encoder_update(obs_encoder_t *encoder, obs_data_t *settings);


EXPORT bool obs_encoder_get_extra_data(const obs_encoder_t *encoder,
		uint8_t **extra_data, size_t *size);


EXPORT obs_data_t *obs_encoder_get_settings(const obs_encoder_t *encoder);


EXPORT void obs_encoder_set_video(obs_encoder_t *encoder, video_t *video);


EXPORT void obs_encoder_set_audio(obs_encoder_t *encoder, audio_t *audio);


EXPORT video_t *obs_encoder_video(const obs_encoder_t *encoder);


EXPORT audio_t *obs_encoder_audio(const obs_encoder_t *encoder);


EXPORT bool obs_encoder_active(const obs_encoder_t *encoder);

EXPORT void *obs_encoder_get_type_data(obs_encoder_t *encoder);

EXPORT const char *obs_encoder_get_id(const obs_encoder_t *encoder);

EXPORT uint32_t obs_get_encoder_caps(const char *encoder_id);

#ifndef SWIG

DEPRECATED
EXPORT void obs_duplicate_encoder_packet(struct encoder_packet *dst,
		const struct encoder_packet *src);

DEPRECATED
EXPORT void obs_free_encoder_packet(struct encoder_packet *packet);
#endif

EXPORT void obs_encoder_packet_ref(struct encoder_packet *dst,
		struct encoder_packet *src);
EXPORT void obs_encoder_packet_release(struct encoder_packet *packet);





EXPORT const char *obs_service_get_display_name(const char *id);

EXPORT obs_service_t *obs_service_create(const char *id, const char *name,
		obs_data_t *settings, obs_data_t *hotkey_data);

EXPORT obs_service_t *obs_service_create_private(const char *id,
		const char *name, obs_data_t *settings);


EXPORT void obs_service_addref(obs_service_t *service);
EXPORT void obs_service_release(obs_service_t *service);

EXPORT void obs_weak_service_addref(obs_weak_service_t *weak);
EXPORT void obs_weak_service_release(obs_weak_service_t *weak);

EXPORT obs_service_t *obs_service_get_ref(obs_service_t *service);
EXPORT obs_weak_service_t *obs_service_get_weak_service(obs_service_t *service);
EXPORT obs_service_t *obs_weak_service_get_service(obs_weak_service_t *weak);

EXPORT bool obs_weak_service_references_service(obs_weak_service_t *weak,
		obs_service_t *service);

EXPORT const char *obs_service_get_name(const obs_service_t *service);


EXPORT obs_data_t *obs_service_defaults(const char *id);


EXPORT obs_properties_t *obs_get_service_properties(const char *id);


EXPORT obs_properties_t *obs_service_properties(const obs_service_t *service);


EXPORT const char *obs_service_get_type(const obs_service_t *service);


EXPORT void obs_service_update(obs_service_t *service, obs_data_t *settings);


EXPORT obs_data_t *obs_service_get_settings(const obs_service_t *service);


EXPORT const char *obs_service_get_url(const obs_service_t *service);


EXPORT const char *obs_service_get_key(const obs_service_t *service);


EXPORT const char *obs_service_get_username(const obs_service_t *service);


EXPORT const char *obs_service_get_password(const obs_service_t *service);


EXPORT void obs_service_apply_encoder_settings(obs_service_t *service,
		obs_data_t *video_encoder_settings,
		obs_data_t *audio_encoder_settings);

EXPORT void *obs_service_get_type_data(obs_service_t *service);

EXPORT const char *obs_service_get_id(const obs_service_t *service);


EXPORT const char *obs_service_get_output_type(const obs_service_t *service);




EXPORT void obs_source_frame_init(struct obs_source_frame *frame,
		enum video_format format, uint32_t width, uint32_t height);

static inline void obs_source_frame_free(struct obs_source_frame *frame)
{
	if (frame) {
		bfree(frame->data[0]);
		memset(frame, 0, sizeof(*frame));
	}
}

static inline struct obs_source_frame *obs_source_frame_create(
		enum video_format format, uint32_t width, uint32_t height)
{
	struct obs_source_frame *frame;

	frame = (struct obs_source_frame*)bzalloc(sizeof(*frame));
	obs_source_frame_init(frame, format, width, height);
	return frame;
}

static inline void obs_source_frame_destroy(struct obs_source_frame *frame)
{
	if (frame) {
		bfree(frame->data[0]);
		bfree(frame);
	}
}


#ifdef __cplusplus
}
#endif
<code block>
#pragma once

#include "util/c99defs.h"
#include "util/darray.h"
#include "util/circlebuf.h"
#include "util/dstr.h"
#include "util/threading.h"
#include "util/platform.h"
#include "util/profiler.h"
#include "callback/signal.h"
#include "callback/proc.h"

#include "graphics/graphics.h"
#include "graphics/matrix4.h"

#include "media-io/audio-resampler.h"
#include "media-io/video-io.h"
#include "media-io/audio-io.h"

#include "obs.h"

#define NUM_TEXTURES 2
#define MICROSECOND_DEN 1000000

static inline int64_t packet_dts_usec(struct encoder_packet *packet)
{
	return packet->dts * MICROSECOND_DEN / packet->timebase_den;
}

struct tick_callback {
	void (*tick)(void *param, float seconds);
	void *param;
};

struct draw_callback {
	void (*draw)(void *param, uint32_t cx, uint32_t cy);
	void *param;
};




static inline bool obs_object_valid(const void *obj, const char *f,
		const char *t)
{
	if (!obj) {
		blog(LOG_DEBUG, "%s: Null '%s' parameter", f, t);
		return false;
	}

	return true;
}

#define obs_ptr_valid(ptr, func) obs_object_valid(ptr, func, #ptr)
#define obs_source_valid  obs_ptr_valid
#define obs_output_valid  obs_ptr_valid
#define obs_encoder_valid obs_ptr_valid
#define obs_service_valid obs_ptr_valid




struct obs_module {
	char *mod_name;
	const char *file;
	char *bin_path;
	char *data_path;
	void *module;
	bool loaded;

	bool        (*load)(void);
	void        (*unload)(void);
	void        (*post_load)(void);
	void        (*set_locale)(const char *locale);
	void        (*free_locale)(void);
	uint32_t    (*ver)(void);
	void        (*set_pointer)(obs_module_t *module);
	const char *(*name)(void);
	const char *(*description)(void);
	const char *(*author)(void);

	struct obs_module *next;
};

extern void free_module(struct obs_module *mod);

struct obs_module_path {
	char *bin;
	char *data;
};

static inline void free_module_path(struct obs_module_path *omp)
{
	if (omp) {
		bfree(omp->bin);
		bfree(omp->data);
	}
}

static inline bool check_path(const char *data, const char *path,
		struct dstr *output)
{
	dstr_copy(output, path);
	dstr_cat(output, data);

	return os_file_exists(output->array);
}





struct obs_hotkey {
	obs_hotkey_id               id;
	char                        *name;
	char                        *description;

	obs_hotkey_func             func;
	void                        *data;
	int                         pressed;

	obs_hotkey_registerer_t     registerer_type;
	void                        *registerer;

	obs_hotkey_id               pair_partner_id;
};

struct obs_hotkey_pair {
	obs_hotkey_pair_id          pair_id;
	obs_hotkey_id               id[2];
	obs_hotkey_active_func      func[2];
	bool                        pressed0;
	bool                        pressed1;
	void                        *data[2];
};

typedef struct obs_hotkey_pair obs_hotkey_pair_t;

typedef struct obs_hotkeys_platform obs_hotkeys_platform_t;

void *obs_hotkey_thread(void *param);

struct obs_core_hotkeys;
bool obs_hotkeys_platform_init(struct obs_core_hotkeys *hotkeys);
void obs_hotkeys_platform_free(struct obs_core_hotkeys *hotkeys);
bool obs_hotkeys_platform_is_pressed(obs_hotkeys_platform_t *context,
		obs_key_t key);

const char *obs_get_hotkey_translation(obs_key_t key, const char *def);

struct obs_context_data;
void obs_hotkeys_context_release(struct obs_context_data *context);

void obs_hotkeys_free(void);

struct obs_hotkey_binding {
	obs_key_combination_t       key;
	bool                        pressed;
	bool                        modifiers_match;

	obs_hotkey_id               hotkey_id;
	obs_hotkey_t                *hotkey;
};

struct obs_hotkey_name_map;
void obs_hotkey_name_map_free(void);





struct obs_view {
	pthread_mutex_t                 channels_mutex;
	obs_source_t                    *channels[MAX_CHANNELS];
};

extern bool obs_view_init(struct obs_view *view);
extern void obs_view_free(struct obs_view *view);





struct obs_display {
	bool                            size_changed;
	bool                            enabled;
	uint32_t                        cx, cy;
	uint32_t                        background_color;
	gs_swapchain_t                  *swap;
	pthread_mutex_t                 draw_callbacks_mutex;
	pthread_mutex_t                 draw_info_mutex;
	DARRAY(struct draw_callback)    draw_callbacks;

	struct obs_display              *next;
	struct obs_display              **prev_next;
};

extern bool obs_display_init(struct obs_display *display,
		const struct gs_init_data *graphics_data);
extern void obs_display_free(struct obs_display *display);





struct obs_vframe_info {
	uint64_t timestamp;
	int count;
};

struct obs_core_video {
	graphics_t                      *graphics;
	gs_stagesurf_t                  *copy_surfaces[NUM_TEXTURES];
	gs_texture_t                    *render_textures[NUM_TEXTURES];
	gs_texture_t                    *output_textures[NUM_TEXTURES];
	gs_texture_t                    *convert_textures[NUM_TEXTURES];
	bool                            textures_rendered[NUM_TEXTURES];
	bool                            textures_output[NUM_TEXTURES];
	bool                            textures_copied[NUM_TEXTURES];
	bool                            textures_converted[NUM_TEXTURES];
	struct circlebuf                vframe_info_buffer;
	gs_effect_t                     *default_effect;
	gs_effect_t                     *default_rect_effect;
	gs_effect_t                     *opaque_effect;
	gs_effect_t                     *solid_effect;
	gs_effect_t                     *conversion_effect;
	gs_effect_t                     *bicubic_effect;
	gs_effect_t                     *lanczos_effect;
	gs_effect_t                     *bilinear_lowres_effect;
	gs_effect_t                     *premultiplied_alpha_effect;
	gs_samplerstate_t               *point_sampler;
	gs_stagesurf_t                  *mapped_surface;
	int                             cur_texture;

	uint64_t                        video_time;
	uint64_t                        video_avg_frame_time_ns;
	double                          video_fps;
	video_t                         *video;
	pthread_t                       video_thread;
	uint32_t                        total_frames;
	uint32_t                        lagged_frames;
	bool                            thread_initialized;

	bool                            gpu_conversion;
	const char                      *conversion_tech;
	uint32_t                        conversion_height;
	uint32_t                        plane_offsets[3];
	uint32_t                        plane_sizes[3];
	uint32_t                        plane_linewidth[3];

	uint32_t                        output_width;
	uint32_t                        output_height;
	uint32_t                        base_width;
	uint32_t                        base_height;
	float                           color_matrix[16];
	enum obs_scale_type             scale_type;

	gs_texture_t                    *transparent_texture;

	gs_effect_t                     *deinterlace_discard_effect;
	gs_effect_t                     *deinterlace_discard_2x_effect;
	gs_effect_t                     *deinterlace_linear_effect;
	gs_effect_t                     *deinterlace_linear_2x_effect;
	gs_effect_t                     *deinterlace_blend_effect;
	gs_effect_t                     *deinterlace_blend_2x_effect;
	gs_effect_t                     *deinterlace_yadif_effect;
	gs_effect_t                     *deinterlace_yadif_2x_effect;

	struct obs_video_info           ovi;
};

struct audio_monitor;

struct obs_core_audio {
	audio_t                         *audio;

	DARRAY(struct obs_source*)      render_order;
	DARRAY(struct obs_source*)      root_nodes;

	uint64_t                        buffered_ts;
	struct circlebuf                buffered_timestamps;
	int                             buffering_wait_ticks;
	int                             total_buffering_ticks;

	float                           user_volume;

	pthread_mutex_t                 monitoring_mutex;
	DARRAY(struct audio_monitor*)   monitors;
	char                            *monitoring_device_name;
	char                            *monitoring_device_id;
};


struct obs_core_data {
	struct obs_source               *first_source;
	struct obs_source               *first_audio_source;
	struct obs_display              *first_display;
	struct obs_output               *first_output;
	struct obs_encoder              *first_encoder;
	struct obs_service              *first_service;

	pthread_mutex_t                 sources_mutex;
	pthread_mutex_t                 displays_mutex;
	pthread_mutex_t                 outputs_mutex;
	pthread_mutex_t                 encoders_mutex;
	pthread_mutex_t                 services_mutex;
	pthread_mutex_t                 audio_sources_mutex;
	pthread_mutex_t                 draw_callbacks_mutex;
	DARRAY(struct draw_callback)    draw_callbacks;
	DARRAY(struct tick_callback)    tick_callbacks;

	struct obs_view                 main_view;

	long long                       unnamed_index;

	volatile bool                   valid;
};


struct obs_core_hotkeys {
	pthread_mutex_t                 mutex;
	DARRAY(obs_hotkey_t)            hotkeys;
	obs_hotkey_id                   next_id;
	DARRAY(obs_hotkey_pair_t)       hotkey_pairs;
	obs_hotkey_pair_id              next_pair_id;

	pthread_t                       hotkey_thread;
	bool                            hotkey_thread_initialized;
	os_event_t                      *stop_event;
	bool                            thread_disable_press;
	bool                            strict_modifiers;
	bool                            reroute_hotkeys;
	DARRAY(obs_hotkey_binding_t)    bindings;

	obs_hotkey_callback_router_func router_func;
	void                            *router_func_data;

	obs_hotkeys_platform_t          *platform_context;

	pthread_once_t                  name_map_init_token;
	struct obs_hotkey_name_map      *name_map;

	signal_handler_t                *signals;

	char                            *translations[OBS_KEY_LAST_VALUE];
	char                            *mute;
	char                            *unmute;
	char                            *push_to_mute;
	char                            *push_to_talk;
	char                            *sceneitem_show;
	char                            *sceneitem_hide;
};

struct obs_core {
	struct obs_module               *first_module;
	DARRAY(struct obs_module_path)  module_paths;

	DARRAY(struct obs_source_info)  source_types;
	DARRAY(struct obs_source_info)  input_types;
	DARRAY(struct obs_source_info)  filter_types;
	DARRAY(struct obs_source_info)  transition_types;
	DARRAY(struct obs_output_info)  output_types;
	DARRAY(struct obs_encoder_info) encoder_types;
	DARRAY(struct obs_service_info) service_types;
	DARRAY(struct obs_modal_ui)     modal_ui_callbacks;
	DARRAY(struct obs_modeless_ui)  modeless_ui_callbacks;

	signal_handler_t                *signals;
	proc_handler_t                  *procs;

	char                            *locale;
	char                            *module_config_path;
	bool                            name_store_owned;
	profiler_name_store_t           *name_store;


	struct obs_core_video           video;
	struct obs_core_audio           audio;
	struct obs_core_data            data;
	struct obs_core_hotkeys         hotkeys;
};

extern struct obs_core *obs;

extern void *obs_graphics_thread(void *param);

extern gs_effect_t *obs_load_effect(gs_effect_t **effect, const char *file);

extern bool audio_callback(void *param,
		uint64_t start_ts_in, uint64_t end_ts_in, uint64_t *out_ts,
		uint32_t mixers, struct audio_output_data *mixes);





struct obs_context_data {
	char                            *name;
	void                            *data;
	obs_data_t                      *settings;
	signal_handler_t                *signals;
	proc_handler_t                  *procs;
	enum obs_obj_type               type;

	DARRAY(obs_hotkey_id)           hotkeys;
	DARRAY(obs_hotkey_pair_id)      hotkey_pairs;
	obs_data_t                      *hotkey_data;

	DARRAY(char*)                   rename_cache;
	pthread_mutex_t                 rename_cache_mutex;

	pthread_mutex_t                 *mutex;
	struct obs_context_data         *next;
	struct obs_context_data         **prev_next;

	bool                            private;
};

extern bool obs_context_data_init(
		struct obs_context_data *context,
		enum obs_obj_type       type,
		obs_data_t              *settings,
		const char              *name,
		obs_data_t              *hotkey_data,
		bool                    private);
extern void obs_context_data_free(struct obs_context_data *context);

extern void obs_context_data_insert(struct obs_context_data *context,
		pthread_mutex_t *mutex, void *first);
extern void obs_context_data_remove(struct obs_context_data *context);

extern void obs_context_data_setname(struct obs_context_data *context,
		const char *name);





struct obs_weak_ref {
	volatile long refs;
	volatile long weak_refs;
};

static inline void obs_ref_addref(struct obs_weak_ref *ref)
{
	os_atomic_inc_long(&ref->refs);
}

static inline bool obs_ref_release(struct obs_weak_ref *ref)
{
	return os_atomic_dec_long(&ref->refs) == -1;
}

static inline void obs_weak_ref_addref(struct obs_weak_ref *ref)
{
	os_atomic_inc_long(&ref->weak_refs);
}

static inline bool obs_weak_ref_release(struct obs_weak_ref *ref)
{
	return os_atomic_dec_long(&ref->weak_refs) == -1;
}

static inline bool obs_weak_ref_get_ref(struct obs_weak_ref *ref)
{
	long owners = ref->refs;
	while (owners > -1) {
		if (os_atomic_compare_swap_long(&ref->refs, owners, owners + 1))
			return true;

		owners = ref->refs;
	}

	return false;
}





struct async_frame {
	struct obs_source_frame *frame;
	long unused_count;
	bool used;
};

enum audio_action_type {
	AUDIO_ACTION_VOL,
	AUDIO_ACTION_MUTE,
	AUDIO_ACTION_PTT,
	AUDIO_ACTION_PTM,
};

struct audio_action {
	uint64_t timestamp;
	enum audio_action_type type;
	union {
		float vol;
		bool  set;
	};
};

struct obs_weak_source {
	struct obs_weak_ref ref;
	struct obs_source *source;
};

struct audio_cb_info {
	obs_source_audio_capture_t callback;
	void *param;
};

struct obs_source {
	struct obs_context_data         context;
	struct obs_source_info          info;
	struct obs_weak_source          *control;


	uint32_t                        flags;
	uint32_t                        default_flags;


	bool                            owns_info_id;


	bool                            defer_update;


	volatile long                   show_refs;


	volatile long                   activate_refs;


	bool                            removed;

	bool                            active;
	bool                            showing;


	bool                            enabled;


	volatile bool                   timing_set;
	volatile uint64_t               timing_adjust;
	uint64_t                        resample_offset;
	uint64_t                        last_audio_ts;
	uint64_t                        next_audio_ts_min;
	uint64_t                        next_audio_sys_ts_min;
	uint64_t                        last_frame_ts;
	uint64_t                        last_sys_timestamp;
	bool                            async_rendered;


	bool                            audio_failed;
	bool                            audio_pending;
	bool                            pending_stop;
	bool                            user_muted;
	bool                            muted;
	struct obs_source               *next_audio_source;
	struct obs_source               **prev_next_audio_source;
	uint64_t                        audio_ts;
	struct circlebuf                audio_input_buf[MAX_AUDIO_CHANNELS];
	size_t                          last_audio_input_buf_size;
	DARRAY(struct audio_action)     audio_actions;
	float                           *audio_output_buf[MAX_AUDIO_MIXES][MAX_AUDIO_CHANNELS];
	struct resample_info            sample_info;
	audio_resampler_t               *resampler;
	pthread_mutex_t                 audio_actions_mutex;
	pthread_mutex_t                 audio_buf_mutex;
	pthread_mutex_t                 audio_mutex;
	pthread_mutex_t                 audio_cb_mutex;
	DARRAY(struct audio_cb_info)    audio_cb_list;
	struct obs_audio_data           audio_data;
	size_t                          audio_storage_size;
	uint32_t                        audio_mixers;
	float                           user_volume;
	float                           volume;
	int64_t                         sync_offset;
	int64_t                         last_sync_offset;


	gs_texture_t                    *async_texture;
	gs_texrender_t                  *async_texrender;
	struct obs_source_frame         *cur_async_frame;
	bool                            async_gpu_conversion;
	enum video_format               async_format;
	enum video_format               async_cache_format;
	enum gs_color_format            async_texture_format;
	float                           async_color_matrix[16];
	bool                            async_full_range;
	float                           async_color_range_min[3];
	float                           async_color_range_max[3];
	int                             async_plane_offset[2];
	bool                            async_flip;
	bool                            async_active;
	bool                            async_update_texture;
	bool                            async_unbuffered;
	bool                            async_decoupled;
	struct obs_source_frame         *async_preload_frame;
	DARRAY(struct async_frame)      async_cache;
	DARRAY(struct obs_source_frame*)async_frames;
	pthread_mutex_t                 async_mutex;
	uint32_t                        async_width;
	uint32_t                        async_height;
	uint32_t                        async_cache_width;
	uint32_t                        async_cache_height;
	uint32_t                        async_convert_width;
	uint32_t                        async_convert_height;


	uint64_t                        deinterlace_offset;
	uint64_t                        deinterlace_frame_ts;
	gs_effect_t                     *deinterlace_effect;
	struct obs_source_frame         *prev_async_frame;
	gs_texture_t                    *async_prev_texture;
	gs_texrender_t                  *async_prev_texrender;
	uint32_t                        deinterlace_half_duration;
	enum obs_deinterlace_mode       deinterlace_mode;
	bool                            deinterlace_top_first;
	bool                            deinterlace_rendered;


	struct obs_source               *filter_parent;
	struct obs_source               *filter_target;
	DARRAY(struct obs_source*)      filters;
	pthread_mutex_t                 filter_mutex;
	gs_texrender_t                  *filter_texrender;
	enum obs_allow_direct_render    allow_direct;
	bool                            rendering_filter;


	obs_hotkey_pair_id              mute_unmute_key;
	obs_hotkey_id                   push_to_mute_key;
	obs_hotkey_id                   push_to_talk_key;
	bool                            push_to_mute_enabled;
	bool                            push_to_mute_pressed;
	bool                            user_push_to_mute_pressed;
	bool                            push_to_talk_enabled;
	bool                            push_to_talk_pressed;
	bool                            user_push_to_talk_pressed;
	uint64_t                        push_to_mute_delay;
	uint64_t                        push_to_mute_stop_time;
	uint64_t                        push_to_talk_delay;
	uint64_t                        push_to_talk_stop_time;


	uint64_t                        transition_start_time;
	uint64_t                        transition_duration;
	pthread_mutex_t                 transition_tex_mutex;
	gs_texrender_t                  *transition_texrender[2];
	pthread_mutex_t                 transition_mutex;
	obs_source_t                    *transition_sources[2];
	bool                            transitioning_video;
	bool                            transitioning_audio;
	bool                            transition_source_active[2];
	uint32_t                        transition_alignment;
	uint32_t                        transition_actual_cx;
	uint32_t                        transition_actual_cy;
	uint32_t                        transition_cx;
	uint32_t                        transition_cy;
	uint32_t                        transition_fixed_duration;
	bool                            transition_use_fixed_duration;
	enum obs_transition_mode        transition_mode;
	enum obs_transition_scale_type  transition_scale_type;
	struct matrix4                  transition_matrices[2];

	struct audio_monitor            *monitor;
	enum obs_monitoring_type        monitoring_type;

	obs_data_t                      *private_settings;
};

extern struct obs_source_info *get_source_info(const char *id);
extern bool obs_source_init_context(struct obs_source *source,
		obs_data_t *settings, const char *name,
		obs_data_t *hotkey_data, bool private);

extern void obs_source_save(obs_source_t *source);
extern void obs_source_load(obs_source_t *source);

extern bool obs_transition_init(obs_source_t *transition);
extern void obs_transition_free(obs_source_t *transition);
extern void obs_transition_tick(obs_source_t *transition);
extern void obs_transition_enum_sources(obs_source_t *transition,
		obs_source_enum_proc_t enum_callback, void *param);
extern void obs_transition_save(obs_source_t *source, obs_data_t *data);
extern void obs_transition_load(obs_source_t *source, obs_data_t *data);

struct audio_monitor *audio_monitor_create(obs_source_t *source);
void audio_monitor_reset(struct audio_monitor *monitor);
extern void audio_monitor_destroy(struct audio_monitor *monitor);

extern void obs_source_destroy(struct obs_source *source);

enum view_type {
	MAIN_VIEW,
	AUX_VIEW
};

static inline void obs_source_dosignal(struct obs_source *source,
		const char *signal_obs, const char *signal_source)
{
	struct calldata data;
	uint8_t stack[128];

	calldata_init_fixed(&data, stack, sizeof(stack));
	calldata_set_ptr(&data, "source", source);
	if (signal_obs && !source->context.private)
		signal_handler_signal(obs->signals, signal_obs, &data);
	if (signal_source)
		signal_handler_signal(source->context.signals, signal_source,
				&data);
}


#define MAX_TS_VAR          2000000000ULL

static inline bool frame_out_of_bounds(const obs_source_t *source, uint64_t ts)
{
	if (ts < source->last_frame_ts)
		return ((source->last_frame_ts - ts) > MAX_TS_VAR);
	else
		return ((ts - source->last_frame_ts) > MAX_TS_VAR);
}

static inline enum gs_color_format convert_video_format(
		enum video_format format)
{
	if (format == VIDEO_FORMAT_RGBA)
		return GS_RGBA;
	else if (format == VIDEO_FORMAT_BGRA)
		return GS_BGRA;

	return GS_BGRX;
}

extern void obs_source_activate(obs_source_t *source, enum view_type type);
extern void obs_source_deactivate(obs_source_t *source, enum view_type type);
extern void obs_source_video_tick(obs_source_t *source, float seconds);
extern float obs_source_get_target_volume(obs_source_t *source,
		obs_source_t *target);

extern void obs_source_audio_render(obs_source_t *source, uint32_t mixers,
		size_t channels, size_t sample_rate, size_t size);

extern void add_alignment(struct vec2 *v, uint32_t align, int cx, int cy);

extern struct obs_source_frame *filter_async_video(obs_source_t *source,
		struct obs_source_frame *in);
extern bool update_async_texture(struct obs_source *source,
		const struct obs_source_frame *frame,
		gs_texture_t *tex, gs_texrender_t *texrender);
extern bool set_async_texture_size(struct obs_source *source,
		const struct obs_source_frame *frame);
extern void remove_async_frame(obs_source_t *source,
		struct obs_source_frame *frame);

extern void set_deinterlace_texture_size(obs_source_t *source);
extern void deinterlace_process_last_frame(obs_source_t *source,
		uint64_t sys_time);
extern void deinterlace_update_async_video(obs_source_t *source);
extern void deinterlace_render(obs_source_t *s);





enum delay_msg {
	DELAY_MSG_PACKET,
	DELAY_MSG_START,
	DELAY_MSG_STOP,
};

struct delay_data {
	enum delay_msg msg;
	uint64_t ts;
	struct encoder_packet packet;
};

typedef void (*encoded_callback_t)(void *data, struct encoder_packet *packet);

struct obs_weak_output {
	struct obs_weak_ref ref;
	struct obs_output *output;
};

#define CAPTION_LINE_CHARS (32)
#define CAPTION_LINE_BYTES (4*CAPTION_LINE_CHARS)
struct caption_text {
	char text[CAPTION_LINE_BYTES+1];
	struct caption_text *next;
};

struct obs_output {
	struct obs_context_data         context;
	struct obs_output_info          info;
	struct obs_weak_output          *control;


	bool                            owns_info_id;

	bool                            received_video;
	bool                            received_audio;
	volatile bool                   data_active;
	volatile bool                   end_data_capture_thread_active;
	int64_t                         video_offset;
	int64_t                         audio_offsets[MAX_AUDIO_MIXES];
	int64_t                         highest_audio_ts;
	int64_t                         highest_video_ts;
	pthread_t                       end_data_capture_thread;
	os_event_t                      *stopping_event;
	pthread_mutex_t                 interleaved_mutex;
	DARRAY(struct encoder_packet)   interleaved_packets;
	int                             stop_code;

	int                             reconnect_retry_sec;
	int                             reconnect_retry_max;
	int                             reconnect_retries;
	int                             reconnect_retry_cur_sec;
	pthread_t                       reconnect_thread;
	os_event_t                      *reconnect_stop_event;
	volatile bool                   reconnecting;
	volatile bool                   reconnect_thread_active;

	uint32_t                        starting_drawn_count;
	uint32_t                        starting_lagged_count;
	uint32_t                        starting_frame_count;

	int                             total_frames;

	volatile bool                   active;
	video_t                         *video;
	audio_t                         *audio;
	obs_encoder_t                   *video_encoder;
	obs_encoder_t                   *audio_encoders[MAX_AUDIO_MIXES];
	obs_service_t                   *service;
	size_t                          mixer_idx;

	uint32_t                        scaled_width;
	uint32_t                        scaled_height;

	bool                            video_conversion_set;
	bool                            audio_conversion_set;
	struct video_scale_info         video_conversion;
	struct audio_convert_info       audio_conversion;

	pthread_mutex_t                 caption_mutex;
	double                          caption_timestamp;
	struct caption_text             *caption_head;
	struct caption_text             *caption_tail;

	bool                            valid;

	uint64_t                        active_delay_ns;
	encoded_callback_t              delay_callback;
	struct circlebuf                delay_data; 
	pthread_mutex_t                 delay_mutex;
	uint32_t                        delay_sec;
	uint32_t                        delay_flags;
	uint32_t                        delay_cur_flags;
	volatile long                   delay_restart_refs;
	volatile bool                   delay_active;
	volatile bool                   delay_capturing;

	char                            *last_error_message;
};

static inline void do_output_signal(struct obs_output *output,
		const char *signal)
{
	struct calldata params = {0};
	calldata_set_ptr(&params, "output", output);
	signal_handler_signal(output->context.signals, signal, &params);
	calldata_free(&params);
}

extern void process_delay(void *data, struct encoder_packet *packet);
extern void obs_output_cleanup_delay(obs_output_t *output);
extern bool obs_output_delay_start(obs_output_t *output);
extern void obs_output_delay_stop(obs_output_t *output);
extern bool obs_output_actual_start(obs_output_t *output);
extern void obs_output_actual_stop(obs_output_t *output, bool force,
		uint64_t ts);

extern const struct obs_output_info *find_output(const char *id);

extern void obs_output_remove_encoder(struct obs_output *output,
		struct obs_encoder *encoder);

extern void obs_encoder_packet_create_instance(struct encoder_packet *dst,
		const struct encoder_packet *src);
void obs_output_destroy(obs_output_t *output);





struct obs_weak_encoder {
	struct obs_weak_ref ref;
	struct obs_encoder *encoder;
};

struct encoder_callback {
	bool sent_first_packet;
	void (*new_packet)(void *param, struct encoder_packet *packet);
	void *param;
};

struct obs_encoder {
	struct obs_context_data         context;
	struct obs_encoder_info         info;
	struct obs_weak_encoder         *control;

	pthread_mutex_t                 init_mutex;

	uint32_t                        samplerate;
	size_t                          planes;
	size_t                          blocksize;
	size_t                          framesize;
	size_t                          framesize_bytes;

	size_t                          mixer_idx;

	uint32_t                        scaled_width;
	uint32_t                        scaled_height;
	enum video_format               preferred_format;

	volatile bool                   active;
	bool                            initialized;


	bool                            owns_info_id;

	uint32_t                        timebase_num;
	uint32_t                        timebase_den;

	int64_t                         cur_pts;

	struct circlebuf                audio_input_buffer[MAX_AV_PLANES];
	uint8_t                         *audio_output_buffer[MAX_AV_PLANES];


	bool                            wait_for_video;
	bool                            first_received;
	struct obs_encoder              *paired_encoder;
	int64_t                         offset_usec;
	uint64_t                        first_raw_ts;
	uint64_t                        start_ts;

	pthread_mutex_t                 outputs_mutex;
	DARRAY(obs_output_t*)            outputs;

	bool                            destroy_on_stop;


	void                            *media;

	pthread_mutex_t                 callbacks_mutex;
	DARRAY(struct encoder_callback) callbacks;

	const char                      *profile_encoder_encode_name;
};

extern struct obs_encoder_info *find_encoder(const char *id);

extern bool obs_encoder_initialize(obs_encoder_t *encoder);
extern void obs_encoder_shutdown(obs_encoder_t *encoder);

extern void obs_encoder_start(obs_encoder_t *encoder,
		void (*new_packet)(void *param, struct encoder_packet *packet),
		void *param);
extern void obs_encoder_stop(obs_encoder_t *encoder,
		void (*new_packet)(void *param, struct encoder_packet *packet),
		void *param);

extern void obs_encoder_add_output(struct obs_encoder *encoder,
		struct obs_output *output);
extern void obs_encoder_remove_output(struct obs_encoder *encoder,
		struct obs_output *output);

void obs_encoder_destroy(obs_encoder_t *encoder);




struct obs_weak_service {
	struct obs_weak_ref ref;
	struct obs_service *service;
};

struct obs_service {
	struct obs_context_data         context;
	struct obs_service_info         info;
	struct obs_weak_service         *control;


	bool                            owns_info_id;

	bool                            active;
	bool                            destroy;
	struct obs_output               *output;
};

extern const struct obs_service_info *find_service(const char *id);

extern void obs_service_activate(struct obs_service *service);
extern void obs_service_deactivate(struct obs_service *service, bool remove);
extern bool obs_service_initialize(struct obs_service *service,
		struct obs_output *output);

void obs_service_destroy(obs_service_t *service);
<code block>
#pragma once

#include "util/c99defs.h"
#include "util/bmem.h"
#include "util/profiler.h"
#include "util/text-lookup.h"
#include "graphics/graphics.h"
#include "graphics/vec2.h"
#include "graphics/vec3.h"
#include "media-io/audio-io.h"
#include "media-io/video-io.h"
#include "callback/signal.h"
#include "callback/proc.h"

#include "obs-config.h"
#include "obs-defs.h"
#include "obs-data.h"
#include "obs-ui.h"
#include "obs-properties.h"
#include "obs-interaction.h"

struct matrix4;


struct obs_display;
struct obs_view;
struct obs_source;
struct obs_scene;
struct obs_scene_item;
struct obs_output;
struct obs_encoder;
struct obs_service;
struct obs_module;
struct obs_fader;
struct obs_volmeter;

typedef struct obs_display    obs_display_t;
typedef struct obs_view       obs_view_t;
typedef struct obs_source     obs_source_t;
typedef struct obs_scene      obs_scene_t;
typedef struct obs_scene_item obs_sceneitem_t;
typedef struct obs_output     obs_output_t;
typedef struct obs_encoder    obs_encoder_t;
typedef struct obs_service    obs_service_t;
typedef struct obs_module     obs_module_t;
typedef struct obs_fader      obs_fader_t;
typedef struct obs_volmeter   obs_volmeter_t;

typedef struct obs_weak_source  obs_weak_source_t;
typedef struct obs_weak_output  obs_weak_output_t;
typedef struct obs_weak_encoder obs_weak_encoder_t;
typedef struct obs_weak_service obs_weak_service_t;

#include "obs-source.h"
#include "obs-encoder.h"
#include "obs-output.h"
#include "obs-service.h"
#include "obs-audio-controls.h"
#include "obs-hotkey.h"



#ifdef __cplusplus
extern "C" {
#endif


enum obs_order_movement {
	OBS_ORDER_MOVE_UP,
	OBS_ORDER_MOVE_DOWN,
	OBS_ORDER_MOVE_TOP,
	OBS_ORDER_MOVE_BOTTOM
};


enum obs_allow_direct_render {
	OBS_NO_DIRECT_RENDERING,
	OBS_ALLOW_DIRECT_RENDERING,
};

enum obs_scale_type {
	OBS_SCALE_DISABLE,
	OBS_SCALE_POINT,
	OBS_SCALE_BICUBIC,
	OBS_SCALE_BILINEAR,
	OBS_SCALE_LANCZOS
};


enum obs_bounds_type {
	OBS_BOUNDS_NONE,            
	OBS_BOUNDS_STRETCH,         
	OBS_BOUNDS_SCALE_INNER,     
	OBS_BOUNDS_SCALE_OUTER,     
	OBS_BOUNDS_SCALE_TO_WIDTH,  
	OBS_BOUNDS_SCALE_TO_HEIGHT, 
	OBS_BOUNDS_MAX_ONLY,        
};

struct obs_transform_info {
	struct vec2          pos;
	float                rot;
	struct vec2          scale;
	uint32_t             alignment;

	enum obs_bounds_type bounds_type;
	uint32_t             bounds_alignment;
	struct vec2          bounds;
};


struct obs_video_info {
#ifndef SWIG

	const char          *graphics_module;
#endif

	uint32_t            fps_num;       
	uint32_t            fps_den;       

	uint32_t            base_width;    
	uint32_t            base_height;   

	uint32_t            output_width;  
	uint32_t            output_height; 
	enum video_format   output_format; 


	uint32_t            adapter;


	bool                gpu_conversion;

	enum video_colorspace colorspace;  
	enum video_range_type range;       

	enum obs_scale_type scale_type;    
};


struct obs_audio_info {
	uint32_t            samples_per_sec;
	enum speaker_layout speakers;
};


struct obs_audio_data {
	uint8_t             *data[MAX_AV_PLANES];
	uint32_t            frames;
	uint64_t            timestamp;
};


struct obs_source_audio {
	const uint8_t       *data[MAX_AV_PLANES];
	uint32_t            frames;

	enum speaker_layout speakers;
	enum audio_format   format;
	uint32_t            samples_per_sec;

	uint64_t            timestamp;
};


struct obs_source_frame {
	uint8_t             *data[MAX_AV_PLANES];
	uint32_t            linesize[MAX_AV_PLANES];
	uint32_t            width;
	uint32_t            height;
	uint64_t            timestamp;

	enum video_format   format;
	float               color_matrix[16];
	bool                full_range;
	float               color_range_min[3];
	float               color_range_max[3];
	bool                flip;


	volatile long       refs;
	bool                prev_frame;
};





EXPORT bool obs_startup(const char *locale, const char *module_config_path,
		profiler_name_store_t *store);


EXPORT void obs_shutdown(void);


EXPORT bool obs_initialized(void);


EXPORT uint32_t obs_get_version(void);


EXPORT const char *obs_get_version_string(void);


EXPORT void obs_set_locale(const char *locale);


EXPORT const char *obs_get_locale(void);


EXPORT profiler_name_store_t *obs_get_profiler_name_store(void);


EXPORT int obs_reset_video(struct obs_video_info *ovi);


EXPORT bool obs_reset_audio(const struct obs_audio_info *oai);


EXPORT bool obs_get_video_info(struct obs_video_info *ovi);


EXPORT bool obs_get_audio_info(struct obs_audio_info *oai);


EXPORT int obs_open_module(obs_module_t **module, const char *path,
		const char *data_path);


EXPORT bool obs_init_module(obs_module_t *module);


EXPORT void obs_log_loaded_modules(void);


EXPORT const char *obs_get_module_file_name(obs_module_t *module);


EXPORT const char *obs_get_module_name(obs_module_t *module);


EXPORT const char *obs_get_module_author(obs_module_t *module);


EXPORT const char *obs_get_module_description(obs_module_t *module);


EXPORT const char *obs_get_module_binary_path(obs_module_t *module);


EXPORT const char *obs_get_module_data_path(obs_module_t *module);


EXPORT void obs_add_module_path(const char *bin, const char *data);


EXPORT void obs_load_all_modules(void);


EXPORT void obs_post_load_modules(void);

#ifndef SWIG
struct obs_module_info {
	const char *bin_path;
	const char *data_path;
};

typedef void (*obs_find_module_callback_t)(void *param,
		const struct obs_module_info *info);


EXPORT void obs_find_modules(obs_find_module_callback_t callback, void *param);
#endif

typedef void (*obs_enum_module_callback_t)(void *param, obs_module_t *module);


EXPORT void obs_enum_modules(obs_enum_module_callback_t callback, void *param);


EXPORT lookup_t *obs_module_load_locale(obs_module_t *module,
		const char *default_locale, const char *locale);


EXPORT char *obs_find_module_file(obs_module_t *module, const char *file);


EXPORT char *obs_module_get_config_path(obs_module_t *module, const char *file);


EXPORT bool obs_enum_source_types(size_t idx, const char **id);


EXPORT bool obs_enum_input_types(size_t idx, const char **id);


EXPORT bool obs_enum_filter_types(size_t idx, const char **id);


EXPORT bool obs_enum_transition_types(size_t idx, const char **id);


EXPORT bool obs_enum_output_types(size_t idx, const char **id);


EXPORT bool obs_enum_encoder_types(size_t idx, const char **id);


EXPORT bool obs_enum_service_types(size_t idx, const char **id);


EXPORT void obs_enter_graphics(void);


EXPORT void obs_leave_graphics(void);


EXPORT audio_t *obs_get_audio(void);


EXPORT video_t *obs_get_video(void);


EXPORT void obs_set_output_source(uint32_t channel, obs_source_t *source);


EXPORT obs_source_t *obs_get_output_source(uint32_t channel);


EXPORT void obs_enum_sources(bool (*enum_proc)(void*, obs_source_t*),
		void *param);


EXPORT void obs_enum_outputs(bool (*enum_proc)(void*, obs_output_t*),
		void *param);


EXPORT void obs_enum_encoders(bool (*enum_proc)(void*, obs_encoder_t*),
		void *param);


EXPORT void obs_enum_services(bool (*enum_proc)(void*, obs_service_t*),
		void *param);


EXPORT obs_source_t *obs_get_source_by_name(const char *name);


EXPORT obs_output_t *obs_get_output_by_name(const char *name);


EXPORT obs_encoder_t *obs_get_encoder_by_name(const char *name);


EXPORT obs_service_t *obs_get_service_by_name(const char *name);

enum obs_base_effect {
	OBS_EFFECT_DEFAULT,            
	OBS_EFFECT_DEFAULT_RECT,       
	OBS_EFFECT_OPAQUE,             
	OBS_EFFECT_SOLID,              
	OBS_EFFECT_BICUBIC,            
	OBS_EFFECT_LANCZOS,            
	OBS_EFFECT_BILINEAR_LOWRES,    
	OBS_EFFECT_PREMULTIPLIED_ALPHA,
};


EXPORT gs_effect_t *obs_get_base_effect(enum obs_base_effect effect);

#ifndef SWIG

DEPRECATED
EXPORT gs_effect_t *obs_get_default_rect_effect(void);
#endif


EXPORT signal_handler_t *obs_get_signal_handler(void);


EXPORT proc_handler_t *obs_get_proc_handler(void);

#ifndef SWIG

DEPRECATED
EXPORT void obs_render_main_view(void);
#endif


EXPORT void obs_render_main_texture(void);


EXPORT void obs_set_master_volume(float volume);


EXPORT float obs_get_master_volume(void);


EXPORT obs_data_t *obs_save_source(obs_source_t *source);


EXPORT obs_source_t *obs_load_source(obs_data_t *data);

typedef void (*obs_load_source_cb)(void *private_data, obs_source_t *source);


EXPORT void obs_load_sources(obs_data_array_t *array, obs_load_source_cb cb,
		void *private_data);


EXPORT obs_data_array_t *obs_save_sources(void);

typedef bool (*obs_save_source_filter_cb)(void *data, obs_source_t *source);
EXPORT obs_data_array_t *obs_save_sources_filtered(obs_save_source_filter_cb cb,
		void *data);

enum obs_obj_type {
	OBS_OBJ_TYPE_INVALID,
	OBS_OBJ_TYPE_SOURCE,
	OBS_OBJ_TYPE_OUTPUT,
	OBS_OBJ_TYPE_ENCODER,
	OBS_OBJ_TYPE_SERVICE
};

EXPORT enum obs_obj_type obs_obj_get_type(void *obj);
EXPORT const char *obs_obj_get_id(void *obj);
EXPORT bool obs_obj_invalid(void *obj);

typedef bool (*obs_enum_audio_device_cb)(void *data, const char *name,
		const char *id);

EXPORT void obs_enum_audio_monitoring_devices(obs_enum_audio_device_cb cb,
		void *data);

EXPORT bool obs_set_audio_monitoring_device(const char *name, const char *id);
EXPORT void obs_get_audio_monitoring_device(const char **name, const char **id);

EXPORT void obs_add_tick_callback(
		void (*tick)(void *param, float seconds),
		void *param);
EXPORT void obs_remove_tick_callback(
		void (*tick)(void *param, float seconds),
		void *param);

EXPORT void obs_add_main_render_callback(
		void (*draw)(void *param, uint32_t cx, uint32_t cy),
		void *param);
EXPORT void obs_remove_main_render_callback(
		void (*draw)(void *param, uint32_t cx, uint32_t cy),
		void *param);






EXPORT obs_view_t *obs_view_create(void);


EXPORT void obs_view_destroy(obs_view_t *view);


EXPORT void obs_view_set_source(obs_view_t *view, uint32_t channel,
		obs_source_t *source);


EXPORT obs_source_t *obs_view_get_source(obs_view_t *view,
		uint32_t channel);


EXPORT void obs_view_render(obs_view_t *view);

EXPORT uint64_t obs_get_video_frame_time(void);

EXPORT double obs_get_active_fps(void);
EXPORT uint64_t obs_get_average_frame_time_ns(void);

EXPORT uint32_t obs_get_total_frames(void);
EXPORT uint32_t obs_get_lagged_frames(void);






EXPORT obs_display_t *obs_display_create(
		const struct gs_init_data *graphics_data);


EXPORT void obs_display_destroy(obs_display_t *display);


EXPORT void obs_display_resize(obs_display_t *display, uint32_t cx,
		uint32_t cy);


EXPORT void obs_display_add_draw_callback(obs_display_t *display,
		void (*draw)(void *param, uint32_t cx, uint32_t cy),
		void *param);


EXPORT void obs_display_remove_draw_callback(obs_display_t *display,
		void (*draw)(void *param, uint32_t cx, uint32_t cy),
		void *param);

EXPORT void obs_display_set_enabled(obs_display_t *display, bool enable);
EXPORT bool obs_display_enabled(obs_display_t *display);

EXPORT void obs_display_set_background_color(obs_display_t *display,
		uint32_t color);






EXPORT const char *obs_source_get_display_name(const char *id);


EXPORT obs_source_t *obs_source_create(const char *id, const char *name,
		obs_data_t *settings, obs_data_t *hotkey_data);

EXPORT obs_source_t *obs_source_create_private(const char *id,
		const char *name, obs_data_t *settings);


EXPORT obs_source_t *obs_source_duplicate(obs_source_t *source,
		const char *desired_name, bool create_private);

EXPORT void obs_source_addref(obs_source_t *source);
EXPORT void obs_source_release(obs_source_t *source);

EXPORT void obs_weak_source_addref(obs_weak_source_t *weak);
EXPORT void obs_weak_source_release(obs_weak_source_t *weak);

EXPORT obs_source_t *obs_source_get_ref(obs_source_t *source);
EXPORT obs_weak_source_t *obs_source_get_weak_source(obs_source_t *source);
EXPORT obs_source_t *obs_weak_source_get_source(obs_weak_source_t *weak);

EXPORT bool obs_weak_source_references_source(obs_weak_source_t *weak,
		obs_source_t *source);


EXPORT void obs_source_remove(obs_source_t *source);


EXPORT bool obs_source_removed(const obs_source_t *source);


EXPORT uint32_t obs_source_get_output_flags(const obs_source_t *source);


EXPORT uint32_t obs_get_source_output_flags(const char *id);


EXPORT obs_data_t *obs_get_source_defaults(const char *id);


EXPORT obs_properties_t *obs_get_source_properties(const char *id);


EXPORT bool obs_is_source_configurable(const char *id);

EXPORT bool obs_source_configurable(const obs_source_t *source);


EXPORT obs_properties_t *obs_source_properties(const obs_source_t *source);


EXPORT void obs_source_update(obs_source_t *source, obs_data_t *settings);


EXPORT void obs_source_video_render(obs_source_t *source);


EXPORT uint32_t obs_source_get_width(obs_source_t *source);


EXPORT uint32_t obs_source_get_height(obs_source_t *source);


EXPORT obs_source_t *obs_filter_get_parent(const obs_source_t *filter);


EXPORT obs_source_t *obs_filter_get_target(const obs_source_t *filter);


EXPORT void obs_source_default_render(obs_source_t *source);


EXPORT void obs_source_filter_add(obs_source_t *source, obs_source_t *filter);


EXPORT void obs_source_filter_remove(obs_source_t *source,
		obs_source_t *filter);


EXPORT void obs_source_filter_set_order(obs_source_t *source,
		obs_source_t *filter, enum obs_order_movement movement);


EXPORT obs_data_t *obs_source_get_settings(const obs_source_t *source);


EXPORT const char *obs_source_get_name(const obs_source_t *source);


EXPORT void obs_source_set_name(obs_source_t *source, const char *name);


EXPORT enum obs_source_type obs_source_get_type(const obs_source_t *source);


EXPORT const char *obs_source_get_id(const obs_source_t *source);


EXPORT signal_handler_t *obs_source_get_signal_handler(
		const obs_source_t *source);


EXPORT proc_handler_t *obs_source_get_proc_handler(const obs_source_t *source);


EXPORT void obs_source_set_volume(obs_source_t *source, float volume);


EXPORT float obs_source_get_volume(const obs_source_t *source);


EXPORT void obs_source_set_sync_offset(obs_source_t *source, int64_t offset);


EXPORT int64_t obs_source_get_sync_offset(const obs_source_t *source);


EXPORT void obs_source_enum_active_sources(obs_source_t *source,
		obs_source_enum_proc_t enum_callback,
		void *param);


EXPORT void obs_source_enum_active_tree(obs_source_t *source,
		obs_source_enum_proc_t enum_callback,
		void *param);


EXPORT bool obs_source_active(const obs_source_t *source);


EXPORT bool obs_source_showing(const obs_source_t *source);


#define OBS_SOURCE_FLAG_UNUSED_1               (1<<0)

#define OBS_SOURCE_FLAG_FORCE_MONO             (1<<1)


EXPORT void obs_source_set_flags(obs_source_t *source, uint32_t flags);


EXPORT uint32_t obs_source_get_flags(const obs_source_t *source);


EXPORT void obs_source_set_audio_mixers(obs_source_t *source, uint32_t mixers);


EXPORT uint32_t obs_source_get_audio_mixers(const obs_source_t *source);


EXPORT void obs_source_inc_showing(obs_source_t *source);


EXPORT void obs_source_dec_showing(obs_source_t *source);


EXPORT void obs_source_enum_filters(obs_source_t *source,
		obs_source_enum_proc_t callback, void *param);


EXPORT obs_source_t *obs_source_get_filter_by_name(obs_source_t *source,
		const char *name);

EXPORT void obs_source_copy_filters(obs_source_t *dst, obs_source_t *src);

EXPORT bool obs_source_enabled(const obs_source_t *source);
EXPORT void obs_source_set_enabled(obs_source_t *source, bool enabled);

EXPORT bool obs_source_muted(const obs_source_t *source);
EXPORT void obs_source_set_muted(obs_source_t *source, bool muted);

EXPORT bool obs_source_push_to_mute_enabled(obs_source_t *source);
EXPORT void obs_source_enable_push_to_mute(obs_source_t *source, bool enabled);

EXPORT uint64_t obs_source_get_push_to_mute_delay(obs_source_t *source);
EXPORT void obs_source_set_push_to_mute_delay(obs_source_t *source,
		uint64_t delay);

EXPORT bool obs_source_push_to_talk_enabled(obs_source_t *source);
EXPORT void obs_source_enable_push_to_talk(obs_source_t *source, bool enabled);

EXPORT uint64_t obs_source_get_push_to_talk_delay(obs_source_t *source);
EXPORT void obs_source_set_push_to_talk_delay(obs_source_t *source,
		uint64_t delay);

typedef void (*obs_source_audio_capture_t)(void *param, obs_source_t *source,
		const struct audio_data *audio_data, bool muted);

EXPORT void obs_source_add_audio_capture_callback(obs_source_t *source,
		obs_source_audio_capture_t callback, void *param);
EXPORT void obs_source_remove_audio_capture_callback(obs_source_t *source,
		obs_source_audio_capture_t callback, void *param);

enum obs_deinterlace_mode {
	OBS_DEINTERLACE_MODE_DISABLE,
	OBS_DEINTERLACE_MODE_DISCARD,
	OBS_DEINTERLACE_MODE_RETRO,
	OBS_DEINTERLACE_MODE_BLEND,
	OBS_DEINTERLACE_MODE_BLEND_2X,
	OBS_DEINTERLACE_MODE_LINEAR,
	OBS_DEINTERLACE_MODE_LINEAR_2X,
	OBS_DEINTERLACE_MODE_YADIF,
	OBS_DEINTERLACE_MODE_YADIF_2X
};

enum obs_deinterlace_field_order {
	OBS_DEINTERLACE_FIELD_ORDER_TOP,
	OBS_DEINTERLACE_FIELD_ORDER_BOTTOM
};

EXPORT void obs_source_set_deinterlace_mode(obs_source_t *source,
		enum obs_deinterlace_mode mode);
EXPORT enum obs_deinterlace_mode obs_source_get_deinterlace_mode(
		const obs_source_t *source);
EXPORT void obs_source_set_deinterlace_field_order(obs_source_t *source,
		enum obs_deinterlace_field_order field_order);
EXPORT enum obs_deinterlace_field_order obs_source_get_deinterlace_field_order(
		const obs_source_t *source);

enum obs_monitoring_type {
	OBS_MONITORING_TYPE_NONE,
	OBS_MONITORING_TYPE_MONITOR_ONLY,
	OBS_MONITORING_TYPE_MONITOR_AND_OUTPUT
};

EXPORT void obs_source_set_monitoring_type(obs_source_t *source,
		enum obs_monitoring_type type);
EXPORT enum obs_monitoring_type obs_source_get_monitoring_type(
		const obs_source_t *source);


EXPORT obs_data_t *obs_source_get_private_settings(obs_source_t *item);




EXPORT void *obs_source_get_type_data(obs_source_t *source);


EXPORT void obs_source_draw_set_color_matrix(
		const struct matrix4 *color_matrix,
		const struct vec3 *color_range_min,
		const struct vec3 *color_range_max);


EXPORT void obs_source_draw(gs_texture_t *image, int x, int y,
		uint32_t cx, uint32_t cy, bool flip);


EXPORT void obs_source_output_video(obs_source_t *source,
		const struct obs_source_frame *frame);


EXPORT void obs_source_preload_video(obs_source_t *source,
		const struct obs_source_frame *frame);


EXPORT void obs_source_show_preloaded_video(obs_source_t *source);


EXPORT void obs_source_output_audio(obs_source_t *source,
		const struct obs_source_audio *audio);


EXPORT void obs_source_update_properties(obs_source_t *source);


EXPORT struct obs_source_frame *obs_source_get_frame(obs_source_t *source);


EXPORT void obs_source_release_frame(obs_source_t *source,
		struct obs_source_frame *frame);


EXPORT bool obs_source_process_filter_begin(obs_source_t *filter,
		enum gs_color_format format,
		enum obs_allow_direct_render allow_direct);


EXPORT void obs_source_process_filter_end(obs_source_t *filter,
		gs_effect_t *effect, uint32_t width, uint32_t height);


EXPORT void obs_source_process_filter_tech_end(obs_source_t *filter,
		gs_effect_t *effect, uint32_t width, uint32_t height,
		const char *tech_name);


EXPORT void obs_source_skip_video_filter(obs_source_t *filter);


EXPORT bool obs_source_add_active_child(obs_source_t *parent,
		obs_source_t *child);


EXPORT void obs_source_remove_active_child(obs_source_t *parent,
		obs_source_t *child);


EXPORT void obs_source_send_mouse_click(obs_source_t *source,
		const struct obs_mouse_event *event,
		int32_t type, bool mouse_up,
		uint32_t click_count);


EXPORT void obs_source_send_mouse_move(obs_source_t *source,
		const struct obs_mouse_event *event, bool mouse_leave);


EXPORT void obs_source_send_mouse_wheel(obs_source_t *source,
		const struct obs_mouse_event *event, int x_delta, int y_delta);


EXPORT void obs_source_send_focus(obs_source_t *source, bool focus);


EXPORT void obs_source_send_key_click(obs_source_t *source,
		const struct obs_key_event *event, bool key_up);


EXPORT void obs_source_set_default_flags(obs_source_t *source, uint32_t flags);


EXPORT uint32_t obs_source_get_base_width(obs_source_t *source);


EXPORT uint32_t obs_source_get_base_height(obs_source_t *source);

EXPORT bool obs_source_audio_pending(const obs_source_t *source);
EXPORT uint64_t obs_source_get_audio_timestamp(const obs_source_t *source);
EXPORT void obs_source_get_audio_mix(const obs_source_t *source,
		struct obs_source_audio_mix *audio);

EXPORT void obs_source_set_async_unbuffered(obs_source_t *source,
		bool unbuffered);
EXPORT bool obs_source_async_unbuffered(const obs_source_t *source);


EXPORT void obs_source_set_async_decoupled(obs_source_t *source, bool decouple);
EXPORT bool obs_source_async_decoupled(const obs_source_t *source);



enum obs_transition_target {
	OBS_TRANSITION_SOURCE_A,
	OBS_TRANSITION_SOURCE_B
};

EXPORT obs_source_t *obs_transition_get_source(obs_source_t *transition,
		enum obs_transition_target target);
EXPORT void obs_transition_clear(obs_source_t *transition);

EXPORT obs_source_t *obs_transition_get_active_source(obs_source_t *transition);

enum obs_transition_mode {
	OBS_TRANSITION_MODE_AUTO,
};

EXPORT bool obs_transition_start(obs_source_t *transition,
		enum obs_transition_mode mode, uint32_t duration_ms,
		obs_source_t *dest);

EXPORT void obs_transition_set(obs_source_t *transition, obs_source_t *source);

enum obs_transition_scale_type {
	OBS_TRANSITION_SCALE_MAX_ONLY,
	OBS_TRANSITION_SCALE_ASPECT,
	OBS_TRANSITION_SCALE_STRETCH,
};

EXPORT void obs_transition_set_scale_type(obs_source_t *transition,
		enum obs_transition_scale_type type);
EXPORT enum obs_transition_scale_type obs_transition_get_scale_type(
		const obs_source_t *transition);

EXPORT void obs_transition_set_alignment(obs_source_t *transition,
		uint32_t alignment);
EXPORT uint32_t obs_transition_get_alignment(const obs_source_t *transition);

EXPORT void obs_transition_set_size(obs_source_t *transition,
		uint32_t cx, uint32_t cy);
EXPORT void obs_transition_get_size(const obs_source_t *transition,
		uint32_t *cx, uint32_t *cy);




EXPORT void obs_transition_enable_fixed(obs_source_t *transition, bool enable,
		uint32_t duration_ms);
EXPORT bool obs_transition_fixed(obs_source_t *transition);

typedef void (*obs_transition_video_render_callback_t)(void *data,
		gs_texture_t *a, gs_texture_t *b, float t,
		uint32_t cx, uint32_t cy);
typedef float (*obs_transition_audio_mix_callback_t)(void *data, float t);

EXPORT float obs_transition_get_time(obs_source_t *transition);

EXPORT void obs_transition_video_render(obs_source_t *transition,
		obs_transition_video_render_callback_t callback);


EXPORT bool obs_transition_video_render_direct(obs_source_t *transition,
		enum obs_transition_target target);

EXPORT bool obs_transition_audio_render(obs_source_t *transition,
		uint64_t *ts_out, struct obs_source_audio_mix *audio,
		uint32_t mixers, size_t channels, size_t sample_rate,
		obs_transition_audio_mix_callback_t mix_a_callback,
		obs_transition_audio_mix_callback_t mix_b_callback);


EXPORT void obs_transition_swap_begin(obs_source_t *tr_dest,
		obs_source_t *tr_source);
EXPORT void obs_transition_swap_end(obs_source_t *tr_dest,
		obs_source_t *tr_source);






EXPORT obs_scene_t *obs_scene_create(const char *name);

EXPORT obs_scene_t *obs_scene_create_private(const char *name);

enum obs_scene_duplicate_type {
	OBS_SCENE_DUP_REFS,         
	OBS_SCENE_DUP_COPY,         
	OBS_SCENE_DUP_PRIVATE_REFS, 
	OBS_SCENE_DUP_PRIVATE_COPY  
};


EXPORT obs_scene_t *obs_scene_duplicate(obs_scene_t *scene, const char *name,
		enum obs_scene_duplicate_type type);

EXPORT void        obs_scene_addref(obs_scene_t *scene);
EXPORT void        obs_scene_release(obs_scene_t *scene);


EXPORT obs_source_t *obs_scene_get_source(const obs_scene_t *scene);


EXPORT obs_scene_t *obs_scene_from_source(const obs_source_t *source);


EXPORT obs_sceneitem_t *obs_scene_find_source(obs_scene_t *scene,
		const char *name);

EXPORT obs_sceneitem_t *obs_scene_find_sceneitem_by_id(obs_scene_t *scene,
		int64_t id);


EXPORT void obs_scene_enum_items(obs_scene_t *scene,
		bool (*callback)(obs_scene_t*, obs_sceneitem_t*, void*),
		void *param);

EXPORT bool obs_scene_reorder_items(obs_scene_t *scene,
		obs_sceneitem_t * const *item_order, size_t item_order_size);


EXPORT obs_sceneitem_t *obs_scene_add(obs_scene_t *scene, obs_source_t *source);

typedef void (*obs_scene_atomic_update_func)(void *, obs_scene_t *scene);
EXPORT void obs_scene_atomic_update(obs_scene_t *scene,
		obs_scene_atomic_update_func func, void *data);

EXPORT void obs_sceneitem_addref(obs_sceneitem_t *item);
EXPORT void obs_sceneitem_release(obs_sceneitem_t *item);


EXPORT void obs_sceneitem_remove(obs_sceneitem_t *item);


EXPORT obs_scene_t *obs_sceneitem_get_scene(const obs_sceneitem_t *item);


EXPORT obs_source_t *obs_sceneitem_get_source(const obs_sceneitem_t *item);


EXPORT void obs_sceneitem_select(obs_sceneitem_t *item, bool select);
EXPORT bool obs_sceneitem_selected(const obs_sceneitem_t *item);
EXPORT bool obs_sceneitem_locked(const obs_sceneitem_t *item);
EXPORT bool obs_sceneitem_set_locked(obs_sceneitem_t *item, bool lock);


EXPORT void obs_sceneitem_set_pos(obs_sceneitem_t *item, const struct vec2 *pos);
EXPORT void obs_sceneitem_set_rot(obs_sceneitem_t *item, float rot_deg);
EXPORT void obs_sceneitem_set_scale(obs_sceneitem_t *item,
		const struct vec2 *scale);
EXPORT void obs_sceneitem_set_alignment(obs_sceneitem_t *item,
		uint32_t alignment);
EXPORT void obs_sceneitem_set_order(obs_sceneitem_t *item,
		enum obs_order_movement movement);
EXPORT void obs_sceneitem_set_order_position(obs_sceneitem_t *item,
		int position);
EXPORT void obs_sceneitem_set_bounds_type(obs_sceneitem_t *item,
		enum obs_bounds_type type);
EXPORT void obs_sceneitem_set_bounds_alignment(obs_sceneitem_t *item,
		uint32_t alignment);
EXPORT void obs_sceneitem_set_bounds(obs_sceneitem_t *item,
		const struct vec2 *bounds);

EXPORT int64_t obs_sceneitem_get_id(const obs_sceneitem_t *item);

EXPORT void  obs_sceneitem_get_pos(const obs_sceneitem_t *item,
		struct vec2 *pos);
EXPORT float obs_sceneitem_get_rot(const obs_sceneitem_t *item);
EXPORT void  obs_sceneitem_get_scale(const obs_sceneitem_t *item,
		struct vec2 *scale);
EXPORT uint32_t obs_sceneitem_get_alignment(const obs_sceneitem_t *item);

EXPORT enum obs_bounds_type obs_sceneitem_get_bounds_type(
		const obs_sceneitem_t *item);
EXPORT uint32_t obs_sceneitem_get_bounds_alignment(const obs_sceneitem_t *item);
EXPORT void obs_sceneitem_get_bounds(const obs_sceneitem_t *item,
		struct vec2 *bounds);

EXPORT void obs_sceneitem_get_info(const obs_sceneitem_t *item,
		struct obs_transform_info *info);
EXPORT void obs_sceneitem_set_info(obs_sceneitem_t *item,
		const struct obs_transform_info *info);

EXPORT void obs_sceneitem_get_draw_transform(const obs_sceneitem_t *item,
		struct matrix4 *transform);
EXPORT void obs_sceneitem_get_box_transform(const obs_sceneitem_t *item,
		struct matrix4 *transform);

EXPORT bool obs_sceneitem_visible(const obs_sceneitem_t *item);
EXPORT bool obs_sceneitem_set_visible(obs_sceneitem_t *item, bool visible);

struct obs_sceneitem_crop {
	int left;
	int top;
	int right;
	int bottom;
};

EXPORT void obs_sceneitem_set_crop(obs_sceneitem_t *item,
		const struct obs_sceneitem_crop *crop);
EXPORT void obs_sceneitem_get_crop(const obs_sceneitem_t *item,
		struct obs_sceneitem_crop *crop);

EXPORT void obs_sceneitem_set_scale_filter(obs_sceneitem_t *item,
		enum obs_scale_type filter);
EXPORT enum obs_scale_type obs_sceneitem_get_scale_filter(
		obs_sceneitem_t *item);

EXPORT void obs_sceneitem_defer_update_begin(obs_sceneitem_t *item);
EXPORT void obs_sceneitem_defer_update_end(obs_sceneitem_t *item);


EXPORT obs_data_t *obs_sceneitem_get_private_settings(obs_sceneitem_t *item);





EXPORT const char *obs_output_get_display_name(const char *id);


EXPORT obs_output_t *obs_output_create(const char *id, const char *name,
		obs_data_t *settings, obs_data_t *hotkey_data);


EXPORT void obs_output_addref(obs_output_t *output);
EXPORT void obs_output_release(obs_output_t *output);

EXPORT void obs_weak_output_addref(obs_weak_output_t *weak);
EXPORT void obs_weak_output_release(obs_weak_output_t *weak);

EXPORT obs_output_t *obs_output_get_ref(obs_output_t *output);
EXPORT obs_weak_output_t *obs_output_get_weak_output(obs_output_t *output);
EXPORT obs_output_t *obs_weak_output_get_output(obs_weak_output_t *weak);

EXPORT bool obs_weak_output_references_output(obs_weak_output_t *weak,
		obs_output_t *output);

EXPORT const char *obs_output_get_name(const obs_output_t *output);


EXPORT bool obs_output_start(obs_output_t *output);


EXPORT void obs_output_stop(obs_output_t *output);


#define OBS_OUTPUT_DELAY_PRESERVE (1<<0)


EXPORT void obs_output_set_delay(obs_output_t *output, uint32_t delay_sec,
		uint32_t flags);


EXPORT uint32_t obs_output_get_delay(const obs_output_t *output);


EXPORT uint32_t obs_output_get_active_delay(const obs_output_t *output);


EXPORT void obs_output_force_stop(obs_output_t *output);


EXPORT bool obs_output_active(const obs_output_t *output);


EXPORT obs_data_t *obs_output_defaults(const char *id);


EXPORT obs_properties_t *obs_get_output_properties(const char *id);


EXPORT obs_properties_t *obs_output_properties(const obs_output_t *output);


EXPORT void obs_output_update(obs_output_t *output, obs_data_t *settings);


EXPORT bool obs_output_can_pause(const obs_output_t *output);


EXPORT void obs_output_pause(obs_output_t *output);


EXPORT obs_data_t *obs_output_get_settings(const obs_output_t *output);


EXPORT signal_handler_t *obs_output_get_signal_handler(
		const obs_output_t *output);


EXPORT proc_handler_t *obs_output_get_proc_handler(const obs_output_t *output);


EXPORT void obs_output_set_media(obs_output_t *output,
		video_t *video, audio_t *audio);


EXPORT video_t *obs_output_video(const obs_output_t *output);


EXPORT audio_t *obs_output_audio(const obs_output_t *output);


EXPORT void obs_output_set_mixer(obs_output_t *output, size_t mixer_idx);


EXPORT size_t obs_output_get_mixer(const obs_output_t *output);


EXPORT void obs_output_set_video_encoder(obs_output_t *output,
		obs_encoder_t *encoder);


EXPORT void obs_output_set_audio_encoder(obs_output_t *output,
		obs_encoder_t *encoder, size_t idx);


EXPORT obs_encoder_t *obs_output_get_video_encoder(const obs_output_t *output);


EXPORT obs_encoder_t *obs_output_get_audio_encoder(const obs_output_t *output,
		size_t idx);


EXPORT void obs_output_set_service(obs_output_t *output,
		obs_service_t *service);


EXPORT obs_service_t *obs_output_get_service(const obs_output_t *output);


EXPORT void obs_output_set_reconnect_settings(obs_output_t *output,
		int retry_count, int retry_sec);

EXPORT uint64_t obs_output_get_total_bytes(const obs_output_t *output);
EXPORT int obs_output_get_frames_dropped(const obs_output_t *output);
EXPORT int obs_output_get_total_frames(const obs_output_t *output);


EXPORT void obs_output_set_preferred_size(obs_output_t *output, uint32_t width,
		uint32_t height);


EXPORT uint32_t obs_output_get_width(const obs_output_t *output);


EXPORT uint32_t obs_output_get_height(const obs_output_t *output);

EXPORT const char *obs_output_get_id(const obs_output_t *output);

#if BUILD_CAPTIONS
EXPORT void obs_output_output_caption_text1(obs_output_t *output,
		const char *text);
#endif

EXPORT float obs_output_get_congestion(obs_output_t *output);
EXPORT int obs_output_get_connect_time_ms(obs_output_t *output);

EXPORT bool obs_output_reconnecting(const obs_output_t *output);


EXPORT void obs_output_set_last_error(obs_output_t *output,
		const char *message);
EXPORT const char *obs_output_get_last_error(obs_output_t *output);

EXPORT const char *obs_output_get_supported_video_codecs(
		const obs_output_t *output);
EXPORT const char *obs_output_get_supported_audio_codecs(
		const obs_output_t *output);




EXPORT void *obs_output_get_type_data(obs_output_t *output);


EXPORT void obs_output_set_video_conversion(obs_output_t *output,
		const struct video_scale_info *conversion);


EXPORT void obs_output_set_audio_conversion(obs_output_t *output,
		const struct audio_convert_info *conversion);


EXPORT bool obs_output_can_begin_data_capture(const obs_output_t *output,
		uint32_t flags);


EXPORT bool obs_output_initialize_encoders(obs_output_t *output,
		uint32_t flags);


EXPORT bool obs_output_begin_data_capture(obs_output_t *output, uint32_t flags);


EXPORT void obs_output_end_data_capture(obs_output_t *output);


EXPORT void obs_output_signal_stop(obs_output_t *output, int code);





EXPORT const char *obs_encoder_get_display_name(const char *id);


EXPORT obs_encoder_t *obs_video_encoder_create(const char *id, const char *name,
		obs_data_t *settings, obs_data_t *hotkey_data);


EXPORT obs_encoder_t *obs_audio_encoder_create(const char *id, const char *name,
		obs_data_t *settings, size_t mixer_idx,
		obs_data_t *hotkey_data);


EXPORT void obs_encoder_addref(obs_encoder_t *encoder);
EXPORT void obs_encoder_release(obs_encoder_t *encoder);

EXPORT void obs_weak_encoder_addref(obs_weak_encoder_t *weak);
EXPORT void obs_weak_encoder_release(obs_weak_encoder_t *weak);

EXPORT obs_encoder_t *obs_encoder_get_ref(obs_encoder_t *encoder);
EXPORT obs_weak_encoder_t *obs_encoder_get_weak_encoder(obs_encoder_t *encoder);
EXPORT obs_encoder_t *obs_weak_encoder_get_encoder(obs_weak_encoder_t *weak);

EXPORT bool obs_weak_encoder_references_encoder(obs_weak_encoder_t *weak,
		obs_encoder_t *encoder);

EXPORT void obs_encoder_set_name(obs_encoder_t *encoder, const char *name);
EXPORT const char *obs_encoder_get_name(const obs_encoder_t *encoder);


EXPORT const char *obs_get_encoder_codec(const char *id);


EXPORT enum obs_encoder_type obs_get_encoder_type(const char *id);


EXPORT const char *obs_encoder_get_codec(const obs_encoder_t *encoder);


EXPORT enum obs_encoder_type obs_encoder_get_type(const obs_encoder_t *encoder);


EXPORT void obs_encoder_set_scaled_size(obs_encoder_t *encoder, uint32_t width,
		uint32_t height);


EXPORT uint32_t obs_encoder_get_width(const obs_encoder_t *encoder);


EXPORT uint32_t obs_encoder_get_height(const obs_encoder_t *encoder);


EXPORT uint32_t obs_encoder_get_sample_rate(const obs_encoder_t *encoder);


EXPORT void obs_encoder_set_preferred_video_format(obs_encoder_t *encoder,
		enum video_format format);
EXPORT enum video_format obs_encoder_get_preferred_video_format(
		const obs_encoder_t *encoder);


EXPORT obs_data_t *obs_encoder_defaults(const char *id);


EXPORT obs_properties_t *obs_get_encoder_properties(const char *id);


EXPORT obs_properties_t *obs_encoder_properties(const obs_encoder_t *encoder);


EXPORT void obs_encoder_update(obs_encoder_t *encoder, obs_data_t *settings);


EXPORT bool obs_encoder_get_extra_data(const obs_encoder_t *encoder,
		uint8_t **extra_data, size_t *size);


EXPORT obs_data_t *obs_encoder_get_settings(const obs_encoder_t *encoder);


EXPORT void obs_encoder_set_video(obs_encoder_t *encoder, video_t *video);


EXPORT void obs_encoder_set_audio(obs_encoder_t *encoder, audio_t *audio);


EXPORT video_t *obs_encoder_video(const obs_encoder_t *encoder);


EXPORT audio_t *obs_encoder_audio(const obs_encoder_t *encoder);


EXPORT bool obs_encoder_active(const obs_encoder_t *encoder);

EXPORT void *obs_encoder_get_type_data(obs_encoder_t *encoder);

EXPORT const char *obs_encoder_get_id(const obs_encoder_t *encoder);

EXPORT uint32_t obs_get_encoder_caps(const char *encoder_id);

#ifndef SWIG

DEPRECATED
EXPORT void obs_duplicate_encoder_packet(struct encoder_packet *dst,
		const struct encoder_packet *src);

DEPRECATED
EXPORT void obs_free_encoder_packet(struct encoder_packet *packet);
#endif

EXPORT void obs_encoder_packet_ref(struct encoder_packet *dst,
		struct encoder_packet *src);
EXPORT void obs_encoder_packet_release(struct encoder_packet *packet);





EXPORT const char *obs_service_get_display_name(const char *id);

EXPORT obs_service_t *obs_service_create(const char *id, const char *name,
		obs_data_t *settings, obs_data_t *hotkey_data);

EXPORT obs_service_t *obs_service_create_private(const char *id,
		const char *name, obs_data_t *settings);


EXPORT void obs_service_addref(obs_service_t *service);
EXPORT void obs_service_release(obs_service_t *service);

EXPORT void obs_weak_service_addref(obs_weak_service_t *weak);
EXPORT void obs_weak_service_release(obs_weak_service_t *weak);

EXPORT obs_service_t *obs_service_get_ref(obs_service_t *service);
EXPORT obs_weak_service_t *obs_service_get_weak_service(obs_service_t *service);
EXPORT obs_service_t *obs_weak_service_get_service(obs_weak_service_t *weak);

EXPORT bool obs_weak_service_references_service(obs_weak_service_t *weak,
		obs_service_t *service);

EXPORT const char *obs_service_get_name(const obs_service_t *service);


EXPORT obs_data_t *obs_service_defaults(const char *id);


EXPORT obs_properties_t *obs_get_service_properties(const char *id);


EXPORT obs_properties_t *obs_service_properties(const obs_service_t *service);


EXPORT const char *obs_service_get_type(const obs_service_t *service);


EXPORT void obs_service_update(obs_service_t *service, obs_data_t *settings);


EXPORT obs_data_t *obs_service_get_settings(const obs_service_t *service);


EXPORT const char *obs_service_get_url(const obs_service_t *service);


EXPORT const char *obs_service_get_key(const obs_service_t *service);


EXPORT const char *obs_service_get_username(const obs_service_t *service);


EXPORT const char *obs_service_get_password(const obs_service_t *service);


EXPORT void obs_service_apply_encoder_settings(obs_service_t *service,
		obs_data_t *video_encoder_settings,
		obs_data_t *audio_encoder_settings);

EXPORT void *obs_service_get_type_data(obs_service_t *service);

EXPORT const char *obs_service_get_id(const obs_service_t *service);


EXPORT const char *obs_service_get_output_type(const obs_service_t *service);




EXPORT void obs_source_frame_init(struct obs_source_frame *frame,
		enum video_format format, uint32_t width, uint32_t height);

static inline void obs_source_frame_free(struct obs_source_frame *frame)
{
	if (frame) {
		bfree(frame->data[0]);
		memset(frame, 0, sizeof(*frame));
	}
}

static inline struct obs_source_frame *obs_source_frame_create(
		enum video_format format, uint32_t width, uint32_t height)
{
	struct obs_source_frame *frame;

	frame = (struct obs_source_frame*)bzalloc(sizeof(*frame));
	obs_source_frame_init(frame, format, width, height);
	return frame;
}

static inline void obs_source_frame_destroy(struct obs_source_frame *frame)
{
	if (frame) {
		bfree(frame->data[0]);
		bfree(frame);
	}
}


#ifdef __cplusplus
}
#endif