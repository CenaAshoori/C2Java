

#include "util/bmem.h"
#include "util/darray.h"
#include "obs-internal.h"
#include "obs-properties.h"

static inline void *get_property_data(struct obs_property *prop);



struct float_data {
	double min, max, step;
	enum obs_number_type type;
};

struct int_data {
	int min, max, step;
	enum obs_number_type type;
};

struct list_item {
	char *name;
	bool disabled;

	union {
		char      *str;
		long long ll;
		double    d;
	};
};

struct path_data {
	char               *filter;
	char               *default_path;
	enum obs_path_type type;
};

struct text_data {
	enum obs_text_type type;
};

struct list_data {
	DARRAY(struct list_item) items;
	enum obs_combo_type      type;
	enum obs_combo_format    format;
};

struct editable_list_data {
	enum obs_editable_list_type type;
	char                        *filter;
	char                        *default_path;
};

struct button_data {
	obs_property_clicked_t callback;
};

struct frame_rate_option {
	char *name;
	char *description;
};

struct frame_rate_range {
	struct media_frames_per_second min_time;
	struct media_frames_per_second max_time;
};

struct frame_rate_data {
	DARRAY(struct frame_rate_option) extra_options;
	DARRAY(struct frame_rate_range)  ranges;
};

static inline void path_data_free(struct path_data *data)
{
	bfree(data->default_path);
	if (data->type == OBS_PATH_FILE)
		bfree(data->filter);
}

static inline void editable_list_data_free(struct editable_list_data *data)
{
	bfree(data->default_path);
	bfree(data->filter);
}

static inline void list_item_free(struct list_data *data,
		struct list_item *item)
{
	bfree(item->name);
	if (data->format == OBS_COMBO_FORMAT_STRING)
		bfree(item->str);
}

static inline void list_data_free(struct list_data *data)
{
	for (size_t i = 0; i < data->items.num; i++)
		list_item_free(data, data->items.array+i);

	da_free(data->items);
}

static inline void frame_rate_data_options_free(struct frame_rate_data *data)
{
	for (size_t i = 0; i < data->extra_options.num; i++) {
		struct frame_rate_option *opt = &data->extra_options.array[i];
		bfree(opt->name);
		bfree(opt->description);
	}

	da_resize(data->extra_options, 0);
}

static inline void frame_rate_data_ranges_free(struct frame_rate_data *data)
{
	da_resize(data->ranges, 0);
}

static inline void frame_rate_data_free(struct frame_rate_data *data)
{
	frame_rate_data_options_free(data);
	frame_rate_data_ranges_free(data);

	da_free(data->extra_options);
	da_free(data->ranges);
}

struct obs_properties;

struct obs_property {
	char                    *name;
	char                    *desc;
	char                    *long_desc;
	void                    *priv;
	enum obs_property_type  type;
	bool                    visible;
	bool                    enabled;

	struct obs_properties   *parent;

	obs_property_modified_t modified;
	obs_property_modified2_t modified2;

	struct obs_property     *next;
};

struct obs_properties {
	void                    *param;
	void                    (*destroy)(void *param);
	uint32_t                flags;

	struct obs_property     *first_property;
	struct obs_property     **last;
};

obs_properties_t *obs_properties_create(void)
{
	struct obs_properties *props;
	props = bzalloc(sizeof(struct obs_properties));
	props->last = &props->first_property;
	return props;
}

void obs_properties_set_param(obs_properties_t *props,
		void *param, void (*destroy)(void *param))
{
	if (!props)
		return;

	if (props->param && props->destroy)
		props->destroy(props->param);

	props->param   = param;
	props->destroy = destroy;
}

void obs_properties_set_flags(obs_properties_t *props, uint32_t flags)
{
	if (props)
		props->flags = flags;
}

uint32_t obs_properties_get_flags(obs_properties_t *props)
{
	return props ? props->flags : 0;
}

void *obs_properties_get_param(obs_properties_t *props)
{
	return props ? props->param : NULL;
}

obs_properties_t *obs_properties_create_param(void *param,
		void (*destroy)(void *param))
{
	struct obs_properties *props = obs_properties_create();
	obs_properties_set_param(props, param, destroy);
	return props;
}

static void obs_property_destroy(struct obs_property *property)
{
	if (property->type == OBS_PROPERTY_LIST)
		list_data_free(get_property_data(property));
	else if (property->type == OBS_PROPERTY_PATH)
		path_data_free(get_property_data(property));
	else if (property->type == OBS_PROPERTY_EDITABLE_LIST)
		editable_list_data_free(get_property_data(property));
	else if (property->type == OBS_PROPERTY_FRAME_RATE)
		frame_rate_data_free(get_property_data(property));

	bfree(property->name);
	bfree(property->desc);
	bfree(property->long_desc);
	bfree(property);
}

void obs_properties_destroy(obs_properties_t *props)
{
	if (props) {
		struct obs_property *p = props->first_property;

		if (props->destroy && props->param)
			props->destroy(props->param);

		while (p) {
			struct obs_property *next = p->next;
			obs_property_destroy(p);
			p = next;
		}

		bfree(props);
	}
}

obs_property_t *obs_properties_first(obs_properties_t *props)
{
	return (props != NULL) ? props->first_property : NULL;
}

obs_property_t *obs_properties_get(obs_properties_t *props, const char *name)
{
	struct obs_property *property;

	if (!props)
		return NULL;

	property = props->first_property;
	while (property) {
		if (strcmp(property->name, name) == 0)
			return property;

		property = property->next;
	}

	return NULL;
}

void obs_properties_apply_settings(obs_properties_t *props, obs_data_t *settings)
{
	struct obs_property *p;

	if (!props)
		return;
	
	p = props->first_property;
	while (p) {
		if (p->modified)
			p->modified(props, p, settings);
		else if (p->modified2)
			p->modified2(p->priv, props, p, settings);
		p = p->next;
	}
}



static inline void propertes_add(struct obs_properties *props,
		struct obs_property *p)
{
	*props->last = p;
	props->last = &p->next;
}

static inline size_t get_property_size(enum obs_property_type type)
{
	switch (type) {
	case OBS_PROPERTY_INVALID:   return 0;
	case OBS_PROPERTY_BOOL:      return 0;
	case OBS_PROPERTY_INT:       return sizeof(struct int_data);
	case OBS_PROPERTY_FLOAT:     return sizeof(struct float_data);
	case OBS_PROPERTY_TEXT:      return sizeof(struct text_data);
	case OBS_PROPERTY_PATH:      return sizeof(struct path_data);
	case OBS_PROPERTY_LIST:      return sizeof(struct list_data);
	case OBS_PROPERTY_COLOR:     return 0;
	case OBS_PROPERTY_BUTTON:    return sizeof(struct button_data);
	case OBS_PROPERTY_FONT:      return 0;
	case OBS_PROPERTY_EDITABLE_LIST:
		return sizeof(struct editable_list_data);
	case OBS_PROPERTY_FRAME_RATE:return sizeof(struct frame_rate_data);
	}

	return 0;
}

static inline struct obs_property *new_prop(struct obs_properties *props,
		const char *name, const char *desc,
		enum obs_property_type type)
{
	size_t data_size = get_property_size(type);
	struct obs_property *p;

	p = bzalloc(sizeof(struct obs_property) + data_size);
	p->parent  = props;
	p->enabled = true;
	p->visible = true;
	p->type    = type;
	p->name    = bstrdup(name);
	p->desc    = bstrdup(desc);
	propertes_add(props, p);

	return p;
}

static inline bool has_prop(struct obs_properties *props, const char *name)
{
	struct obs_property *p = props->first_property;

	while (p) {
		if (strcmp(p->name, name) == 0) {
			blog(LOG_WARNING, "Property '%s' exists", name);
			return true;
		}

		p = p->next;
	}

	return false;
}

static inline void *get_property_data(struct obs_property *prop)
{
	return (uint8_t*)prop + sizeof(struct obs_property);
}

static inline void *get_type_data(struct obs_property *prop,
		enum obs_property_type type)
{
	if (!prop || prop->type != type)
		return NULL;

	return get_property_data(prop);
}

obs_property_t *obs_properties_add_bool(obs_properties_t *props,
		const char *name, const char *desc)
{
	if (!props || has_prop(props, name)) return NULL;
	return new_prop(props, name, desc, OBS_PROPERTY_BOOL);
}

static obs_property_t *add_int(obs_properties_t *props,
		const char *name, const char *desc, int min, int max, int step,
		enum obs_number_type type)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc, OBS_PROPERTY_INT);
	struct int_data *data = get_property_data(p);
	data->min  = min;
	data->max  = max;
	data->step = step;
	data->type = type;
	return p;
}

static obs_property_t *add_flt(obs_properties_t *props,
		const char *name, const char *desc,
		double min, double max, double step,
		enum obs_number_type type)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc,
			OBS_PROPERTY_FLOAT);
	struct float_data *data = get_property_data(p);
	data->min  = min;
	data->max  = max;
	data->step = step;
	data->type = type;
	return p;
}

obs_property_t *obs_properties_add_int(obs_properties_t *props,
		const char *name, const char *desc, int min, int max, int step)
{
	return add_int(props, name, desc, min, max, step, OBS_NUMBER_SCROLLER);
}

obs_property_t *obs_properties_add_float(obs_properties_t *props,
		const char *name, const char *desc,
		double min, double max, double step)
{
	return add_flt(props, name, desc, min, max, step, OBS_NUMBER_SCROLLER);
}

obs_property_t *obs_properties_add_int_slider(obs_properties_t *props,
		const char *name, const char *desc, int min, int max, int step)
{
	return add_int(props, name, desc, min, max, step, OBS_NUMBER_SLIDER);
}

obs_property_t *obs_properties_add_float_slider(obs_properties_t *props,
		const char *name, const char *desc,
		double min, double max, double step)
{
	return add_flt(props, name, desc, min, max, step, OBS_NUMBER_SLIDER);
}

obs_property_t *obs_properties_add_text(obs_properties_t *props,
		const char *name, const char *desc, enum obs_text_type type)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc, OBS_PROPERTY_TEXT);
	struct text_data *data = get_property_data(p);
	data->type = type;
	return p;
}

obs_property_t *obs_properties_add_path(obs_properties_t *props,
		const char *name, const char *desc, enum obs_path_type type,
		const char *filter, const char *default_path)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc, OBS_PROPERTY_PATH);
	struct path_data *data = get_property_data(p);
	data->type         = type;
	data->default_path = bstrdup(default_path);

	if (data->type == OBS_PATH_FILE)
		data->filter = bstrdup(filter);

	return p;
}

obs_property_t *obs_properties_add_list(obs_properties_t *props,
		const char *name, const char *desc,
		enum obs_combo_type type,
		enum obs_combo_format format)
{
	if (!props || has_prop(props, name)) return NULL;

	if (type   == OBS_COMBO_TYPE_EDITABLE &&
	    format != OBS_COMBO_FORMAT_STRING) {
		blog(LOG_WARNING, "List '%s', error: Editable combo boxes "
		                  "must be of the 'string' type", name);
		return NULL;
	}

	struct obs_property *p = new_prop(props, name, desc, OBS_PROPERTY_LIST);
	struct list_data *data = get_property_data(p);
	data->format = format;
	data->type   = type;

	return p;
}

obs_property_t *obs_properties_add_color(obs_properties_t *props,
		const char *name, const char *desc)
{
	if (!props || has_prop(props, name)) return NULL;
	return new_prop(props, name, desc, OBS_PROPERTY_COLOR);
}

obs_property_t *obs_properties_add_button(obs_properties_t *props,
		const char *name, const char *text,
		obs_property_clicked_t callback)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, text,
			OBS_PROPERTY_BUTTON);
	struct button_data *data = get_property_data(p);
	data->callback = callback;
	return p;
}

obs_property_t *obs_properties_add_button2(obs_properties_t *props,
		const char *name, const char *text,
		obs_property_clicked_t callback, void *priv)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, text,
			OBS_PROPERTY_BUTTON);
	struct button_data *data = get_property_data(p);
	data->callback = callback;
	p->priv = priv;
	return p;
}

obs_property_t *obs_properties_add_font(obs_properties_t *props,
		const char *name, const char *desc)
{
	if (!props || has_prop(props, name)) return NULL;
	return new_prop(props, name, desc, OBS_PROPERTY_FONT);
}

obs_property_t *obs_properties_add_editable_list(obs_properties_t *props,
		const char *name, const char *desc,
		enum obs_editable_list_type type, const char *filter,
		const char *default_path)
{
	if (!props || has_prop(props, name)) return NULL;
	struct obs_property *p = new_prop(props, name, desc,
			OBS_PROPERTY_EDITABLE_LIST);

	struct editable_list_data *data = get_property_data(p);
	data->type = type;
	data->filter = bstrdup(filter);
	data->default_path = bstrdup(default_path);
	return p;
}

obs_property_t *obs_properties_add_frame_rate(obs_properties_t *props,
		const char *name, const char *desc)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc,
			OBS_PROPERTY_FRAME_RATE);

	struct frame_rate_data *data = get_property_data(p);
	da_init(data->extra_options);
	da_init(data->ranges);
	return p;
}



static inline bool is_combo(struct obs_property *p)
{
	return p->type == OBS_PROPERTY_LIST;
}

static inline struct list_data *get_list_data(struct obs_property *p)
{
	if (!p || !is_combo(p))
		return NULL;

	return get_property_data(p);
}

static inline struct list_data *get_list_fmt_data(struct obs_property *p,
		enum obs_combo_format format)
{
	struct list_data *data = get_list_data(p);
	return (data && data->format == format) ? data : NULL;
}



bool obs_property_next(obs_property_t **p)
{
	if (!p || !*p)
		return false;

	*p = (*p)->next;
	return *p != NULL;
}

void obs_property_set_modified_callback(obs_property_t *p,
		obs_property_modified_t modified)
{
	if (p) p->modified = modified;
}

void obs_property_set_modified_callback2(obs_property_t *p,
		obs_property_modified2_t modified2, void *priv)
{
	if (p) {
		p->modified2 = modified2;
		p->priv = priv;
	}
}

bool obs_property_modified(obs_property_t *p, obs_data_t *settings)
{
	if (p) {
		if (p->modified) {
			return p->modified(p->parent, p, settings);
		} else if (p->modified2) {
			return p->modified2(p->priv, p->parent, p, settings);
		}
	}
	return false;
}

bool obs_property_button_clicked(obs_property_t *p, void *obj)
{
	struct obs_context_data *context = obj;
	if (p) {
		struct button_data *data = get_type_data(p,
				OBS_PROPERTY_BUTTON);
		if (data && data->callback) {
			if (p->priv)
				return data->callback(p->parent, p, p->priv);
			return data->callback(p->parent, p,
					(context ? context->data : NULL));
		}
	}

	return false;
}

void obs_property_set_visible(obs_property_t *p, bool visible)
{
	if (p) p->visible = visible;
}

void obs_property_set_enabled(obs_property_t *p, bool enabled)
{
	if (p) p->enabled = enabled;
}

void obs_property_set_description(obs_property_t *p, const char *description)
{
	if (p) {
		bfree(p->desc);
		p->desc = description && *description
			? bstrdup(description)
			: NULL;
	}
}

void obs_property_set_long_description(obs_property_t *p, const char *long_desc)
{
	if (p) {
		bfree(p->long_desc);
		p->long_desc = long_desc && *long_desc
			? bstrdup(long_desc)
			: NULL;
	}
}

const char *obs_property_name(obs_property_t *p)
{
	return p ? p->name : NULL;
}

const char *obs_property_description(obs_property_t *p)
{
	return p ? p->desc : NULL;
}

const char *obs_property_long_description(obs_property_t *p)
{
	return p ? p->long_desc : NULL;
}

enum obs_property_type obs_property_get_type(obs_property_t *p)
{
	return p ? p->type : OBS_PROPERTY_INVALID;
}

bool obs_property_enabled(obs_property_t *p)
{
	return p ? p->enabled : false;
}

bool obs_property_visible(obs_property_t *p)
{
	return p ? p->visible : false;
}

int obs_property_int_min(obs_property_t *p)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	return data ? data->min : 0;
}

int obs_property_int_max(obs_property_t *p)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	return data ? data->max : 0;
}

int obs_property_int_step(obs_property_t *p)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	return data ? data->step : 0;
}

enum obs_number_type obs_property_int_type(obs_property_t *p)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	return data ? data->type : OBS_NUMBER_SCROLLER;
}

double obs_property_float_min(obs_property_t *p)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_FLOAT);
	return data ? data->min : 0;
}

double obs_property_float_max(obs_property_t *p)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_FLOAT);
	return data ? data->max : 0;
}

double obs_property_float_step(obs_property_t *p)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_FLOAT);
	return data ? data->step : 0;
}

enum obs_number_type obs_property_float_type(obs_property_t *p)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_FLOAT);
	return data ? data->type : OBS_NUMBER_SCROLLER;
}

enum obs_text_type obs_property_text_type(obs_property_t *p)
{
	struct text_data *data = get_type_data(p, OBS_PROPERTY_TEXT);
	return data ? data->type : OBS_TEXT_DEFAULT;
}

enum obs_path_type obs_property_path_type(obs_property_t *p)
{
	struct path_data *data = get_type_data(p, OBS_PROPERTY_PATH);
	return data ? data->type : OBS_PATH_DIRECTORY;
}

const char *obs_property_path_filter(obs_property_t *p)
{
	struct path_data *data = get_type_data(p, OBS_PROPERTY_PATH);
	return data ? data->filter : NULL;
}

const char *obs_property_path_default_path(obs_property_t *p)
{
	struct path_data *data = get_type_data(p, OBS_PROPERTY_PATH);
	return data ? data->default_path : NULL;
}

enum obs_combo_type obs_property_list_type(obs_property_t *p)
{
	struct list_data *data = get_list_data(p);
	return data ? data->type : OBS_COMBO_TYPE_INVALID;
}

enum obs_combo_format obs_property_list_format(obs_property_t *p)
{
	struct list_data *data = get_list_data(p);
	return data ? data->format : OBS_COMBO_FORMAT_INVALID;
}

void obs_property_int_set_limits(obs_property_t *p,
		int min, int max, int step)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	if (!data)
		return;

	data->min = min;
	data->max = max;
	data->step = step;
}

void obs_property_float_set_limits(obs_property_t *p,
		double min, double max, double step)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_INT);
	if (!data)
		return;

	data->min = min;
	data->max = max;
	data->step = step;
}

void obs_property_list_clear(obs_property_t *p)
{
	struct list_data *data = get_list_data(p);
	if (data)
		list_data_free(data);
}

static size_t add_item(struct list_data *data, const char *name,
		const void *val)
{
	struct list_item item = { NULL };
	item.name  = bstrdup(name);

	if (data->format == OBS_COMBO_FORMAT_INT)
		item.ll  = *(const long long*)val;
	else if (data->format == OBS_COMBO_FORMAT_FLOAT)
		item.d   = *(const double*)val;
	else
		item.str = bstrdup(val);

	return da_push_back(data->items, &item);
}

static void insert_item(struct list_data *data, size_t idx, const char *name,
		const void *val)
{
	struct list_item item = { NULL };
	item.name  = bstrdup(name);

	if (data->format == OBS_COMBO_FORMAT_INT)
		item.ll  = *(const long long*)val;
	else if (data->format == OBS_COMBO_FORMAT_FLOAT)
		item.d   = *(const double*)val;
	else
		item.str = bstrdup(val);

	da_insert(data->items, idx, &item);
}

size_t obs_property_list_add_string(obs_property_t *p,
		const char *name, const char *val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_STRING)
		return add_item(data, name, val);
	return 0;
}

size_t obs_property_list_add_int(obs_property_t *p,
		const char *name, long long val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_INT)
		return add_item(data, name, &val);
	return 0;
}

size_t obs_property_list_add_float(obs_property_t *p,
		const char *name, double val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_FLOAT)
		return add_item(data, name, &val);
	return 0;
}

void obs_property_list_insert_string(obs_property_t *p, size_t idx,
		const char *name, const char *val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_STRING)
		insert_item(data, idx, name, val);
}

void obs_property_list_insert_int(obs_property_t *p, size_t idx,
		const char *name, long long val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_INT)
		insert_item(data, idx, name, &val);
}

void obs_property_list_insert_float(obs_property_t *p, size_t idx,
		const char *name, double val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_FLOAT)
		insert_item(data, idx, name, &val);
}

void obs_property_list_item_remove(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_data(p);
	if (data && idx < data->items.num) {
		list_item_free(data, data->items.array+idx);
		da_erase(data->items, idx);
	}
}

size_t obs_property_list_item_count(obs_property_t *p)
{
	struct list_data *data = get_list_data(p);
	return data ? data->items.num : 0;
}

bool obs_property_list_item_disabled(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_data(p);
	return (data && idx < data->items.num) ?
		data->items.array[idx].disabled : false;
}

void obs_property_list_item_disable(obs_property_t *p, size_t idx,
		bool disabled)
{
	struct list_data *data = get_list_data(p);
	if (!data || idx >= data->items.num)
		return;
	data->items.array[idx].disabled = disabled;
}

const char *obs_property_list_item_name(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_data(p);
	return (data && idx < data->items.num) ?
		data->items.array[idx].name : NULL;
}

const char *obs_property_list_item_string(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_fmt_data(p, OBS_COMBO_FORMAT_STRING);
	return (data && idx < data->items.num) ?
		data->items.array[idx].str : NULL;
}

long long obs_property_list_item_int(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_fmt_data(p, OBS_COMBO_FORMAT_INT);
	return (data && idx < data->items.num) ?
		data->items.array[idx].ll : 0;
}

double obs_property_list_item_float(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_fmt_data(p, OBS_COMBO_FORMAT_FLOAT);
	return (data && idx < data->items.num) ?
		data->items.array[idx].d : 0.0;
}

enum obs_editable_list_type obs_property_editable_list_type(obs_property_t *p)
{
	struct editable_list_data *data = get_type_data(p,
			OBS_PROPERTY_EDITABLE_LIST);
	return data ? data->type : OBS_EDITABLE_LIST_TYPE_STRINGS;
}

const char *obs_property_editable_list_filter(obs_property_t *p)
{
	struct editable_list_data *data = get_type_data(p,
			OBS_PROPERTY_EDITABLE_LIST);
	return data ? data->filter : NULL;
}

const char *obs_property_editable_list_default_path(obs_property_t *p)
{
	struct editable_list_data *data = get_type_data(p,
			OBS_PROPERTY_EDITABLE_LIST);
	return data ? data->default_path : NULL;
}




void obs_property_frame_rate_clear(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	frame_rate_data_options_free(data);
	frame_rate_data_ranges_free(data);
}

void obs_property_frame_rate_options_clear(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	frame_rate_data_options_free(data);
}

void obs_property_frame_rate_fps_ranges_clear(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	frame_rate_data_ranges_free(data);
}

size_t obs_property_frame_rate_option_add(obs_property_t *p,
		const char *name, const char *description)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return DARRAY_INVALID;

	struct frame_rate_option *opt = da_push_back_new(data->extra_options);

	opt->name        = bstrdup(name);
	opt->description = bstrdup(description);

	return data->extra_options.num - 1;
}

size_t obs_property_frame_rate_fps_range_add(obs_property_t *p,
		struct media_frames_per_second min,
		struct media_frames_per_second max)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return DARRAY_INVALID;

	struct frame_rate_range *rng = da_push_back_new(data->ranges);

	rng->min_time = min;
	rng->max_time = max;

	return data->ranges.num - 1;
}

void obs_property_frame_rate_option_insert(obs_property_t *p, size_t idx,
		const char *name, const char *description)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	struct frame_rate_option *opt = da_insert_new(data->extra_options, idx);

	opt->name        = bstrdup(name);
	opt->description = bstrdup(description);
}

void obs_property_frame_rate_fps_range_insert(obs_property_t *p, size_t idx,
		struct media_frames_per_second min,
		struct media_frames_per_second max)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	struct frame_rate_range *rng = da_insert_new(data->ranges, idx);

	rng->min_time = min;
	rng->max_time = max;
}

size_t obs_property_frame_rate_options_count(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data ? data->extra_options.num : 0;
}

const char *obs_property_frame_rate_option_name(obs_property_t *p,
		size_t idx)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data && data->extra_options.num > idx ?
		data->extra_options.array[idx].name : NULL;
}

const char *obs_property_frame_rate_option_description(
		obs_property_t *p, size_t idx)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data && data->extra_options.num > idx ?
		data->extra_options.array[idx].description : NULL;
}

size_t obs_property_frame_rate_fps_ranges_count(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data ? data->ranges.num : 0;
}

struct media_frames_per_second obs_property_frame_rate_fps_range_min(
		obs_property_t *p, size_t idx)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data && data->ranges.num > idx ?
		data->ranges.array[idx].min_time :
		(struct media_frames_per_second){0};
}
struct media_frames_per_second obs_property_frame_rate_fps_range_max(
		obs_property_t *p, size_t idx)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data && data->ranges.num > idx ?
		data->ranges.array[idx].max_time :
		(struct media_frames_per_second){0};
}

enum obs_text_type obs_proprety_text_type(obs_property_t *p)
{
	return obs_property_text_type(p);
}

<code block>


#include "util/bmem.h"
#include "util/darray.h"
#include "obs-internal.h"
#include "obs-properties.h"

static inline void *get_property_data(struct obs_property *prop);



struct float_data {
	double min, max, step;
	enum obs_number_type type;
};

struct int_data {
	int min, max, step;
	enum obs_number_type type;
};

struct list_item {
	char *name;
	bool disabled;

	union {
		char      *str;
		long long ll;
		double    d;
	};
};

struct path_data {
	char               *filter;
	char               *default_path;
	enum obs_path_type type;
};

struct text_data {
	enum obs_text_type type;
};

struct list_data {
	DARRAY(struct list_item) items;
	enum obs_combo_type      type;
	enum obs_combo_format    format;
};

struct editable_list_data {
	enum obs_editable_list_type type;
	char                        *filter;
	char                        *default_path;
};

struct button_data {
	obs_property_clicked_t callback;
};

struct frame_rate_option {
	char *name;
	char *description;
};

struct frame_rate_range {
	struct media_frames_per_second min_time;
	struct media_frames_per_second max_time;
};

struct frame_rate_data {
	DARRAY(struct frame_rate_option) extra_options;
	DARRAY(struct frame_rate_range)  ranges;
};

static inline void path_data_free(struct path_data *data)
{
	bfree(data->default_path);
	if (data->type == OBS_PATH_FILE)
		bfree(data->filter);
}

static inline void editable_list_data_free(struct editable_list_data *data)
{
	bfree(data->default_path);
	bfree(data->filter);
}

static inline void list_item_free(struct list_data *data,
		struct list_item *item)
{
	bfree(item->name);
	if (data->format == OBS_COMBO_FORMAT_STRING)
		bfree(item->str);
}

static inline void list_data_free(struct list_data *data)
{
	for (size_t i = 0; i < data->items.num; i++)
		list_item_free(data, data->items.array+i);

	da_free(data->items);
}

static inline void frame_rate_data_options_free(struct frame_rate_data *data)
{
	for (size_t i = 0; i < data->extra_options.num; i++) {
		struct frame_rate_option *opt = &data->extra_options.array[i];
		bfree(opt->name);
		bfree(opt->description);
	}

	da_resize(data->extra_options, 0);
}

static inline void frame_rate_data_ranges_free(struct frame_rate_data *data)
{
	da_resize(data->ranges, 0);
}

static inline void frame_rate_data_free(struct frame_rate_data *data)
{
	frame_rate_data_options_free(data);
	frame_rate_data_ranges_free(data);

	da_free(data->extra_options);
	da_free(data->ranges);
}

struct obs_properties;

struct obs_property {
	char                    *name;
	char                    *desc;
	char                    *long_desc;
	void                    *priv;
	enum obs_property_type  type;
	bool                    visible;
	bool                    enabled;

	struct obs_properties   *parent;

	obs_property_modified_t modified;
	obs_property_modified2_t modified2;

	struct obs_property     *next;
};

struct obs_properties {
	void                    *param;
	void                    (*destroy)(void *param);
	uint32_t                flags;

	struct obs_property     *first_property;
	struct obs_property     **last;
};

obs_properties_t *obs_properties_create(void)
{
	struct obs_properties *props;
	props = bzalloc(sizeof(struct obs_properties));
	props->last = &props->first_property;
	return props;
}

void obs_properties_set_param(obs_properties_t *props,
		void *param, void (*destroy)(void *param))
{
	if (!props)
		return;

	if (props->param && props->destroy)
		props->destroy(props->param);

	props->param   = param;
	props->destroy = destroy;
}

void obs_properties_set_flags(obs_properties_t *props, uint32_t flags)
{
	if (props)
		props->flags = flags;
}

uint32_t obs_properties_get_flags(obs_properties_t *props)
{
	return props ? props->flags : 0;
}

void *obs_properties_get_param(obs_properties_t *props)
{
	return props ? props->param : NULL;
}

obs_properties_t *obs_properties_create_param(void *param,
		void (*destroy)(void *param))
{
	struct obs_properties *props = obs_properties_create();
	obs_properties_set_param(props, param, destroy);
	return props;
}

static void obs_property_destroy(struct obs_property *property)
{
	if (property->type == OBS_PROPERTY_LIST)
		list_data_free(get_property_data(property));
	else if (property->type == OBS_PROPERTY_PATH)
		path_data_free(get_property_data(property));
	else if (property->type == OBS_PROPERTY_EDITABLE_LIST)
		editable_list_data_free(get_property_data(property));
	else if (property->type == OBS_PROPERTY_FRAME_RATE)
		frame_rate_data_free(get_property_data(property));

	bfree(property->name);
	bfree(property->desc);
	bfree(property->long_desc);
	bfree(property);
}

void obs_properties_destroy(obs_properties_t *props)
{
	if (props) {
		struct obs_property *p = props->first_property;

		if (props->destroy && props->param)
			props->destroy(props->param);

		while (p) {
			struct obs_property *next = p->next;
			obs_property_destroy(p);
			p = next;
		}

		bfree(props);
	}
}

obs_property_t *obs_properties_first(obs_properties_t *props)
{
	return (props != NULL) ? props->first_property : NULL;
}

obs_property_t *obs_properties_get(obs_properties_t *props, const char *name)
{
	struct obs_property *property;

	if (!props)
		return NULL;

	property = props->first_property;
	while (property) {
		if (strcmp(property->name, name) == 0)
			return property;

		property = property->next;
	}

	return NULL;
}

void obs_properties_apply_settings(obs_properties_t *props, obs_data_t *settings)
{
	struct obs_property *p;

	if (!props)
		return;
	
	p = props->first_property;
	while (p) {
		if (p->modified)
			p->modified(props, p, settings);
		else if (p->modified2)
			p->modified2(p->priv, props, p, settings);
		p = p->next;
	}
}



static inline void propertes_add(struct obs_properties *props,
		struct obs_property *p)
{
	*props->last = p;
	props->last = &p->next;
}

static inline size_t get_property_size(enum obs_property_type type)
{
	switch (type) {
	case OBS_PROPERTY_INVALID:   return 0;
	case OBS_PROPERTY_BOOL:      return 0;
	case OBS_PROPERTY_INT:       return sizeof(struct int_data);
	case OBS_PROPERTY_FLOAT:     return sizeof(struct float_data);
	case OBS_PROPERTY_TEXT:      return sizeof(struct text_data);
	case OBS_PROPERTY_PATH:      return sizeof(struct path_data);
	case OBS_PROPERTY_LIST:      return sizeof(struct list_data);
	case OBS_PROPERTY_COLOR:     return 0;
	case OBS_PROPERTY_BUTTON:    return sizeof(struct button_data);
	case OBS_PROPERTY_FONT:      return 0;
	case OBS_PROPERTY_EDITABLE_LIST:
		return sizeof(struct editable_list_data);
	case OBS_PROPERTY_FRAME_RATE:return sizeof(struct frame_rate_data);
	}

	return 0;
}

static inline struct obs_property *new_prop(struct obs_properties *props,
		const char *name, const char *desc,
		enum obs_property_type type)
{
	size_t data_size = get_property_size(type);
	struct obs_property *p;

	p = bzalloc(sizeof(struct obs_property) + data_size);
	p->parent  = props;
	p->enabled = true;
	p->visible = true;
	p->type    = type;
	p->name    = bstrdup(name);
	p->desc    = bstrdup(desc);
	propertes_add(props, p);

	return p;
}

static inline bool has_prop(struct obs_properties *props, const char *name)
{
	struct obs_property *p = props->first_property;

	while (p) {
		if (strcmp(p->name, name) == 0) {
			blog(LOG_WARNING, "Property '%s' exists", name);
			return true;
		}

		p = p->next;
	}

	return false;
}

static inline void *get_property_data(struct obs_property *prop)
{
	return (uint8_t*)prop + sizeof(struct obs_property);
}

static inline void *get_type_data(struct obs_property *prop,
		enum obs_property_type type)
{
	if (!prop || prop->type != type)
		return NULL;

	return get_property_data(prop);
}

obs_property_t *obs_properties_add_bool(obs_properties_t *props,
		const char *name, const char *desc)
{
	if (!props || has_prop(props, name)) return NULL;
	return new_prop(props, name, desc, OBS_PROPERTY_BOOL);
}

static obs_property_t *add_int(obs_properties_t *props,
		const char *name, const char *desc, int min, int max, int step,
		enum obs_number_type type)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc, OBS_PROPERTY_INT);
	struct int_data *data = get_property_data(p);
	data->min  = min;
	data->max  = max;
	data->step = step;
	data->type = type;
	return p;
}

static obs_property_t *add_flt(obs_properties_t *props,
		const char *name, const char *desc,
		double min, double max, double step,
		enum obs_number_type type)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc,
			OBS_PROPERTY_FLOAT);
	struct float_data *data = get_property_data(p);
	data->min  = min;
	data->max  = max;
	data->step = step;
	data->type = type;
	return p;
}

obs_property_t *obs_properties_add_int(obs_properties_t *props,
		const char *name, const char *desc, int min, int max, int step)
{
	return add_int(props, name, desc, min, max, step, OBS_NUMBER_SCROLLER);
}

obs_property_t *obs_properties_add_float(obs_properties_t *props,
		const char *name, const char *desc,
		double min, double max, double step)
{
	return add_flt(props, name, desc, min, max, step, OBS_NUMBER_SCROLLER);
}

obs_property_t *obs_properties_add_int_slider(obs_properties_t *props,
		const char *name, const char *desc, int min, int max, int step)
{
	return add_int(props, name, desc, min, max, step, OBS_NUMBER_SLIDER);
}

obs_property_t *obs_properties_add_float_slider(obs_properties_t *props,
		const char *name, const char *desc,
		double min, double max, double step)
{
	return add_flt(props, name, desc, min, max, step, OBS_NUMBER_SLIDER);
}

obs_property_t *obs_properties_add_text(obs_properties_t *props,
		const char *name, const char *desc, enum obs_text_type type)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc, OBS_PROPERTY_TEXT);
	struct text_data *data = get_property_data(p);
	data->type = type;
	return p;
}

obs_property_t *obs_properties_add_path(obs_properties_t *props,
		const char *name, const char *desc, enum obs_path_type type,
		const char *filter, const char *default_path)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc, OBS_PROPERTY_PATH);
	struct path_data *data = get_property_data(p);
	data->type         = type;
	data->default_path = bstrdup(default_path);

	if (data->type == OBS_PATH_FILE)
		data->filter = bstrdup(filter);

	return p;
}

obs_property_t *obs_properties_add_list(obs_properties_t *props,
		const char *name, const char *desc,
		enum obs_combo_type type,
		enum obs_combo_format format)
{
	if (!props || has_prop(props, name)) return NULL;

	if (type   == OBS_COMBO_TYPE_EDITABLE &&
	    format != OBS_COMBO_FORMAT_STRING) {
		blog(LOG_WARNING, "List '%s', error: Editable combo boxes "
		                  "must be of the 'string' type", name);
		return NULL;
	}

	struct obs_property *p = new_prop(props, name, desc, OBS_PROPERTY_LIST);
	struct list_data *data = get_property_data(p);
	data->format = format;
	data->type   = type;

	return p;
}

obs_property_t *obs_properties_add_color(obs_properties_t *props,
		const char *name, const char *desc)
{
	if (!props || has_prop(props, name)) return NULL;
	return new_prop(props, name, desc, OBS_PROPERTY_COLOR);
}

obs_property_t *obs_properties_add_button(obs_properties_t *props,
		const char *name, const char *text,
		obs_property_clicked_t callback)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, text,
			OBS_PROPERTY_BUTTON);
	struct button_data *data = get_property_data(p);
	data->callback = callback;
	return p;
}

obs_property_t *obs_properties_add_button2(obs_properties_t *props,
		const char *name, const char *text,
		obs_property_clicked_t callback, void *priv)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, text,
			OBS_PROPERTY_BUTTON);
	struct button_data *data = get_property_data(p);
	data->callback = callback;
	p->priv = priv;
	return p;
}

obs_property_t *obs_properties_add_font(obs_properties_t *props,
		const char *name, const char *desc)
{
	if (!props || has_prop(props, name)) return NULL;
	return new_prop(props, name, desc, OBS_PROPERTY_FONT);
}

obs_property_t *obs_properties_add_editable_list(obs_properties_t *props,
		const char *name, const char *desc,
		enum obs_editable_list_type type, const char *filter,
		const char *default_path)
{
	if (!props || has_prop(props, name)) return NULL;
	struct obs_property *p = new_prop(props, name, desc,
			OBS_PROPERTY_EDITABLE_LIST);

	struct editable_list_data *data = get_property_data(p);
	data->type = type;
	data->filter = bstrdup(filter);
	data->default_path = bstrdup(default_path);
	return p;
}

obs_property_t *obs_properties_add_frame_rate(obs_properties_t *props,
		const char *name, const char *desc)
{
	if (!props || has_prop(props, name)) return NULL;

	struct obs_property *p = new_prop(props, name, desc,
			OBS_PROPERTY_FRAME_RATE);

	struct frame_rate_data *data = get_property_data(p);
	da_init(data->extra_options);
	da_init(data->ranges);
	return p;
}



static inline bool is_combo(struct obs_property *p)
{
	return p->type == OBS_PROPERTY_LIST;
}

static inline struct list_data *get_list_data(struct obs_property *p)
{
	if (!p || !is_combo(p))
		return NULL;

	return get_property_data(p);
}

static inline struct list_data *get_list_fmt_data(struct obs_property *p,
		enum obs_combo_format format)
{
	struct list_data *data = get_list_data(p);
	return (data && data->format == format) ? data : NULL;
}



bool obs_property_next(obs_property_t **p)
{
	if (!p || !*p)
		return false;

	*p = (*p)->next;
	return *p != NULL;
}

void obs_property_set_modified_callback(obs_property_t *p,
		obs_property_modified_t modified)
{
	if (p) p->modified = modified;
}

void obs_property_set_modified_callback2(obs_property_t *p,
		obs_property_modified2_t modified2, void *priv)
{
	if (p) {
		p->modified2 = modified2;
		p->priv = priv;
	}
}

bool obs_property_modified(obs_property_t *p, obs_data_t *settings)
{
	if (p) {
		if (p->modified) {
			return p->modified(p->parent, p, settings);
		} else if (p->modified2) {
			return p->modified2(p->priv, p->parent, p, settings);
		}
	}
	return false;
}

bool obs_property_button_clicked(obs_property_t *p, void *obj)
{
	struct obs_context_data *context = obj;
	if (p) {
		struct button_data *data = get_type_data(p,
				OBS_PROPERTY_BUTTON);
		if (data && data->callback) {
			if (p->priv)
				return data->callback(p->parent, p, p->priv);
			return data->callback(p->parent, p,
					(context ? context->data : NULL));
		}
	}

	return false;
}

void obs_property_set_visible(obs_property_t *p, bool visible)
{
	if (p) p->visible = visible;
}

void obs_property_set_enabled(obs_property_t *p, bool enabled)
{
	if (p) p->enabled = enabled;
}

void obs_property_set_description(obs_property_t *p, const char *description)
{
	if (p) {
		bfree(p->desc);
		p->desc = description && *description
			? bstrdup(description)
			: NULL;
	}
}

void obs_property_set_long_description(obs_property_t *p, const char *long_desc)
{
	if (p) {
		bfree(p->long_desc);
		p->long_desc = long_desc && *long_desc
			? bstrdup(long_desc)
			: NULL;
	}
}

const char *obs_property_name(obs_property_t *p)
{
	return p ? p->name : NULL;
}

const char *obs_property_description(obs_property_t *p)
{
	return p ? p->desc : NULL;
}

const char *obs_property_long_description(obs_property_t *p)
{
	return p ? p->long_desc : NULL;
}

enum obs_property_type obs_property_get_type(obs_property_t *p)
{
	return p ? p->type : OBS_PROPERTY_INVALID;
}

bool obs_property_enabled(obs_property_t *p)
{
	return p ? p->enabled : false;
}

bool obs_property_visible(obs_property_t *p)
{
	return p ? p->visible : false;
}

int obs_property_int_min(obs_property_t *p)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	return data ? data->min : 0;
}

int obs_property_int_max(obs_property_t *p)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	return data ? data->max : 0;
}

int obs_property_int_step(obs_property_t *p)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	return data ? data->step : 0;
}

enum obs_number_type obs_property_int_type(obs_property_t *p)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	return data ? data->type : OBS_NUMBER_SCROLLER;
}

double obs_property_float_min(obs_property_t *p)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_FLOAT);
	return data ? data->min : 0;
}

double obs_property_float_max(obs_property_t *p)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_FLOAT);
	return data ? data->max : 0;
}

double obs_property_float_step(obs_property_t *p)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_FLOAT);
	return data ? data->step : 0;
}

enum obs_number_type obs_property_float_type(obs_property_t *p)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_FLOAT);
	return data ? data->type : OBS_NUMBER_SCROLLER;
}

enum obs_text_type obs_proprety_text_type(obs_property_t *p)
{
	struct text_data *data = get_type_data(p, OBS_PROPERTY_TEXT);
	return data ? data->type : OBS_TEXT_DEFAULT;
}

enum obs_path_type obs_property_path_type(obs_property_t *p)
{
	struct path_data *data = get_type_data(p, OBS_PROPERTY_PATH);
	return data ? data->type : OBS_PATH_DIRECTORY;
}

const char *obs_property_path_filter(obs_property_t *p)
{
	struct path_data *data = get_type_data(p, OBS_PROPERTY_PATH);
	return data ? data->filter : NULL;
}

const char *obs_property_path_default_path(obs_property_t *p)
{
	struct path_data *data = get_type_data(p, OBS_PROPERTY_PATH);
	return data ? data->default_path : NULL;
}

enum obs_combo_type obs_property_list_type(obs_property_t *p)
{
	struct list_data *data = get_list_data(p);
	return data ? data->type : OBS_COMBO_TYPE_INVALID;
}

enum obs_combo_format obs_property_list_format(obs_property_t *p)
{
	struct list_data *data = get_list_data(p);
	return data ? data->format : OBS_COMBO_FORMAT_INVALID;
}

void obs_property_int_set_limits(obs_property_t *p,
		int min, int max, int step)
{
	struct int_data *data = get_type_data(p, OBS_PROPERTY_INT);
	if (!data)
		return;

	data->min = min;
	data->max = max;
	data->step = step;
}

void obs_property_float_set_limits(obs_property_t *p,
		double min, double max, double step)
{
	struct float_data *data = get_type_data(p, OBS_PROPERTY_INT);
	if (!data)
		return;

	data->min = min;
	data->max = max;
	data->step = step;
}

void obs_property_list_clear(obs_property_t *p)
{
	struct list_data *data = get_list_data(p);
	if (data)
		list_data_free(data);
}

static size_t add_item(struct list_data *data, const char *name,
		const void *val)
{
	struct list_item item = { NULL };
	item.name  = bstrdup(name);

	if (data->format == OBS_COMBO_FORMAT_INT)
		item.ll  = *(const long long*)val;
	else if (data->format == OBS_COMBO_FORMAT_FLOAT)
		item.d   = *(const double*)val;
	else
		item.str = bstrdup(val);

	return da_push_back(data->items, &item);
}

static void insert_item(struct list_data *data, size_t idx, const char *name,
		const void *val)
{
	struct list_item item = { NULL };
	item.name  = bstrdup(name);

	if (data->format == OBS_COMBO_FORMAT_INT)
		item.ll  = *(const long long*)val;
	else if (data->format == OBS_COMBO_FORMAT_FLOAT)
		item.d   = *(const double*)val;
	else
		item.str = bstrdup(val);

	da_insert(data->items, idx, &item);
}

size_t obs_property_list_add_string(obs_property_t *p,
		const char *name, const char *val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_STRING)
		return add_item(data, name, val);
	return 0;
}

size_t obs_property_list_add_int(obs_property_t *p,
		const char *name, long long val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_INT)
		return add_item(data, name, &val);
	return 0;
}

size_t obs_property_list_add_float(obs_property_t *p,
		const char *name, double val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_FLOAT)
		return add_item(data, name, &val);
	return 0;
}

void obs_property_list_insert_string(obs_property_t *p, size_t idx,
		const char *name, const char *val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_STRING)
		insert_item(data, idx, name, val);
}

void obs_property_list_insert_int(obs_property_t *p, size_t idx,
		const char *name, long long val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_INT)
		insert_item(data, idx, name, &val);
}

void obs_property_list_insert_float(obs_property_t *p, size_t idx,
		const char *name, double val)
{
	struct list_data *data = get_list_data(p);
	if (data && data->format == OBS_COMBO_FORMAT_FLOAT)
		insert_item(data, idx, name, &val);
}

void obs_property_list_item_remove(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_data(p);
	if (data && idx < data->items.num) {
		list_item_free(data, data->items.array+idx);
		da_erase(data->items, idx);
	}
}

size_t obs_property_list_item_count(obs_property_t *p)
{
	struct list_data *data = get_list_data(p);
	return data ? data->items.num : 0;
}

bool obs_property_list_item_disabled(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_data(p);
	return (data && idx < data->items.num) ?
		data->items.array[idx].disabled : false;
}

void obs_property_list_item_disable(obs_property_t *p, size_t idx,
		bool disabled)
{
	struct list_data *data = get_list_data(p);
	if (!data || idx >= data->items.num)
		return;
	data->items.array[idx].disabled = disabled;
}

const char *obs_property_list_item_name(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_data(p);
	return (data && idx < data->items.num) ?
		data->items.array[idx].name : NULL;
}

const char *obs_property_list_item_string(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_fmt_data(p, OBS_COMBO_FORMAT_STRING);
	return (data && idx < data->items.num) ?
		data->items.array[idx].str : NULL;
}

long long obs_property_list_item_int(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_fmt_data(p, OBS_COMBO_FORMAT_INT);
	return (data && idx < data->items.num) ?
		data->items.array[idx].ll : 0;
}

double obs_property_list_item_float(obs_property_t *p, size_t idx)
{
	struct list_data *data = get_list_fmt_data(p, OBS_COMBO_FORMAT_FLOAT);
	return (data && idx < data->items.num) ?
		data->items.array[idx].d : 0.0;
}

enum obs_editable_list_type obs_property_editable_list_type(obs_property_t *p)
{
	struct editable_list_data *data = get_type_data(p,
			OBS_PROPERTY_EDITABLE_LIST);
	return data ? data->type : OBS_EDITABLE_LIST_TYPE_STRINGS;
}

const char *obs_property_editable_list_filter(obs_property_t *p)
{
	struct editable_list_data *data = get_type_data(p,
			OBS_PROPERTY_EDITABLE_LIST);
	return data ? data->filter : NULL;
}

const char *obs_property_editable_list_default_path(obs_property_t *p)
{
	struct editable_list_data *data = get_type_data(p,
			OBS_PROPERTY_EDITABLE_LIST);
	return data ? data->default_path : NULL;
}




void obs_property_frame_rate_clear(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	frame_rate_data_options_free(data);
	frame_rate_data_ranges_free(data);
}

void obs_property_frame_rate_options_clear(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	frame_rate_data_options_free(data);
}

void obs_property_frame_rate_fps_ranges_clear(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	frame_rate_data_ranges_free(data);
}

size_t obs_property_frame_rate_option_add(obs_property_t *p,
		const char *name, const char *description)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return DARRAY_INVALID;

	struct frame_rate_option *opt = da_push_back_new(data->extra_options);

	opt->name        = bstrdup(name);
	opt->description = bstrdup(description);

	return data->extra_options.num - 1;
}

size_t obs_property_frame_rate_fps_range_add(obs_property_t *p,
		struct media_frames_per_second min,
		struct media_frames_per_second max)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return DARRAY_INVALID;

	struct frame_rate_range *rng = da_push_back_new(data->ranges);

	rng->min_time = min;
	rng->max_time = max;

	return data->ranges.num - 1;
}

void obs_property_frame_rate_option_insert(obs_property_t *p, size_t idx,
		const char *name, const char *description)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	struct frame_rate_option *opt = da_insert_new(data->extra_options, idx);

	opt->name        = bstrdup(name);
	opt->description = bstrdup(description);
}

void obs_property_frame_rate_fps_range_insert(obs_property_t *p, size_t idx,
		struct media_frames_per_second min,
		struct media_frames_per_second max)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	if (!data) return;

	struct frame_rate_range *rng = da_insert_new(data->ranges, idx);

	rng->min_time = min;
	rng->max_time = max;
}

size_t obs_property_frame_rate_options_count(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data ? data->extra_options.num : 0;
}

const char *obs_property_frame_rate_option_name(obs_property_t *p,
		size_t idx)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data && data->extra_options.num > idx ?
		data->extra_options.array[idx].name : NULL;
}

const char *obs_property_frame_rate_option_description(
		obs_property_t *p, size_t idx)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data && data->extra_options.num > idx ?
		data->extra_options.array[idx].description : NULL;
}

size_t obs_property_frame_rate_fps_ranges_count(obs_property_t *p)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data ? data->ranges.num : 0;
}

struct media_frames_per_second obs_property_frame_rate_fps_range_min(
		obs_property_t *p, size_t idx)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data && data->ranges.num > idx ?
		data->ranges.array[idx].min_time :
		(struct media_frames_per_second){0};
}
struct media_frames_per_second obs_property_frame_rate_fps_range_max(
		obs_property_t *p, size_t idx)
{
	struct frame_rate_data *data =
		get_type_data(p, OBS_PROPERTY_FRAME_RATE);
	return data && data->ranges.num > idx ?
		data->ranges.array[idx].max_time :
		(struct media_frames_per_second){0};
}

<code block>


#pragma once

#include "util/c99defs.h"
#include "util/darray.h"
#include "util/circlebuf.h"
#include "util/dstr.h"
#include "util/threading.h"
#include "util/platform.h"
#include "util/profiler.h"
#include "callback/signal.h"
#include "callback/proc.h"

#include "graphics/graphics.h"
#include "graphics/matrix4.h"

#include "media-io/audio-resampler.h"
#include "media-io/video-io.h"
#include "media-io/audio-io.h"

#include "obs.h"

#define NUM_TEXTURES 2
#define MICROSECOND_DEN 1000000

static inline int64_t packet_dts_usec(struct encoder_packet *packet)
{
	return packet->dts * MICROSECOND_DEN / packet->timebase_den;
}

struct tick_callback {
	void (*tick)(void *param, float seconds);
	void *param;
};

struct draw_callback {
	void (*draw)(void *param, uint32_t cx, uint32_t cy);
	void *param;
};




static inline bool obs_object_valid(const void *obj, const char *f,
		const char *t)
{
	if (!obj) {
		blog(LOG_DEBUG, "%s: Null '%s' parameter", f, t);
		return false;
	}

	return true;
}

#define obs_ptr_valid(ptr, func) obs_object_valid(ptr, func, #ptr)
#define obs_source_valid  obs_ptr_valid
#define obs_output_valid  obs_ptr_valid
#define obs_encoder_valid obs_ptr_valid
#define obs_service_valid obs_ptr_valid




struct obs_module {
	char *mod_name;
	const char *file;
	char *bin_path;
	char *data_path;
	void *module;
	bool loaded;

	bool        (*load)(void);
	void        (*unload)(void);
	void        (*post_load)(void);
	void        (*set_locale)(const char *locale);
	void        (*free_locale)(void);
	uint32_t    (*ver)(void);
	void        (*set_pointer)(obs_module_t *module);
	const char *(*name)(void);
	const char *(*description)(void);
	const char *(*author)(void);

	struct obs_module *next;
};

extern void free_module(struct obs_module *mod);

struct obs_module_path {
	char *bin;
	char *data;
};

static inline void free_module_path(struct obs_module_path *omp)
{
	if (omp) {
		bfree(omp->bin);
		bfree(omp->data);
	}
}

static inline bool check_path(const char *data, const char *path,
		struct dstr *output)
{
	dstr_copy(output, path);
	dstr_cat(output, data);

	return os_file_exists(output->array);
}





struct obs_hotkey {
	obs_hotkey_id               id;
	char                        *name;
	char                        *description;

	obs_hotkey_func             func;
	void                        *data;
	int                         pressed;

	obs_hotkey_registerer_t     registerer_type;
	void                        *registerer;

	obs_hotkey_id               pair_partner_id;
};

struct obs_hotkey_pair {
	obs_hotkey_pair_id          pair_id;
	obs_hotkey_id               id[2];
	obs_hotkey_active_func      func[2];
	bool                        pressed0;
	bool                        pressed1;
	void                        *data[2];
};

typedef struct obs_hotkey_pair obs_hotkey_pair_t;

typedef struct obs_hotkeys_platform obs_hotkeys_platform_t;

void *obs_hotkey_thread(void *param);

struct obs_core_hotkeys;
bool obs_hotkeys_platform_init(struct obs_core_hotkeys *hotkeys);
void obs_hotkeys_platform_free(struct obs_core_hotkeys *hotkeys);
bool obs_hotkeys_platform_is_pressed(obs_hotkeys_platform_t *context,
		obs_key_t key);

const char *obs_get_hotkey_translation(obs_key_t key, const char *def);

struct obs_context_data;
void obs_hotkeys_context_release(struct obs_context_data *context);

void obs_hotkeys_free(void);

struct obs_hotkey_binding {
	obs_key_combination_t       key;
	bool                        pressed;
	bool                        modifiers_match;

	obs_hotkey_id               hotkey_id;
	obs_hotkey_t                *hotkey;
};

struct obs_hotkey_name_map;
void obs_hotkey_name_map_free(void);





struct obs_view {
	pthread_mutex_t                 channels_mutex;
	obs_source_t                    *channels[MAX_CHANNELS];
};

extern bool obs_view_init(struct obs_view *view);
extern void obs_view_free(struct obs_view *view);





struct obs_display {
	bool                            size_changed;
	bool                            enabled;
	uint32_t                        cx, cy;
	uint32_t                        background_color;
	gs_swapchain_t                  *swap;
	pthread_mutex_t                 draw_callbacks_mutex;
	pthread_mutex_t                 draw_info_mutex;
	DARRAY(struct draw_callback)    draw_callbacks;

	struct obs_display              *next;
	struct obs_display              **prev_next;
};

extern bool obs_display_init(struct obs_display *display,
		const struct gs_init_data *graphics_data);
extern void obs_display_free(struct obs_display *display);





struct obs_vframe_info {
	uint64_t timestamp;
	int count;
};

struct obs_core_video {
	graphics_t                      *graphics;
	gs_stagesurf_t                  *copy_surfaces[NUM_TEXTURES];
	gs_texture_t                    *render_textures[NUM_TEXTURES];
	gs_texture_t                    *output_textures[NUM_TEXTURES];
	gs_texture_t                    *convert_textures[NUM_TEXTURES];
	bool                            textures_rendered[NUM_TEXTURES];
	bool                            textures_output[NUM_TEXTURES];
	bool                            textures_copied[NUM_TEXTURES];
	bool                            textures_converted[NUM_TEXTURES];
	struct circlebuf                vframe_info_buffer;
	gs_effect_t                     *default_effect;
	gs_effect_t                     *default_rect_effect;
	gs_effect_t                     *opaque_effect;
	gs_effect_t                     *solid_effect;
	gs_effect_t                     *conversion_effect;
	gs_effect_t                     *bicubic_effect;
	gs_effect_t                     *lanczos_effect;
	gs_effect_t                     *bilinear_lowres_effect;
	gs_effect_t                     *premultiplied_alpha_effect;
	gs_samplerstate_t               *point_sampler;
	gs_stagesurf_t                  *mapped_surface;
	int                             cur_texture;

	uint64_t                        video_time;
	uint64_t                        video_avg_frame_time_ns;
	double                          video_fps;
	video_t                         *video;
	pthread_t                       video_thread;
	uint32_t                        total_frames;
	uint32_t                        lagged_frames;
	bool                            thread_initialized;

	bool                            gpu_conversion;
	const char                      *conversion_tech;
	uint32_t                        conversion_height;
	uint32_t                        plane_offsets[3];
	uint32_t                        plane_sizes[3];
	uint32_t                        plane_linewidth[3];

	uint32_t                        output_width;
	uint32_t                        output_height;
	uint32_t                        base_width;
	uint32_t                        base_height;
	float                           color_matrix[16];
	enum obs_scale_type             scale_type;

	gs_texture_t                    *transparent_texture;

	gs_effect_t                     *deinterlace_discard_effect;
	gs_effect_t                     *deinterlace_discard_2x_effect;
	gs_effect_t                     *deinterlace_linear_effect;
	gs_effect_t                     *deinterlace_linear_2x_effect;
	gs_effect_t                     *deinterlace_blend_effect;
	gs_effect_t                     *deinterlace_blend_2x_effect;
	gs_effect_t                     *deinterlace_yadif_effect;
	gs_effect_t                     *deinterlace_yadif_2x_effect;

	struct obs_video_info           ovi;
};

struct audio_monitor;

struct obs_core_audio {
	audio_t                         *audio;

	DARRAY(struct obs_source*)      render_order;
	DARRAY(struct obs_source*)      root_nodes;

	uint64_t                        buffered_ts;
	struct circlebuf                buffered_timestamps;
	int                             buffering_wait_ticks;
	int                             total_buffering_ticks;

	float                           user_volume;

	pthread_mutex_t                 monitoring_mutex;
	DARRAY(struct audio_monitor*)   monitors;
	char                            *monitoring_device_name;
	char                            *monitoring_device_id;
};


struct obs_core_data {
	struct obs_source               *first_source;
	struct obs_source               *first_audio_source;
	struct obs_display              *first_display;
	struct obs_output               *first_output;
	struct obs_encoder              *first_encoder;
	struct obs_service              *first_service;

	pthread_mutex_t                 sources_mutex;
	pthread_mutex_t                 displays_mutex;
	pthread_mutex_t                 outputs_mutex;
	pthread_mutex_t                 encoders_mutex;
	pthread_mutex_t                 services_mutex;
	pthread_mutex_t                 audio_sources_mutex;
	pthread_mutex_t                 draw_callbacks_mutex;
	DARRAY(struct draw_callback)    draw_callbacks;
	DARRAY(struct tick_callback)    tick_callbacks;

	struct obs_view                 main_view;

	long long                       unnamed_index;

	volatile bool                   valid;
};


struct obs_core_hotkeys {
	pthread_mutex_t                 mutex;
	DARRAY(obs_hotkey_t)            hotkeys;
	obs_hotkey_id                   next_id;
	DARRAY(obs_hotkey_pair_t)       hotkey_pairs;
	obs_hotkey_pair_id              next_pair_id;

	pthread_t                       hotkey_thread;
	bool                            hotkey_thread_initialized;
	os_event_t                      *stop_event;
	bool                            thread_disable_press;
	bool                            strict_modifiers;
	bool                            reroute_hotkeys;
	DARRAY(obs_hotkey_binding_t)    bindings;

	obs_hotkey_callback_router_func router_func;
	void                            *router_func_data;

	obs_hotkeys_platform_t          *platform_context;

	pthread_once_t                  name_map_init_token;
	struct obs_hotkey_name_map      *name_map;

	signal_handler_t                *signals;

	char                            *translations[OBS_KEY_LAST_VALUE];
	char                            *mute;
	char                            *unmute;
	char                            *push_to_mute;
	char                            *push_to_talk;
	char                            *sceneitem_show;
	char                            *sceneitem_hide;
};

struct obs_core {
	struct obs_module               *first_module;
	DARRAY(struct obs_module_path)  module_paths;

	DARRAY(struct obs_source_info)  source_types;
	DARRAY(struct obs_source_info)  input_types;
	DARRAY(struct obs_source_info)  filter_types;
	DARRAY(struct obs_source_info)  transition_types;
	DARRAY(struct obs_output_info)  output_types;
	DARRAY(struct obs_encoder_info) encoder_types;
	DARRAY(struct obs_service_info) service_types;
	DARRAY(struct obs_modal_ui)     modal_ui_callbacks;
	DARRAY(struct obs_modeless_ui)  modeless_ui_callbacks;

	signal_handler_t                *signals;
	proc_handler_t                  *procs;

	char                            *locale;
	char                            *module_config_path;
	bool                            name_store_owned;
	profiler_name_store_t           *name_store;


	struct obs_core_video           video;
	struct obs_core_audio           audio;
	struct obs_core_data            data;
	struct obs_core_hotkeys         hotkeys;
};

extern struct obs_core *obs;

extern void *obs_graphics_thread(void *param);

extern gs_effect_t *obs_load_effect(gs_effect_t **effect, const char *file);

extern bool audio_callback(void *param,
		uint64_t start_ts_in, uint64_t end_ts_in, uint64_t *out_ts,
		uint32_t mixers, struct audio_output_data *mixes);





struct obs_context_data {
	char                            *name;
	void                            *data;
	obs_data_t                      *settings;
	signal_handler_t                *signals;
	proc_handler_t                  *procs;
	enum obs_obj_type               type;

	DARRAY(obs_hotkey_id)           hotkeys;
	DARRAY(obs_hotkey_pair_id)      hotkey_pairs;
	obs_data_t                      *hotkey_data;

	DARRAY(char*)                   rename_cache;
	pthread_mutex_t                 rename_cache_mutex;

	pthread_mutex_t                 *mutex;
	struct obs_context_data         *next;
	struct obs_context_data         **prev_next;

	bool                            private;
};

extern bool obs_context_data_init(
		struct obs_context_data *context,
		enum obs_obj_type       type,
		obs_data_t              *settings,
		const char              *name,
		obs_data_t              *hotkey_data,
		bool                    private);
extern void obs_context_data_free(struct obs_context_data *context);

extern void obs_context_data_insert(struct obs_context_data *context,
		pthread_mutex_t *mutex, void *first);
extern void obs_context_data_remove(struct obs_context_data *context);

extern void obs_context_data_setname(struct obs_context_data *context,
		const char *name);





struct obs_weak_ref {
	volatile long refs;
	volatile long weak_refs;
};

static inline void obs_ref_addref(struct obs_weak_ref *ref)
{
	os_atomic_inc_long(&ref->refs);
}

static inline bool obs_ref_release(struct obs_weak_ref *ref)
{
	return os_atomic_dec_long(&ref->refs) == -1;
}

static inline void obs_weak_ref_addref(struct obs_weak_ref *ref)
{
	os_atomic_inc_long(&ref->weak_refs);
}

static inline bool obs_weak_ref_release(struct obs_weak_ref *ref)
{
	return os_atomic_dec_long(&ref->weak_refs) == -1;
}

static inline bool obs_weak_ref_get_ref(struct obs_weak_ref *ref)
{
	long owners = ref->refs;
	while (owners > -1) {
		if (os_atomic_compare_swap_long(&ref->refs, owners, owners + 1))
			return true;

		owners = ref->refs;
	}

	return false;
}





struct async_frame {
	struct obs_source_frame *frame;
	long unused_count;
	bool used;
};

enum audio_action_type {
	AUDIO_ACTION_VOL,
	AUDIO_ACTION_MUTE,
	AUDIO_ACTION_PTT,
	AUDIO_ACTION_PTM,
};

struct audio_action {
	uint64_t timestamp;
	enum audio_action_type type;
	union {
		float vol;
		bool  set;
	};
};

struct obs_weak_source {
	struct obs_weak_ref ref;
	struct obs_source *source;
};

struct audio_cb_info {
	obs_source_audio_capture_t callback;
	void *param;
};

struct obs_source {
	struct obs_context_data         context;
	struct obs_source_info          info;
	struct obs_weak_source          *control;


	uint32_t                        flags;
	uint32_t                        default_flags;


	bool                            owns_info_id;


	bool                            defer_update;


	volatile long                   show_refs;


	volatile long                   activate_refs;


	bool                            removed;

	bool                            active;
	bool                            showing;


	bool                            enabled;


	volatile bool                   timing_set;
	volatile uint64_t               timing_adjust;
	uint64_t                        resample_offset;
	uint64_t                        last_audio_ts;
	uint64_t                        next_audio_ts_min;
	uint64_t                        next_audio_sys_ts_min;
	uint64_t                        last_frame_ts;
	uint64_t                        last_sys_timestamp;
	bool                            async_rendered;


	bool                            audio_failed;
	bool                            audio_pending;
	bool                            pending_stop;
	bool                            user_muted;
	bool                            muted;
	struct obs_source               *next_audio_source;
	struct obs_source               **prev_next_audio_source;
	uint64_t                        audio_ts;
	struct circlebuf                audio_input_buf[MAX_AUDIO_CHANNELS];
	size_t                          last_audio_input_buf_size;
	DARRAY(struct audio_action)     audio_actions;
	float                           *audio_output_buf[MAX_AUDIO_MIXES][MAX_AUDIO_CHANNELS];
	struct resample_info            sample_info;
	audio_resampler_t               *resampler;
	pthread_mutex_t                 audio_actions_mutex;
	pthread_mutex_t                 audio_buf_mutex;
	pthread_mutex_t                 audio_mutex;
	pthread_mutex_t                 audio_cb_mutex;
	DARRAY(struct audio_cb_info)    audio_cb_list;
	struct obs_audio_data           audio_data;
	size_t                          audio_storage_size;
	uint32_t                        audio_mixers;
	float                           user_volume;
	float                           volume;
	int64_t                         sync_offset;
	int64_t                         last_sync_offset;


	gs_texture_t                    *async_texture;
	gs_texrender_t                  *async_texrender;
	struct obs_source_frame         *cur_async_frame;
	bool                            async_gpu_conversion;
	enum video_format               async_format;
	enum video_format               async_cache_format;
	enum gs_color_format            async_texture_format;
	float                           async_color_matrix[16];
	bool                            async_full_range;
	float                           async_color_range_min[3];
	float                           async_color_range_max[3];
	int                             async_plane_offset[2];
	bool                            async_flip;
	bool                            async_active;
	bool                            async_update_texture;
	bool                            async_unbuffered;
	bool                            async_decoupled;
	struct obs_source_frame         *async_preload_frame;
	DARRAY(struct async_frame)      async_cache;
	DARRAY(struct obs_source_frame*)async_frames;
	pthread_mutex_t                 async_mutex;
	uint32_t                        async_width;
	uint32_t                        async_height;
	uint32_t                        async_cache_width;
	uint32_t                        async_cache_height;
	uint32_t                        async_convert_width;
	uint32_t                        async_convert_height;


	uint64_t                        deinterlace_offset;
	uint64_t                        deinterlace_frame_ts;
	gs_effect_t                     *deinterlace_effect;
	struct obs_source_frame         *prev_async_frame;
	gs_texture_t                    *async_prev_texture;
	gs_texrender_t                  *async_prev_texrender;
	uint32_t                        deinterlace_half_duration;
	enum obs_deinterlace_mode       deinterlace_mode;
	bool                            deinterlace_top_first;
	bool                            deinterlace_rendered;


	struct obs_source               *filter_parent;
	struct obs_source               *filter_target;
	DARRAY(struct obs_source*)      filters;
	pthread_mutex_t                 filter_mutex;
	gs_texrender_t                  *filter_texrender;
	enum obs_allow_direct_render    allow_direct;
	bool                            rendering_filter;


	obs_hotkey_pair_id              mute_unmute_key;
	obs_hotkey_id                   push_to_mute_key;
	obs_hotkey_id                   push_to_talk_key;
	bool                            push_to_mute_enabled;
	bool                            push_to_mute_pressed;
	bool                            user_push_to_mute_pressed;
	bool                            push_to_talk_enabled;
	bool                            push_to_talk_pressed;
	bool                            user_push_to_talk_pressed;
	uint64_t                        push_to_mute_delay;
	uint64_t                        push_to_mute_stop_time;
	uint64_t                        push_to_talk_delay;
	uint64_t                        push_to_talk_stop_time;


	uint64_t                        transition_start_time;
	uint64_t                        transition_duration;
	pthread_mutex_t                 transition_tex_mutex;
	gs_texrender_t                  *transition_texrender[2];
	pthread_mutex_t                 transition_mutex;
	obs_source_t                    *transition_sources[2];
	bool                            transitioning_video;
	bool                            transitioning_audio;
	bool                            transition_source_active[2];
	uint32_t                        transition_alignment;
	uint32_t                        transition_actual_cx;
	uint32_t                        transition_actual_cy;
	uint32_t                        transition_cx;
	uint32_t                        transition_cy;
	uint32_t                        transition_fixed_duration;
	bool                            transition_use_fixed_duration;
	enum obs_transition_mode        transition_mode;
	enum obs_transition_scale_type  transition_scale_type;
	struct matrix4                  transition_matrices[2];

	struct audio_monitor            *monitor;
	enum obs_monitoring_type        monitoring_type;

	obs_data_t                      *private_settings;
};

extern struct obs_source_info *get_source_info(const char *id);
extern bool obs_source_init_context(struct obs_source *source,
		obs_data_t *settings, const char *name,
		obs_data_t *hotkey_data, bool private);

extern bool obs_transition_init(obs_source_t *transition);
extern void obs_transition_free(obs_source_t *transition);
extern void obs_transition_tick(obs_source_t *transition);
extern void obs_transition_enum_sources(obs_source_t *transition,
		obs_source_enum_proc_t enum_callback, void *param);
extern void obs_transition_save(obs_source_t *source, obs_data_t *data);
extern void obs_transition_load(obs_source_t *source, obs_data_t *data);

struct audio_monitor *audio_monitor_create(obs_source_t *source);
void audio_monitor_reset(struct audio_monitor *monitor);
extern void audio_monitor_destroy(struct audio_monitor *monitor);

extern void obs_source_destroy(struct obs_source *source);

enum view_type {
	MAIN_VIEW,
	AUX_VIEW
};

static inline void obs_source_dosignal(struct obs_source *source,
		const char *signal_obs, const char *signal_source)
{
	struct calldata data;
	uint8_t stack[128];

	calldata_init_fixed(&data, stack, sizeof(stack));
	calldata_set_ptr(&data, "source", source);
	if (signal_obs && !source->context.private)
		signal_handler_signal(obs->signals, signal_obs, &data);
	if (signal_source)
		signal_handler_signal(source->context.signals, signal_source,
				&data);
}


#define MAX_TS_VAR          2000000000ULL

static inline bool frame_out_of_bounds(const obs_source_t *source, uint64_t ts)
{
	if (ts < source->last_frame_ts)
		return ((source->last_frame_ts - ts) > MAX_TS_VAR);
	else
		return ((ts - source->last_frame_ts) > MAX_TS_VAR);
}

static inline enum gs_color_format convert_video_format(
		enum video_format format)
{
	if (format == VIDEO_FORMAT_RGBA)
		return GS_RGBA;
	else if (format == VIDEO_FORMAT_BGRA)
		return GS_BGRA;

	return GS_BGRX;
}

extern void obs_source_activate(obs_source_t *source, enum view_type type);
extern void obs_source_deactivate(obs_source_t *source, enum view_type type);
extern void obs_source_video_tick(obs_source_t *source, float seconds);
extern float obs_source_get_target_volume(obs_source_t *source,
		obs_source_t *target);

extern void obs_source_audio_render(obs_source_t *source, uint32_t mixers,
		size_t channels, size_t sample_rate, size_t size);

extern void add_alignment(struct vec2 *v, uint32_t align, int cx, int cy);

extern struct obs_source_frame *filter_async_video(obs_source_t *source,
		struct obs_source_frame *in);
extern bool update_async_texture(struct obs_source *source,
		const struct obs_source_frame *frame,
		gs_texture_t *tex, gs_texrender_t *texrender);
extern bool set_async_texture_size(struct obs_source *source,
		const struct obs_source_frame *frame);
extern void remove_async_frame(obs_source_t *source,
		struct obs_source_frame *frame);

extern void set_deinterlace_texture_size(obs_source_t *source);
extern void deinterlace_process_last_frame(obs_source_t *source,
		uint64_t sys_time);
extern void deinterlace_update_async_video(obs_source_t *source);
extern void deinterlace_render(obs_source_t *s);





enum delay_msg {
	DELAY_MSG_PACKET,
	DELAY_MSG_START,
	DELAY_MSG_STOP,
};

struct delay_data {
	enum delay_msg msg;
	uint64_t ts;
	struct encoder_packet packet;
};

typedef void (*encoded_callback_t)(void *data, struct encoder_packet *packet);

struct obs_weak_output {
	struct obs_weak_ref ref;
	struct obs_output *output;
};

#define CAPTION_LINE_CHARS (32)
#define CAPTION_LINE_BYTES (4*CAPTION_LINE_CHARS)
struct caption_text {
	char text[CAPTION_LINE_BYTES+1];
	struct caption_text *next;
};

struct obs_output {
	struct obs_context_data         context;
	struct obs_output_info          info;
	struct obs_weak_output          *control;


	bool                            owns_info_id;

	bool                            received_video;
	bool                            received_audio;
	volatile bool                   data_active;
	volatile bool                   end_data_capture_thread_active;
	int64_t                         video_offset;
	int64_t                         audio_offsets[MAX_AUDIO_MIXES];
	int64_t                         highest_audio_ts;
	int64_t                         highest_video_ts;
	pthread_t                       end_data_capture_thread;
	os_event_t                      *stopping_event;
	pthread_mutex_t                 interleaved_mutex;
	DARRAY(struct encoder_packet)   interleaved_packets;
	int                             stop_code;

	int                             reconnect_retry_sec;
	int                             reconnect_retry_max;
	int                             reconnect_retries;
	int                             reconnect_retry_cur_sec;
	pthread_t                       reconnect_thread;
	os_event_t                      *reconnect_stop_event;
	volatile bool                   reconnecting;
	volatile bool                   reconnect_thread_active;

	uint32_t                        starting_drawn_count;
	uint32_t                        starting_lagged_count;
	uint32_t                        starting_frame_count;

	int                             total_frames;

	volatile bool                   active;
	video_t                         *video;
	audio_t                         *audio;
	obs_encoder_t                   *video_encoder;
	obs_encoder_t                   *audio_encoders[MAX_AUDIO_MIXES];
	obs_service_t                   *service;
	size_t                          mixer_idx;

	uint32_t                        scaled_width;
	uint32_t                        scaled_height;

	bool                            video_conversion_set;
	bool                            audio_conversion_set;
	struct video_scale_info         video_conversion;
	struct audio_convert_info       audio_conversion;

	pthread_mutex_t                 caption_mutex;
	double                          caption_timestamp;
	struct caption_text             *caption_head;
	struct caption_text             *caption_tail;

	bool                            valid;

	uint64_t                        active_delay_ns;
	encoded_callback_t              delay_callback;
	struct circlebuf                delay_data; 
	pthread_mutex_t                 delay_mutex;
	uint32_t                        delay_sec;
	uint32_t                        delay_flags;
	uint32_t                        delay_cur_flags;
	volatile long                   delay_restart_refs;
	volatile bool                   delay_active;
	volatile bool                   delay_capturing;

	char                            *last_error_message;
};

static inline void do_output_signal(struct obs_output *output,
		const char *signal)
{
	struct calldata params = {0};
	calldata_set_ptr(&params, "output", output);
	signal_handler_signal(output->context.signals, signal, &params);
	calldata_free(&params);
}

extern void process_delay(void *data, struct encoder_packet *packet);
extern void obs_output_cleanup_delay(obs_output_t *output);
extern bool obs_output_delay_start(obs_output_t *output);
extern void obs_output_delay_stop(obs_output_t *output);
extern bool obs_output_actual_start(obs_output_t *output);
extern void obs_output_actual_stop(obs_output_t *output, bool force,
		uint64_t ts);

extern const struct obs_output_info *find_output(const char *id);

extern void obs_output_remove_encoder(struct obs_output *output,
		struct obs_encoder *encoder);

extern void obs_encoder_packet_create_instance(struct encoder_packet *dst,
		const struct encoder_packet *src);
void obs_output_destroy(obs_output_t *output);





struct obs_weak_encoder {
	struct obs_weak_ref ref;
	struct obs_encoder *encoder;
};

struct encoder_callback {
	bool sent_first_packet;
	void (*new_packet)(void *param, struct encoder_packet *packet);
	void *param;
};

struct obs_encoder {
	struct obs_context_data         context;
	struct obs_encoder_info         info;
	struct obs_weak_encoder         *control;

	pthread_mutex_t                 init_mutex;

	uint32_t                        samplerate;
	size_t                          planes;
	size_t                          blocksize;
	size_t                          framesize;
	size_t                          framesize_bytes;

	size_t                          mixer_idx;

	uint32_t                        scaled_width;
	uint32_t                        scaled_height;
	enum video_format               preferred_format;

	volatile bool                   active;
	bool                            initialized;


	bool                            owns_info_id;

	uint32_t                        timebase_num;
	uint32_t                        timebase_den;

	int64_t                         cur_pts;

	struct circlebuf                audio_input_buffer[MAX_AV_PLANES];
	uint8_t                         *audio_output_buffer[MAX_AV_PLANES];


	bool                            wait_for_video;
	bool                            first_received;
	struct obs_encoder              *paired_encoder;
	int64_t                         offset_usec;
	uint64_t                        first_raw_ts;
	uint64_t                        start_ts;

	pthread_mutex_t                 outputs_mutex;
	DARRAY(obs_output_t*)            outputs;

	bool                            destroy_on_stop;


	void                            *media;

	pthread_mutex_t                 callbacks_mutex;
	DARRAY(struct encoder_callback) callbacks;

	const char                      *profile_encoder_encode_name;
};

extern struct obs_encoder_info *find_encoder(const char *id);

extern bool obs_encoder_initialize(obs_encoder_t *encoder);
extern void obs_encoder_shutdown(obs_encoder_t *encoder);

extern void obs_encoder_start(obs_encoder_t *encoder,
		void (*new_packet)(void *param, struct encoder_packet *packet),
		void *param);
extern void obs_encoder_stop(obs_encoder_t *encoder,
		void (*new_packet)(void *param, struct encoder_packet *packet),
		void *param);

extern void obs_encoder_add_output(struct obs_encoder *encoder,
		struct obs_output *output);
extern void obs_encoder_remove_output(struct obs_encoder *encoder,
		struct obs_output *output);

void obs_encoder_destroy(obs_encoder_t *encoder);




struct obs_weak_service {
	struct obs_weak_ref ref;
	struct obs_service *service;
};

struct obs_service {
	struct obs_context_data         context;
	struct obs_service_info         info;
	struct obs_weak_service         *control;


	bool                            owns_info_id;

	bool                            active;
	bool                            destroy;
	struct obs_output               *output;
};

extern const struct obs_service_info *find_service(const char *id);

extern void obs_service_activate(struct obs_service *service);
extern void obs_service_deactivate(struct obs_service *service, bool remove);
extern bool obs_service_initialize(struct obs_service *service,
		struct obs_output *output);

void obs_service_destroy(obs_service_t *service);


<code block>


#pragma once

#include "util/c99defs.h"
#include "util/darray.h"
#include "util/circlebuf.h"
#include "util/dstr.h"
#include "util/threading.h"
#include "util/platform.h"
#include "util/profiler.h"
#include "callback/signal.h"
#include "callback/proc.h"

#include "graphics/graphics.h"
#include "graphics/matrix4.h"

#include "media-io/audio-resampler.h"
#include "media-io/video-io.h"
#include "media-io/audio-io.h"

#include "obs.h"

#define NUM_TEXTURES 2
#define MICROSECOND_DEN 1000000

static inline int64_t packet_dts_usec(struct encoder_packet *packet)
{
	return packet->dts * MICROSECOND_DEN / packet->timebase_den;
}

struct tick_callback {
	void (*tick)(void *param, float seconds);
	void *param;
};

struct draw_callback {
	void (*draw)(void *param, uint32_t cx, uint32_t cy);
	void *param;
};




static inline bool obs_object_valid(const void *obj, const char *f,
		const char *t)
{
	if (!obj) {
		blog(LOG_DEBUG, "%s: Null '%s' parameter", f, t);
		return false;
	}

	return true;
}

#define obs_ptr_valid(ptr, func) obs_object_valid(ptr, func, #ptr)
#define obs_source_valid  obs_ptr_valid
#define obs_output_valid  obs_ptr_valid
#define obs_encoder_valid obs_ptr_valid
#define obs_service_valid obs_ptr_valid




struct obs_module {
	char *mod_name;
	const char *file;
	char *bin_path;
	char *data_path;
	void *module;
	bool loaded;

	bool        (*load)(void);
	void        (*unload)(void);
	void        (*post_load)(void);
	void        (*set_locale)(const char *locale);
	void        (*free_locale)(void);
	uint32_t    (*ver)(void);
	void        (*set_pointer)(obs_module_t *module);
	const char *(*name)(void);
	const char *(*description)(void);
	const char *(*author)(void);

	struct obs_module *next;
};

extern void free_module(struct obs_module *mod);

struct obs_module_path {
	char *bin;
	char *data;
};

static inline void free_module_path(struct obs_module_path *omp)
{
	if (omp) {
		bfree(omp->bin);
		bfree(omp->data);
	}
}

static inline bool check_path(const char *data, const char *path,
		struct dstr *output)
{
	dstr_copy(output, path);
	dstr_cat(output, data);

	return os_file_exists(output->array);
}





struct obs_hotkey {
	obs_hotkey_id               id;
	char                        *name;
	char                        *description;

	obs_hotkey_func             func;
	void                        *data;
	int                         pressed;

	obs_hotkey_registerer_t     registerer_type;
	void                        *registerer;

	obs_hotkey_id               pair_partner_id;
};

struct obs_hotkey_pair {
	obs_hotkey_pair_id          pair_id;
	obs_hotkey_id               id[2];
	obs_hotkey_active_func      func[2];
	bool                        pressed0;
	bool                        pressed1;
	void                        *data[2];
};

typedef struct obs_hotkey_pair obs_hotkey_pair_t;

typedef struct obs_hotkeys_platform obs_hotkeys_platform_t;

void *obs_hotkey_thread(void *param);

struct obs_core_hotkeys;
bool obs_hotkeys_platform_init(struct obs_core_hotkeys *hotkeys);
void obs_hotkeys_platform_free(struct obs_core_hotkeys *hotkeys);
bool obs_hotkeys_platform_is_pressed(obs_hotkeys_platform_t *context,
		obs_key_t key);

const char *obs_get_hotkey_translation(obs_key_t key, const char *def);

struct obs_context_data;
void obs_hotkeys_context_release(struct obs_context_data *context);

void obs_hotkeys_free(void);

struct obs_hotkey_binding {
	obs_key_combination_t       key;
	bool                        pressed;
	bool                        modifiers_match;

	obs_hotkey_id               hotkey_id;
	obs_hotkey_t                *hotkey;
};

struct obs_hotkey_name_map;
void obs_hotkey_name_map_free(void);





struct obs_view {
	pthread_mutex_t                 channels_mutex;
	obs_source_t                    *channels[MAX_CHANNELS];
};

extern bool obs_view_init(struct obs_view *view);
extern void obs_view_free(struct obs_view *view);





struct obs_display {
	bool                            size_changed;
	bool                            enabled;
	uint32_t                        cx, cy;
	uint32_t                        background_color;
	gs_swapchain_t                  *swap;
	pthread_mutex_t                 draw_callbacks_mutex;
	pthread_mutex_t                 draw_info_mutex;
	DARRAY(struct draw_callback)    draw_callbacks;

	struct obs_display              *next;
	struct obs_display              **prev_next;
};

extern bool obs_display_init(struct obs_display *display,
		const struct gs_init_data *graphics_data);
extern void obs_display_free(struct obs_display *display);





struct obs_vframe_info {
	uint64_t timestamp;
	int count;
};

struct obs_core_video {
	graphics_t                      *graphics;
	gs_stagesurf_t                  *copy_surfaces[NUM_TEXTURES];
	gs_texture_t                    *render_textures[NUM_TEXTURES];
	gs_texture_t                    *output_textures[NUM_TEXTURES];
	gs_texture_t                    *convert_textures[NUM_TEXTURES];
	bool                            textures_rendered[NUM_TEXTURES];
	bool                            textures_output[NUM_TEXTURES];
	bool                            textures_copied[NUM_TEXTURES];
	bool                            textures_converted[NUM_TEXTURES];
	struct circlebuf                vframe_info_buffer;
	gs_effect_t                     *default_effect;
	gs_effect_t                     *default_rect_effect;
	gs_effect_t                     *opaque_effect;
	gs_effect_t                     *solid_effect;
	gs_effect_t                     *conversion_effect;
	gs_effect_t                     *bicubic_effect;
	gs_effect_t                     *lanczos_effect;
	gs_effect_t                     *bilinear_lowres_effect;
	gs_effect_t                     *premultiplied_alpha_effect;
	gs_samplerstate_t               *point_sampler;
	gs_stagesurf_t                  *mapped_surface;
	int                             cur_texture;

	uint64_t                        video_time;
	uint64_t                        video_avg_frame_time_ns;
	double                          video_fps;
	video_t                         *video;
	pthread_t                       video_thread;
	uint32_t                        total_frames;
	uint32_t                        lagged_frames;
	bool                            thread_initialized;

	bool                            gpu_conversion;
	const char                      *conversion_tech;
	uint32_t                        conversion_height;
	uint32_t                        plane_offsets[3];
	uint32_t                        plane_sizes[3];
	uint32_t                        plane_linewidth[3];

	uint32_t                        output_width;
	uint32_t                        output_height;
	uint32_t                        base_width;
	uint32_t                        base_height;
	float                           color_matrix[16];
	enum obs_scale_type             scale_type;

	gs_texture_t                    *transparent_texture;

	gs_effect_t                     *deinterlace_discard_effect;
	gs_effect_t                     *deinterlace_discard_2x_effect;
	gs_effect_t                     *deinterlace_linear_effect;
	gs_effect_t                     *deinterlace_linear_2x_effect;
	gs_effect_t                     *deinterlace_blend_effect;
	gs_effect_t                     *deinterlace_blend_2x_effect;
	gs_effect_t                     *deinterlace_yadif_effect;
	gs_effect_t                     *deinterlace_yadif_2x_effect;

	struct obs_video_info           ovi;
};

struct audio_monitor;

struct obs_core_audio {
	audio_t                         *audio;

	DARRAY(struct obs_source*)      render_order;
	DARRAY(struct obs_source*)      root_nodes;

	uint64_t                        buffered_ts;
	struct circlebuf                buffered_timestamps;
	int                             buffering_wait_ticks;
	int                             total_buffering_ticks;

	float                           user_volume;

	pthread_mutex_t                 monitoring_mutex;
	DARRAY(struct audio_monitor*)   monitors;
	char                            *monitoring_device_name;
	char                            *monitoring_device_id;
};


struct obs_core_data {
	struct obs_source               *first_source;
	struct obs_source               *first_audio_source;
	struct obs_display              *first_display;
	struct obs_output               *first_output;
	struct obs_encoder              *first_encoder;
	struct obs_service              *first_service;

	pthread_mutex_t                 sources_mutex;
	pthread_mutex_t                 displays_mutex;
	pthread_mutex_t                 outputs_mutex;
	pthread_mutex_t                 encoders_mutex;
	pthread_mutex_t                 services_mutex;
	pthread_mutex_t                 audio_sources_mutex;
	pthread_mutex_t                 draw_callbacks_mutex;
	DARRAY(struct draw_callback)    draw_callbacks;
	DARRAY(struct tick_callback)    tick_callbacks;

	struct obs_view                 main_view;

	long long                       unnamed_index;

	volatile bool                   valid;
};


struct obs_core_hotkeys {
	pthread_mutex_t                 mutex;
	DARRAY(obs_hotkey_t)            hotkeys;
	obs_hotkey_id                   next_id;
	DARRAY(obs_hotkey_pair_t)       hotkey_pairs;
	obs_hotkey_pair_id              next_pair_id;

	pthread_t                       hotkey_thread;
	bool                            hotkey_thread_initialized;
	os_event_t                      *stop_event;
	bool                            thread_disable_press;
	bool                            strict_modifiers;
	bool                            reroute_hotkeys;
	DARRAY(obs_hotkey_binding_t)    bindings;

	obs_hotkey_callback_router_func router_func;
	void                            *router_func_data;

	obs_hotkeys_platform_t          *platform_context;

	pthread_once_t                  name_map_init_token;
	struct obs_hotkey_name_map      *name_map;

	signal_handler_t                *signals;

	char                            *translations[OBS_KEY_LAST_VALUE];
	char                            *mute;
	char                            *unmute;
	char                            *push_to_mute;
	char                            *push_to_talk;
	char                            *sceneitem_show;
	char                            *sceneitem_hide;
};

struct obs_core {
	struct obs_module               *first_module;
	DARRAY(struct obs_module_path)  module_paths;

	DARRAY(struct obs_source_info)  source_types;
	DARRAY(struct obs_source_info)  input_types;
	DARRAY(struct obs_source_info)  filter_types;
	DARRAY(struct obs_source_info)  transition_types;
	DARRAY(struct obs_output_info)  output_types;
	DARRAY(struct obs_encoder_info) encoder_types;
	DARRAY(struct obs_service_info) service_types;
	DARRAY(struct obs_modal_ui)     modal_ui_callbacks;
	DARRAY(struct obs_modeless_ui)  modeless_ui_callbacks;

	signal_handler_t                *signals;
	proc_handler_t                  *procs;

	char                            *locale;
	char                            *module_config_path;
	bool                            name_store_owned;
	profiler_name_store_t           *name_store;


	struct obs_core_video           video;
	struct obs_core_audio           audio;
	struct obs_core_data            data;
	struct obs_core_hotkeys         hotkeys;
};

extern struct obs_core *obs;

extern void *obs_graphics_thread(void *param);

extern gs_effect_t *obs_load_effect(gs_effect_t **effect, const char *file);

extern bool audio_callback(void *param,
		uint64_t start_ts_in, uint64_t end_ts_in, uint64_t *out_ts,
		uint32_t mixers, struct audio_output_data *mixes);





struct obs_context_data {
	char                            *name;
	void                            *data;
	obs_data_t                      *settings;
	signal_handler_t                *signals;
	proc_handler_t                  *procs;
	enum obs_obj_type               type;

	DARRAY(obs_hotkey_id)           hotkeys;
	DARRAY(obs_hotkey_pair_id)      hotkey_pairs;
	obs_data_t                      *hotkey_data;

	DARRAY(char*)                   rename_cache;
	pthread_mutex_t                 rename_cache_mutex;

	pthread_mutex_t                 *mutex;
	struct obs_context_data         *next;
	struct obs_context_data         **prev_next;

	bool                            private;
};

extern bool obs_context_data_init(
		struct obs_context_data *context,
		enum obs_obj_type       type,
		obs_data_t              *settings,
		const char              *name,
		obs_data_t              *hotkey_data,
		bool                    private);
extern void obs_context_data_free(struct obs_context_data *context);

extern void obs_context_data_insert(struct obs_context_data *context,
		pthread_mutex_t *mutex, void *first);
extern void obs_context_data_remove(struct obs_context_data *context);

extern void obs_context_data_setname(struct obs_context_data *context,
		const char *name);





struct obs_weak_ref {
	volatile long refs;
	volatile long weak_refs;
};

static inline void obs_ref_addref(struct obs_weak_ref *ref)
{
	os_atomic_inc_long(&ref->refs);
}

static inline bool obs_ref_release(struct obs_weak_ref *ref)
{
	return os_atomic_dec_long(&ref->refs) == -1;
}

static inline void obs_weak_ref_addref(struct obs_weak_ref *ref)
{
	os_atomic_inc_long(&ref->weak_refs);
}

static inline bool obs_weak_ref_release(struct obs_weak_ref *ref)
{
	return os_atomic_dec_long(&ref->weak_refs) == -1;
}

static inline bool obs_weak_ref_get_ref(struct obs_weak_ref *ref)
{
	long owners = ref->refs;
	while (owners > -1) {
		if (os_atomic_compare_swap_long(&ref->refs, owners, owners + 1))
			return true;

		owners = ref->refs;
	}

	return false;
}





struct async_frame {
	struct obs_source_frame *frame;
	long unused_count;
	bool used;
};

enum audio_action_type {
	AUDIO_ACTION_VOL,
	AUDIO_ACTION_MUTE,
	AUDIO_ACTION_PTT,
	AUDIO_ACTION_PTM,
};

struct audio_action {
	uint64_t timestamp;
	enum audio_action_type type;
	union {
		float vol;
		bool  set;
	};
};

struct obs_weak_source {
	struct obs_weak_ref ref;
	struct obs_source *source;
};

struct audio_cb_info {
	obs_source_audio_capture_t callback;
	void *param;
};

struct obs_source {
	struct obs_context_data         context;
	struct obs_source_info          info;
	struct obs_weak_source          *control;


	uint32_t                        flags;
	uint32_t                        default_flags;


	bool                            owns_info_id;


	bool                            defer_update;


	volatile long                   show_refs;


	volatile long                   activate_refs;


	bool                            removed;

	bool                            active;
	bool                            showing;


	bool                            enabled;


	volatile bool                   timing_set;
	volatile uint64_t               timing_adjust;
	uint64_t                        resample_offset;
	uint64_t                        last_audio_ts;
	uint64_t                        next_audio_ts_min;
	uint64_t                        next_audio_sys_ts_min;
	uint64_t                        last_frame_ts;
	uint64_t                        last_sys_timestamp;
	bool                            async_rendered;


	bool                            audio_failed;
	bool                            audio_pending;
	bool                            pending_stop;
	bool                            user_muted;
	bool                            muted;
	struct obs_source               *next_audio_source;
	struct obs_source               **prev_next_audio_source;
	uint64_t                        audio_ts;
	struct circlebuf                audio_input_buf[MAX_AUDIO_CHANNELS];
	size_t                          last_audio_input_buf_size;
	DARRAY(struct audio_action)     audio_actions;
	float                           *audio_output_buf[MAX_AUDIO_MIXES][MAX_AUDIO_CHANNELS];
	struct resample_info            sample_info;
	audio_resampler_t               *resampler;
	pthread_mutex_t                 audio_actions_mutex;
	pthread_mutex_t                 audio_buf_mutex;
	pthread_mutex_t                 audio_mutex;
	pthread_mutex_t                 audio_cb_mutex;
	DARRAY(struct audio_cb_info)    audio_cb_list;
	struct obs_audio_data           audio_data;
	size_t                          audio_storage_size;
	uint32_t                        audio_mixers;
	float                           user_volume;
	float                           volume;
	int64_t                         sync_offset;
	int64_t                         last_sync_offset;


	gs_texture_t                    *async_texture;
	gs_texrender_t                  *async_texrender;
	struct obs_source_frame         *cur_async_frame;
	bool                            async_gpu_conversion;
	enum video_format               async_format;
	enum video_format               async_cache_format;
	enum gs_color_format            async_texture_format;
	float                           async_color_matrix[16];
	bool                            async_full_range;
	float                           async_color_range_min[3];
	float                           async_color_range_max[3];
	int                             async_plane_offset[2];
	bool                            async_flip;
	bool                            async_active;
	bool                            async_update_texture;
	bool                            async_unbuffered;
	bool                            async_decoupled;
	struct obs_source_frame         *async_preload_frame;
	DARRAY(struct async_frame)      async_cache;
	DARRAY(struct obs_source_frame*)async_frames;
	pthread_mutex_t                 async_mutex;
	uint32_t                        async_width;
	uint32_t                        async_height;
	uint32_t                        async_cache_width;
	uint32_t                        async_cache_height;
	uint32_t                        async_convert_width;
	uint32_t                        async_convert_height;


	uint64_t                        deinterlace_offset;
	uint64_t                        deinterlace_frame_ts;
	gs_effect_t                     *deinterlace_effect;
	struct obs_source_frame         *prev_async_frame;
	gs_texture_t                    *async_prev_texture;
	gs_texrender_t                  *async_prev_texrender;
	uint32_t                        deinterlace_half_duration;
	enum obs_deinterlace_mode       deinterlace_mode;
	bool                            deinterlace_top_first;
	bool                            deinterlace_rendered;


	struct obs_source               *filter_parent;
	struct obs_source               *filter_target;
	DARRAY(struct obs_source*)      filters;
	pthread_mutex_t                 filter_mutex;
	gs_texrender_t                  *filter_texrender;
	enum obs_allow_direct_render    allow_direct;
	bool                            rendering_filter;


	obs_hotkey_pair_id              mute_unmute_key;
	obs_hotkey_id                   push_to_mute_key;
	obs_hotkey_id                   push_to_talk_key;
	bool                            push_to_mute_enabled;
	bool                            push_to_mute_pressed;
	bool                            user_push_to_mute_pressed;
	bool                            push_to_talk_enabled;
	bool                            push_to_talk_pressed;
	bool                            user_push_to_talk_pressed;
	uint64_t                        push_to_mute_delay;
	uint64_t                        push_to_mute_stop_time;
	uint64_t                        push_to_talk_delay;
	uint64_t                        push_to_talk_stop_time;


	uint64_t                        transition_start_time;
	uint64_t                        transition_duration;
	pthread_mutex_t                 transition_tex_mutex;
	gs_texrender_t                  *transition_texrender[2];
	pthread_mutex_t                 transition_mutex;
	obs_source_t                    *transition_sources[2];
	bool                            transitioning_video;
	bool                            transitioning_audio;
	bool                            transition_source_active[2];
	uint32_t                        transition_alignment;
	uint32_t                        transition_actual_cx;
	uint32_t                        transition_actual_cy;
	uint32_t                        transition_cx;
	uint32_t                        transition_cy;
	uint32_t                        transition_fixed_duration;
	bool                            transition_use_fixed_duration;
	enum obs_transition_mode        transition_mode;
	enum obs_transition_scale_type  transition_scale_type;
	struct matrix4                  transition_matrices[2];

	struct audio_monitor            *monitor;
	enum obs_monitoring_type        monitoring_type;

	obs_data_t                      *private_settings;
};

extern struct obs_source_info *get_source_info(const char *id);
extern bool obs_source_init_context(struct obs_source *source,
		obs_data_t *settings, const char *name,
		obs_data_t *hotkey_data, bool private);

extern void obs_source_save(obs_source_t *source);
extern void obs_source_load(obs_source_t *source);

extern bool obs_transition_init(obs_source_t *transition);
extern void obs_transition_free(obs_source_t *transition);
extern void obs_transition_tick(obs_source_t *transition);
extern void obs_transition_enum_sources(obs_source_t *transition,
		obs_source_enum_proc_t enum_callback, void *param);
extern void obs_transition_save(obs_source_t *source, obs_data_t *data);
extern void obs_transition_load(obs_source_t *source, obs_data_t *data);

struct audio_monitor *audio_monitor_create(obs_source_t *source);
void audio_monitor_reset(struct audio_monitor *monitor);
extern void audio_monitor_destroy(struct audio_monitor *monitor);

extern void obs_source_destroy(struct obs_source *source);

enum view_type {
	MAIN_VIEW,
	AUX_VIEW
};

static inline void obs_source_dosignal(struct obs_source *source,
		const char *signal_obs, const char *signal_source)
{
	struct calldata data;
	uint8_t stack[128];

	calldata_init_fixed(&data, stack, sizeof(stack));
	calldata_set_ptr(&data, "source", source);
	if (signal_obs && !source->context.private)
		signal_handler_signal(obs->signals, signal_obs, &data);
	if (signal_source)
		signal_handler_signal(source->context.signals, signal_source,
				&data);
}


#define MAX_TS_VAR          2000000000ULL

static inline bool frame_out_of_bounds(const obs_source_t *source, uint64_t ts)
{
	if (ts < source->last_frame_ts)
		return ((source->last_frame_ts - ts) > MAX_TS_VAR);
	else
		return ((ts - source->last_frame_ts) > MAX_TS_VAR);
}

static inline enum gs_color_format convert_video_format(
		enum video_format format)
{
	if (format == VIDEO_FORMAT_RGBA)
		return GS_RGBA;
	else if (format == VIDEO_FORMAT_BGRA)
		return GS_BGRA;

	return GS_BGRX;
}

extern void obs_source_activate(obs_source_t *source, enum view_type type);
extern void obs_source_deactivate(obs_source_t *source, enum view_type type);
extern void obs_source_video_tick(obs_source_t *source, float seconds);
extern float obs_source_get_target_volume(obs_source_t *source,
		obs_source_t *target);

extern void obs_source_audio_render(obs_source_t *source, uint32_t mixers,
		size_t channels, size_t sample_rate, size_t size);

extern void add_alignment(struct vec2 *v, uint32_t align, int cx, int cy);

extern struct obs_source_frame *filter_async_video(obs_source_t *source,
		struct obs_source_frame *in);
extern bool update_async_texture(struct obs_source *source,
		const struct obs_source_frame *frame,
		gs_texture_t *tex, gs_texrender_t *texrender);
extern bool set_async_texture_size(struct obs_source *source,
		const struct obs_source_frame *frame);
extern void remove_async_frame(obs_source_t *source,
		struct obs_source_frame *frame);

extern void set_deinterlace_texture_size(obs_source_t *source);
extern void deinterlace_process_last_frame(obs_source_t *source,
		uint64_t sys_time);
extern void deinterlace_update_async_video(obs_source_t *source);
extern void deinterlace_render(obs_source_t *s);





enum delay_msg {
	DELAY_MSG_PACKET,
	DELAY_MSG_START,
	DELAY_MSG_STOP,
};

struct delay_data {
	enum delay_msg msg;
	uint64_t ts;
	struct encoder_packet packet;
};

typedef void (*encoded_callback_t)(void *data, struct encoder_packet *packet);

struct obs_weak_output {
	struct obs_weak_ref ref;
	struct obs_output *output;
};

#define CAPTION_LINE_CHARS (32)
#define CAPTION_LINE_BYTES (4*CAPTION_LINE_CHARS)
struct caption_text {
	char text[CAPTION_LINE_BYTES+1];
	struct caption_text *next;
};

struct obs_output {
	struct obs_context_data         context;
	struct obs_output_info          info;
	struct obs_weak_output          *control;


	bool                            owns_info_id;

	bool                            received_video;
	bool                            received_audio;
	volatile bool                   data_active;
	volatile bool                   end_data_capture_thread_active;
	int64_t                         video_offset;
	int64_t                         audio_offsets[MAX_AUDIO_MIXES];
	int64_t                         highest_audio_ts;
	int64_t                         highest_video_ts;
	pthread_t                       end_data_capture_thread;
	os_event_t                      *stopping_event;
	pthread_mutex_t                 interleaved_mutex;
	DARRAY(struct encoder_packet)   interleaved_packets;
	int                             stop_code;

	int                             reconnect_retry_sec;
	int                             reconnect_retry_max;
	int                             reconnect_retries;
	int                             reconnect_retry_cur_sec;
	pthread_t                       reconnect_thread;
	os_event_t                      *reconnect_stop_event;
	volatile bool                   reconnecting;
	volatile bool                   reconnect_thread_active;

	uint32_t                        starting_drawn_count;
	uint32_t                        starting_lagged_count;
	uint32_t                        starting_frame_count;

	int                             total_frames;

	volatile bool                   active;
	video_t                         *video;
	audio_t                         *audio;
	obs_encoder_t                   *video_encoder;
	obs_encoder_t                   *audio_encoders[MAX_AUDIO_MIXES];
	obs_service_t                   *service;
	size_t                          mixer_idx;

	uint32_t                        scaled_width;
	uint32_t                        scaled_height;

	bool                            video_conversion_set;
	bool                            audio_conversion_set;
	struct video_scale_info         video_conversion;
	struct audio_convert_info       audio_conversion;

	pthread_mutex_t                 caption_mutex;
	double                          caption_timestamp;
	struct caption_text             *caption_head;
	struct caption_text             *caption_tail;

	bool                            valid;

	uint64_t                        active_delay_ns;
	encoded_callback_t              delay_callback;
	struct circlebuf                delay_data; 
	pthread_mutex_t                 delay_mutex;
	uint32_t                        delay_sec;
	uint32_t                        delay_flags;
	uint32_t                        delay_cur_flags;
	volatile long                   delay_restart_refs;
	volatile bool                   delay_active;
	volatile bool                   delay_capturing;

	char                            *last_error_message;
};

static inline void do_output_signal(struct obs_output *output,
		const char *signal)
{
	struct calldata params = {0};
	calldata_set_ptr(&params, "output", output);
	signal_handler_signal(output->context.signals, signal, &params);
	calldata_free(&params);
}

extern void process_delay(void *data, struct encoder_packet *packet);
extern void obs_output_cleanup_delay(obs_output_t *output);
extern bool obs_output_delay_start(obs_output_t *output);
extern void obs_output_delay_stop(obs_output_t *output);
extern bool obs_output_actual_start(obs_output_t *output);
extern void obs_output_actual_stop(obs_output_t *output, bool force,
		uint64_t ts);

extern const struct obs_output_info *find_output(const char *id);

extern void obs_output_remove_encoder(struct obs_output *output,
		struct obs_encoder *encoder);

extern void obs_encoder_packet_create_instance(struct encoder_packet *dst,
		const struct encoder_packet *src);
void obs_output_destroy(obs_output_t *output);





struct obs_weak_encoder {
	struct obs_weak_ref ref;
	struct obs_encoder *encoder;
};

struct encoder_callback {
	bool sent_first_packet;
	void (*new_packet)(void *param, struct encoder_packet *packet);
	void *param;
};

struct obs_encoder {
	struct obs_context_data         context;
	struct obs_encoder_info         info;
	struct obs_weak_encoder         *control;

	pthread_mutex_t                 init_mutex;

	uint32_t                        samplerate;
	size_t                          planes;
	size_t                          blocksize;
	size_t                          framesize;
	size_t                          framesize_bytes;

	size_t                          mixer_idx;

	uint32_t                        scaled_width;
	uint32_t                        scaled_height;
	enum video_format               preferred_format;

	volatile bool                   active;
	bool                            initialized;


	bool                            owns_info_id;

	uint32_t                        timebase_num;
	uint32_t                        timebase_den;

	int64_t                         cur_pts;

	struct circlebuf                audio_input_buffer[MAX_AV_PLANES];
	uint8_t                         *audio_output_buffer[MAX_AV_PLANES];


	bool                            wait_for_video;
	bool                            first_received;
	struct obs_encoder              *paired_encoder;
	int64_t                         offset_usec;
	uint64_t                        first_raw_ts;
	uint64_t                        start_ts;

	pthread_mutex_t                 outputs_mutex;
	DARRAY(obs_output_t*)            outputs;

	bool                            destroy_on_stop;


	void                            *media;

	pthread_mutex_t                 callbacks_mutex;
	DARRAY(struct encoder_callback) callbacks;

	const char                      *profile_encoder_encode_name;
};

extern struct obs_encoder_info *find_encoder(const char *id);

extern bool obs_encoder_initialize(obs_encoder_t *encoder);
extern void obs_encoder_shutdown(obs_encoder_t *encoder);

extern void obs_encoder_start(obs_encoder_t *encoder,
		void (*new_packet)(void *param, struct encoder_packet *packet),
		void *param);
extern void obs_encoder_stop(obs_encoder_t *encoder,
		void (*new_packet)(void *param, struct encoder_packet *packet),
		void *param);

extern void obs_encoder_add_output(struct obs_encoder *encoder,
		struct obs_output *output);
extern void obs_encoder_remove_output(struct obs_encoder *encoder,
		struct obs_output *output);

void obs_encoder_destroy(obs_encoder_t *encoder);




struct obs_weak_service {
	struct obs_weak_ref ref;
	struct obs_service *service;
};

struct obs_service {
	struct obs_context_data         context;
	struct obs_service_info         info;
	struct obs_weak_service         *control;


	bool                            owns_info_id;

	bool                            active;
	bool                            destroy;
	struct obs_output               *output;
};

extern const struct obs_service_info *find_service(const char *id);

extern void obs_service_activate(struct obs_service *service);
extern void obs_service_deactivate(struct obs_service *service, bool remove);
extern bool obs_service_initialize(struct obs_service *service,
		struct obs_output *output);

void obs_service_destroy(obs_service_t *service);

